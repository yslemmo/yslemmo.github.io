<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Win10 家庭版启动组策略组件]]></title>
    <url>%2Fpost%2Fwin10-home-gpedit.html</url>
    <content type="text"><![CDATA[前言我之前用的系统一直是WIn10专业版，但是我手上这台笔记本是自带的家庭版，刚好今天需要在组策略中配置一些设置，通过Win+R 运行 gpedit.msc时却无法打开组策略，才知道家庭版是没有组策略这一功能的。本来都想着更换专业版的密钥，再用ksm来激活。 但通过搜索后发现，专业版和家庭版的镜像文件其实时一样的，想起来之前装系统的时有一个选择系统版本的选项，既然镜像文件时一样的，那么家庭版系统中肯定也有「组策略」这个功能，只是系统限制了这一功能，我们只要手动让它启动起来即可。 启动组策略功能 新建一个txt文件，比如a.txt 在文本文件中，粘贴进几行代码： 123456@echo offpushd "%~dp0"dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txtdir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txtfor /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i"pause 把该文本文件的后缀改成可执行文件，如a.cmd 右键单机a.cmd，并以管理员身份运行 等待执行完毕 Win+Q或Win+R搜索运行gpedit.msc，即可打开组策略]]></content>
      <categories>
        <category>Computer skills</category>
      </categories>
      <tags>
        <tag>gpedit</tag>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速迁移系统]]></title>
    <url>%2Fpost%2FMove-System.html</url>
    <content type="text"><![CDATA[前言我的笔记本内置的固态是三星的一款M.2的SSD，但是是SATA协议的，因此只有500M/S的速率，但是另外空出来的一个插槽支持NVME协议。618的时候在京东上买了Intel 760P，装上之后才发现，这个插槽虽然支持NVME协议，但是只有2个通道，所以应该是PCIE * 2，速度只能达到正常速度的一半（读写都在1700M/S左右），后来想想买都买了懒得换了，至少比SATA的快。 装上固态，迁移系统装固态没啥好写的，这里说一下装固态期间发生的一个小插曲。话说去取快递那天中午是刚参加完毕业典礼回来，下午还要去修改论文。因此想趁着中午的时候，就把固态装上测试一下，用买固态附送的小螺丝刀三五下就把外壳取下来，但取固态插槽那颗螺丝的时候给我整懵逼了，刚扭了一下螺丝就滑丝了。当时就在吐槽，机械革命你踏马为什么多此一举在这放一颗螺丝，放的话为什么不放一颗质量好一点的螺丝，吐槽归吐槽，还是要想办法把螺丝取下来，然后我就用小刀一点点给这颗螺丝刻凹槽，然后用一字起把这颗螺丝刀取出来了，最后换上买固态附送的螺丝。 Fine，装上固态之后，测了一下速便感觉一切索然无味。 直到今天，才想着把系统迁移到这块NVME的固态上，那么究竟用什么工具来迁移呢？其实很简单，大部分的磁盘工具都支持「磁盘克隆」，比如傲梅分区助手、DiskGenius。而我使用的是因特尔数据迁移软件（Intel Data Migration Software），软件界面如下图所示： 这里有很多工具可以使用，但目前只需要使用第一个工具——「复制磁盘」，该工具的介绍为: 该实用程序可帮助您将操作系统、应用程序和数据复制到新磁盘。新磁盘将与旧磁盘完全相同，而且会保留系统可启动性。 进入工具后，在向导窗口根据步骤一步一步来操作就可以了，第一步是选择源磁盘，第二步选择目标磁盘，大概10分钟左右就可以全部完成（取决去你的两块硬盘的速度） 克隆完成后，在资源管理器看不到目标磁盘，为了等会开机后区分新旧磁盘，可以在当前系统桌面上随便创建一个问题，比如创建一个txt文件。一些准备就绪之后，关机，再直接开机，发现桌面上没有刚才创建的那个txt文件，说明当前的系统已经是克隆后的系统，另外新硬盘的盘符也会与旧硬盘的盘符交换了，也不用自己取手动变更盘符了。]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「我不知道该说什么，关于死亡还是爱情」书评]]></title>
    <url>%2Fpost%2FVoices-from-Chernobyl.html</url>
    <content type="text"><![CDATA[Title 我不知道该说什么，关于死亡还是爱情 Author [白俄罗斯]S.A.阿列克谢耶维奇 Edition 花城出版社 Release Date 2014-06 ISBN 9787536071377 近期HBO的美剧《Chernobyl》的播出再次引起了我们对发生了三十多年前的那场悲剧的关注，由于前几年读也阅读了一本记录了切尔诺贝利的书，因此旧文重发，注意这本书还有另一个翻译版本——《切尔诺贝利的悲鸣》。以下部分为原文： 我从未读过如此悲伤的文字，切尔诺贝利——这里所遇到在灾难是我从未看到的或者知道的，我只能用然人间地狱来称呼这里。 背景切尔诺贝利是前苏联的一部分，属于白俄罗斯的领土。在1986年切尔诺贝利核电站四号反应堆发生大爆炸，这次灾难所释放出的辐射线剂量是投在广岛的原子弹的400倍以上。因这次事件死亡的人物不计其数，现在在这个只有一千多万人的小国中每五个人就有一个住在辐射区，总数为二百一十万，其中七十万是儿童。在受灾最重的地区死亡率比出生率高了20%！ 这里的一切都是真实发生的，书中的每一段文字都是作者 S.A.阿列克谢列维奇走访受灾群众口述而成的。 国家的英雄消防员瓦西里是最先进入爆炸核电站的人员之一，几个小时后他便被救护车送回来了，14天后由于大量辐射死于器官衰竭。“他是被自己的内脏呛到的，稍微咳嗽一下，他的肺和肝都可能随时从嘴巴里跑出来。”，讲述这个故事的人是他的妻子，那个时候她正怀有4个月的身孕，对于一般的人来说，原本这个时候正是她人生中最幸福的时刻，但却不得不面对这样的现实。对于吸收了1600伦琴辐射的丈夫（400伦琴就可致死），她选择的不是逃避，她骗了所有人，甚至不顾肚子里面的孩子偷偷跑到隔离间去照顾他，他全身溃烂，衣服沾到身上，妻子一点一点的帮他清理，给他喂药，陪着他说话。 什么是爱情，我没有经历过。但我想为了心中的挚爱就算是冒着生命危险也在所不惜，如果面对如此情形，我会如何选择呢？是转身离开把他和他的记忆留在记忆深处，开始一段新的生活。还是默默陪伴在她的身边，就算是死亡也在所不惜。 在这里，和瓦西里一样的年轻人不断从各地赶来。他们被叫做是国家的英雄，而国家给他们的任务却是用“铲子对抗原子”，多么荒谬的事情，他们在几百伦琴辐射工作，没有任何有效的保护装备。在年轻人中流传着一个笑话，一个美国机器人上屋顶作业五分钟，然后就发生故障了。日本机器人也上去作业了五分钟，然后也发生故障了。俄罗斯机器人来了，一上去就是两个小时！这时扩音器里传来了命令：“二等兵伊凡诺夫！再过两个小时，你就可以下来休息，抽根烟了。” 他们是国家的绿色机器人，在他们死亡时留给家人的只有刻有马克思、列宁头像的奖章。而国家给他们承诺的房子、车子消失了。 无处不在的污染切尔诺贝利是最可怕的战争，你无处可逃，地下、水里，空中都躲不了。牛奶，事物，土地中都含有大量的辐射。母亲在家门口哺乳，就像是切尔诺贝利的圣母，但她的母乳里却含有大量的铯元素，相当于是另一种凶猛的毒药，但是母亲是不自知的。 切尔诺贝利的人民，他们都不知道发生了什么。政府给他们的回复是“情势稳定”，一切还是和爆炸以前的一样。他们依然坚守在自己的土地上，对于他们来说，少了政府的管制倒也自由些了。而正是由于政府的愚弄和科学家的沉默让更多的切尔诺贝利的居民生活在辐射之中。 切尔诺贝利的人突然有一天，你变成了切尔诺贝利人，变成了某种特殊的物种，大家对你感兴趣，却没有人真正愿意了解你。 如果仅仅只是这样，那也并不糟糕，让人感到痛心的是，切尔诺贝利的人们不仅要背负辐射的污染，更要背负人心的疏离。 他们坐火车的时候，当得知他们是从切尔诺贝利来的，乘务员不愿意供给他们餐具和被子，周围的人也一下子保持沉默和疏离。上学的孩子一旦被得知是切尔诺贝利人，所有的小孩都排斥他，疏远他，不愿意更他交朋友，更不愿意亲近他。 而更让人感到荒诞的是，从切尔诺贝利事件中的幸存者，在面对爱情和婚姻时，遭到拒绝的理由却是：“你不能生孩子，生小孩对你来说是罪恶的。爱一个人对你来说都是一种罪恶”。亲历的讲述者说，你知道生小孩可能是一种罪吗？我以前从来没听过这种事。 受到核污染之后的好几年里，很多人并不愿意离开切尔诺贝利，他们知道自己无时无刻不遭受着污染，但是他们不愿离开，而这其中的原因是，因为在切尔诺贝利没有人会以怪异的眼光来看待你，也不会遭到他人的疏离、冷遇和提防。“至少当我拿自家的苹果给对方吃时，他会很高兴坦然的接受，而不是在转身就把这苹果处理掉。” 让人感到痛心的是，切尔诺贝利的核污染现在仍然在继续，战争的伤痛总有停止的那一天，但是核辐射带来的污染却是无止境，也无从消灭。当我们在享受科技带来的便捷的同时，也不应忘却科技曾带给我们的灾难！]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>纪实</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「中国国家治理的制度逻辑」读书笔记]]></title>
    <url>%2Fpost%2FThe-Institutional-Logic-of-Governance-In-China.html</url>
    <content type="text"><![CDATA[Title 中国国家治理的制度逻辑 Author 周雪光 Edition 三联书店 Release Date 2017-02 ISBN 9787559626295 摘录 中国国家治理的一个深刻矛盾是一统体制与有效治理之间的矛盾。 国家治理模式决定了其政治运行特定的优势、负荷、困难和挑战。国家治理模式不是任意选择的，常常与个国家的历史演变过程有着深刻关系，有明显的途径依赖性。 一统体制的集中程度越高、越刚性，必然以相应程度上削弱地方治理权为代价，其有效治理的能力就会相应减弱；反之，有效治理能力的增强意味看地方政府治理权的扩张，常常表现在或被解读为各自为政，又会对一统体制产生巨大威胁。]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>政治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「民主的逻辑」读书笔记]]></title>
    <url>%2Fpost%2FDemocracy-Logic.html</url>
    <content type="text"><![CDATA[Title 民主的逻辑 Author 包刚升 Edition 社会科学文献出版社 Release Date 2018-06 ISBN 9787520125819 摘录 一个自由社会的良好公民需要同时做到两点，一是主张和捍卫自己应用的权力，二是遵守经合法程序指定的法律及服从合法的权威。 人是生而自由的，但却无往不在枷锁之中。自以为是其他一切的主人的人，反而比其他一切更是奴隶。——《社会契约论》 没有人假装民主是完美的和全智的（all wise），民主其实是最坏的政府形式，但要除了所有过去已经被尝试过的政府形式以外。——丘吉尔 经验告诉我们，民主转型更可能是一个结果不确定、充满各种挑战、历时漫长的政治过程。 自由是“一个人不受其他某人或某些人武断意志的强制”，或者说自由就是免于强制。——弗里德里希·哈耶克 现代民主是一种复合型政体，包含了古希腊贡献的民主因素古罗马贡献的共和主义传统、英格兰贡献的成熟代议制以及欧洲北美所贡献的政治平等逻辑。——罗伯特·达尔 欧洲历史意义上的封建主义体制是封君与封臣之间基于土地、融合了财产权利与政治权利的契约关系。这种契约关系的核心是:封君或领主应提供保护和尊重习惯，而封臣或附庸应提供兵役和表示效忠。 《独立宣言》开篇语是对英国哲学家约翰·洛克《政府论》下篇的模仿洛克认为，人类组成政治社会的目的，是为了保护每一个社会成员的生命权、自由权与财产权。《独立宣言》还认为，政府需要经过被治者的同意。 美国的土地制度和自耕农模式的结合还强化了美国的个人主义文化。 自耕农模式下的美国人更崇尚个人奋斗与自力更生，崇尚依靠自己而不是依靠国家、相信通过自己的努力来改善命运而不是依赖政府供给与社会福利。 在一个尚未充分工业化的农业社会土地分配的不平等就是最大的不平等。 资产阶级最想要的制度安排应该是立宪政治、法治国家、有限政府、分权制衡以及自由市场体制。 一个稳定的和有效率的民主政府，不光是依靠政府结构和政治结构；它依靠人民所具有的对政治过程的取向，即政治文化。——里埃尔·阿尔蒙德 一旦政治竞争是完全意义上的赢家通吃，政治斗争就容易走向不择手段和丧失底线。 多数决定制更容易导致两党制比例代表制更容易导致多党制。——迪韦尔热 对一个国家来说，有什么样的政治精英就有什么样的政治；对一个国家的民主转型来说，有什么样的政治精英就有什么样的民主转型。 政府——无论是民主的还是威权的一—本身无法创造财富，它能做的就是转移财富。 民主选举往往是政治动员的重要驱动力，而在那些族群、宗教多样化程度很高的国家，精英们容易选择将这种族群、宗教分歧政治化，并以此为基础进行政治动员，结果就容易导致政治暴力。——《从投票到暴力》 在人类历史的长河中，文明的此起彼伏乃是一种常态。 当特定族群、宗教和语言的人口到达一定规模后，就容易产生聚居效应。 今天全球威权政体或多或少都面临着一个基本问题，那就是合法性的困境。 从20世纪以来的人类政治史来看，很多愚蠢的乃至灾难性的重大决策都是威权体制下少数领导人刚愎自用、一意孤行的产物。 与民主政体相比，威权政体往往需要维持更为庞大的内务部门（警察与安全部门），需要花费更高的成本来压制潜在的反对力量，这种成本最终都需要整个社会来承担。 威权体制通常还会禁止某些外部思想或信息的输入，甚至需要建立一个更封闭的经济、政治与信息体系这种做法有时看起来不过是维护体制稳定的权宜之计，但其长期后果可能非常严重，有可能阻碍一个国家的经济增长、科学进步、产业升级与整体创新能力。 通往奴役的道路，往往是由善良的愿望铺成的。——哈耶克《通往奴役之路》 政治生活的另一面是，即便人类无法实现完美的政治乌托邦，但现实政治通常都有着巨大的可改善空间，而且我们也不应该放弃这种改善现实政治的希望。 主要内容民主的概念1.0版本：人民的统治 谁是“人民” 公民 政治共同体的大多数人 政治共同体中政治正确的那部分人 怎么统治 直接统治 间接统治 采取某种程序和方式来制定国家制度 问题 无法辨别“民主”的真伪 2.0版本：竞争性的选举制度 要素 政治竞争：政治精英展开政治竞争 政治参与：普通公民具有投票权 问题 无法确保选举的公正性 3.0版本：选举民主+法治 法治的作用 保护了公民的基本权利 确保法治的自由与公正 约束执政者守法、恪守民主规则 解决政治争端 问题 不是存粹讨论民主，而是民主和其他的混合物 民主的起源雅典城邦民主 形成的原因 地理因素古希腊海岸曲折、岛屿众多、陆地多山 阶级斗争假说 军事技术假说 三次改革 卢梭改革 BC594 经济改革 取消平民债务 取消土地抵押 政治改革 将雅典公民划分为四个财产登记 设立四百人制度 司法审判制度（陪审团） 克里斯提尼改革 卢梭改革80年之后 设立以德谟（村）为基础的治理单位 选举产生十将军制度 伯里克利改革 公元前五世纪 设立支薪制度给出席五百人会议、陪审团和行政长官提供日薪 确定“公民权”父母双方皆为雅典公民，子女自动成为雅典公民 如何运作 公民大会（最高权力单位） 五百人议事会 行政官员（抽签+选举 产生） 陪审法庭（至少200人，且为单数） 陶片放逐对可能的“危险分子”实施放逐，放逐时间为10年，但放逐者的财产和地位不受影响。每个公民持有陶片并写上放逐人的姓名，在指定的时间放到投票箱，如果有效票数超过6000，则出现姓名最多的人将被放逐。 古罗马共和制 混合政体&amp;制衡政制 君主因素（执政官） 由两名执政官和多名副执政官构成 由平民大会选举构成 职责是领导国家和指挥战争 贵族因素（元老院） 最初由贵族组成，后期人数慢慢扩大 职责 控制共和国政府的预算和资金 管理日常公共事务 任命行省官员 民主因素（平民大会、保民会） 选举产生执政官 颁布法律 问题与挑战 国家规模和行省统治 无休止的战争导致军事化倾向 财富结构和阶级结构的变化 影响 共和制政体持续了五个世纪 对欧洲和世界产生了近千年的影响 英国议会制度 约束国王权利 1215年《大宪章》 国王的权利应该受到原则性的约束（“国王不应受限于任何人，但应该首先于上帝和法律”）。 纠正国王过去的错误。 1258年《牛津条约》 重新确立的《大宪章》的有效性。 规定了国王违法《大宪章》后，贵族和公民反抗的合法性。 国王处理国家公共事务需要遵从贵族会议。 议会主权形成 1688年“光荣革命”国王成为一个符号，统而不治 责任政府形成 1720年起组建内阁 落实普选权 1832年—1928年 原因 社会因素工业革命、城市化以及大规模工厂组织的出现。普通人的公民意识和政治参与意识开始觉醒。 政治因素 三波民主化浪潮 民主政体的最低标准亨廷顿《第三波》 50%成年男子有普选权 政府首脑依靠民选议会的多数支持或定期普选产生 第一波：始于欧美 主要时间：1828—1926 两个重大事件 美国革命 重要文件 1776年《独立宣言》 1783年《美国宪法》 1965年《投票权利法案》 民主化进程的因素 共和制宪法为国家指明了道路 政治家、立法者和大法官的努力 英国的政治制度对美国的影响 美国的土地制度 影响 美国经济、科学和学术的成为成为全球发展的典范 直接影响了全球民主政体发展（德国、日本等） 美国确立的“民主化外交，推动全球意识形态的重塑 法国革命 重要文件 《人权与公民权宣言》 《拿破仑法典》 历程 1789年“法国大革命”：第一共和国 1799年-1815年：拿破仑第一帝国 持续30多年：波旁王朝和六月王朝 1848年-欧洲革命：第二共和国 1875年-1940：第三共和国 特征 现代世界民主化的第一次尝试 逐步民主化，普选权扩大 民主国家作为工业化和全球化影响了全球民主化 西方重大事件对世界民主化进程产生了影响 民主化主要集中在西方少部分地区 第二波：走出西方 主要时间：1943—1963 两个大事件 第一次世界大战的结束 亚洲和非洲去殖民化浪潮 典型国家 德国 1918年之前：德意志第二帝国有宪法、议会、定期选举和政党政治。但德国首相和议会对皇帝负责而非对议会负责 1918—1933：魏玛共和国 1933—1945：法西斯极权体制 1945后：联邦德国（西德）启动民主化进程 印度 尼日利亚 特征 驱动力：二战的结束、去殖民化运动 民主已经成为全球支配性的意识形态 大规模进入欧洲，亚非也开始兴起 收到了全球化深入发展的影响 第三波：全球时代 主要时间：1974— 西班牙 西班牙竞争性政体的传统 佛朗哥时期的经济发展 处于西南欧（周围有英法德意） 俄罗斯 20世纪80年代—1911苏联解体：戈尔巴乔夫 1911—1999：叶利钦改革 2000—至今：普京时代 韩国 智利 阿拉伯之春（冬） 代表 突尼斯 利比亚 埃及 土耳其 影响中东北非政治改革的因素 威权政体类型（君主制/非君主制） 是否拥有丰裕的石油资源政府有石油资源有利于维护本国政体的稳定 伊斯兰世界极端恐怖注意势力 特征 1.规模最大的民主化运动 2.民主国家的数量超过非民主国家 3.受到冷战结束、欧盟的影响 4.处于完全工业化和充分全球化环境 民主治理绩效民主能否带来经济增长？ 能 1.政府权利受到了限制，立宪和法治的政府能促进经济增长 2.公共政策能得到更好的回应，能体现公共利益 3.公共教育文化和人力资本的提升速度更快 4.民主的国家具有更好的创新能力，因为自由的环境下更利于创新 否 1.民主不一定能形成有效的政府、形成有效的决策和解决问题的能力 2.基于民意和多数决定不一定能形成明明智的决策 3.民主更容易导致较低的投资率 4.民主政体下的政策更导致民粹化 民主能否带来好的公共治理？ “全球治理指数”标准 公共表达和问责制 政治稳定和控制暴力 政府效能 管制质量 法治 控制腐败度 能 1.政府权利受到约束 2.公共政策更有回应性 3.民主的治理是基于公共利益的 否 1.低民主国家处于无法治理的状态 2.政治精英能力和品质不行 3.不能形成良好的公共政策 民主能否促进平等？ 政治平等 形式：每个公民有同等的政治权利 实质：每个公民的政治影响力均等化 经济平等 形式：每个具有同等基本经济权利 实质：每个人的财富均等化 民主和非民主相比，实现了更大程度上的形式或程序平等 民主能否减少政治冲突？ 政治冲突的来源 阶级政治的挑战 身份认同的危机（宗教和种族） 意识形态的分歧 民主程度低 政治暴力概率低 导致冲突的诱因被威权政体控制住了 民主程度提高 政治暴力发生概率提高 政治斗争和政治动员被强化了 民主程度高 政治暴力的概率下降 民主机制和平、有效解决政治分歧 民主的兴衰成因经济社会条件论 经济发展 富裕的国家更容易维持民主，而在贫穷的国家更容易崩溃。 阶级结构 资产阶级有利于民主 对于威权政体和民主政体，资产阶级面对的是“两害相权取其轻”而采取的政治抉择。 民主政体：一人一票的普通民众会对自己的资产造成威胁。 威权政府：威权政府的胡作非为，政府的权利不受限制。可能会面临政府通过各种方式剥夺有产阶级的财产。 无产阶级推动落实普选权推动民主 中产阶级更少的阶级斗争有利于民主 群组宗教结构 族群或宗教的分化结构与民主转型挫败的可能性是一个倒U曲线的关系： 族群较少，由族群分歧或宗教分歧导致的政治冲突可能性较少 族群较多，可能导致的严重政治冲突会增大 族群宗教分化继续增大时，基于族群-宗教的政治认同感降低了。 政治文化 国际因素 国家因素 政治制度论 民主政治制度 总统制 半总统制 议会制 选取的制度 议会的规模： 规模大：好处是代表性很充分，坏处是议事效率和效能受到影响 规模小：好处是议事简便，坏处是代表性不足，容易被少数政治家操控 多数决定制 比例决定制 混合制 政治精英论 政治精英影响国家政治 政治精英影响民主转型 民主的现状及未来民主政体国家的治理挑战 大政府的兴起 原因 工业化、城市化对公共服务的需求 民主化时代选民的需求 现代国家官僚体制的扩张 后果 政府责任和权利范围的扩张 高福利倾向和在分配倾向 社会税负会越来越重 小政府模式的终结和个人精神衰退 市场经济、贫富分化和民主治理 群组宗教的多样化 新兴民主国家的转型难题 民主运行起来 没有重要政治力量反对民主 政治力量的竞争能达到均衡 民主产生绩效 有效的国家治理和治理绩效 民主得到巩固 民主的制度化、管理话和稳固化 政治文化的转型 威权政体的困境、复兴与前景 威权政体的价值取向 发展导向 掠夺导向 多层委托代理关系的困境 大型威权政体面临代理链长而导致的治理难度更大 威权国家的官方腐败问题严重影响着治理的效能问题 政治决定和公共政策的风险 威权政体下，决策失误可能性更高。纠错成本也更高 更高的维护稳定的成本 庞大的内务（国安、警察）系统 需要封闭的经济、政治和信息体系（阻碍经济增长、产业和创新能力） 独权的领导人风险 威权政体下领导人的选择透明度低 没有有效对领导人权利的限制制度 思维导图MindNode笔记： https://my.mindnode.com/NxH7GR6a6krujfBLqu2B5EJ43DQ21DCmx7nVznLx 评价花了几天时间阅读包老师《民主的逻辑》，首先在这本书作为一个可读性很高，阅读起来没有想象中的难。整本书的逻辑框架非常清晰，很有条理性。内容上来说，介绍民主的起源，民主的内涵，分析了高民主国家、民主转型中国家、威权政体国家发展的现状及其优势和问题。书中有非常多的引述，包括常见的政治哲学类、社科类的专著。比较遗憾的是大部分内容只是作者对目前上学术界观点的总结概括，而自己的观点相对比较少。总的来说，通过这本能帮助我们理清民主的各个方面，全面地理性地看待“民主”这一政体。比刘瑜的《民主的细节》更加系统全面，也更加严谨。]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>政治</tag>
        <tag>包刚升</tag>
        <tag>民主</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在NAS上搭建FTP服务]]></title>
    <url>%2Fpost%2FBuild-Ftp-Server-On-NAS.html</url>
    <content type="text"><![CDATA[前言之前在家的时候，多设备之间共享文件是直接访问NAS，很方便。但目前在学校的校园网环境下，虽说可以远程登陆NAS来传输文件，但是两端的设备都需要先登陆NAS，再找到指定路径，再上传/下载。所以一般我要多设备同步文件，一般是通过QQ、微信和Telegram来发送。 今天突然想起来可以使用「FTP服务」来同步文件，首先想到的是在「VPS」上搭「FTP服务」，但是有几个问题：一是连接速度和流量限制的问题，毕竟VPS在海外，而且也会浪费VPS的流量；二是VPS的存储容量有限；还有就是资料安全性的问题，如果要更换VPS了，这些资料还要下载下来。 记起来QNAP是支持搭建FTP服务的，本来NAS上存放的就是一些文件，安全性和速度都比VPS上好一些。 环境准备 网络环境为公网IP（如果没有需要需要「内网穿透」服务） 路由器支持DDNS和端口转发（一般的路由器都支持） 支持搭建FTP服务的NAS 开始搭建QNAP中打开「FTP服务」登陆NAS后，操作流程：点击【控制台】-&gt;【网络&amp;文件服务】-&gt;【FTP】 把「启动FTP服务器功能」勾选上 协议类型：FTP 端口：默认是21 Unicode支持：默认是关闭的，使用的 FTP 软件不支持 Unicode 的话，请将 Unicode 支持设成”否” 允许匿名：如果不允许匿名，则需要NAS用户名和密码来登陆 连接：按字面意思设置即可，一般为默认 高级设置-设置根目录：FTP连接的路径地址 路由器设置 设置DDNS设置路由器的远程管理的时候，我已经设置过DDNS了，如图： 添加端口转发注意：服务器IP是指NAS的内部IP地址，我已经在「DHCP」中将NAS的ip地址固定了 连接FTP服务Windows连接FTP服务 Windows可以直接在「资源管理器-此电脑」右键中「添加一个网络位置」，网络地址填： 1ftp://ip地址或动态域名地址/子路径 再填用户名和密码，通过这种方式可以像使用自己的磁盘一样使用，但是不用直接双击直接打开文件，需要先复制到本地路径，它的速度取决于两端的上传和下载速度。 使用FTP连接软件如Total Command、FlashFXP等等 移动端连接方式和Windos类似，都需要FTP服务器地址、用户名和密码。 Android可以使用「Solid Explorer」。 IOS可以使用「Documents（Readdle公司）」]]></content>
      <categories>
        <category>computer skills</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「风中有朵雨做的云」观后]]></title>
    <url>%2Fpost%2FCloud-in-the-Wind.html</url>
    <content type="text"><![CDATA[情节概述 这是一部在改革开放背景下，由城市建设拆迁而引发的利益、官商勾结的故事。因为「风雨云」并不是宏大叙事，所以上面的只是故事的背景而已，通过这一切口去展示其中“腐烂的现实”。 电影是以一场拆迁地坠楼案展开的，坠楼的是人正是开发区的领导—— 唐奕杰。因为当地抗拆居民和开发商发生了骚乱，唐奕杰为了维稳而赶到拆迁现场，去勘察楼层情况时突然坠楼身亡。唐的死亡原因就成了电影的最大疑点和情节发展的主要驱动力，是失足跌落、自杀还是ta杀，考虑了唐的性格和当前的现场环境，最大的可能是“ta杀”，围绕着这一事件，角色一个个登场了： 杨家栋：当地年轻的警官，负责唐的坠楼案，揭露真相唐死亡的真相，也是为了揭露他父亲车祸的真相。 林慧：唐奕杰的妻子，和姜紫成是朋友兼情人。 小诺：唐奕杰的“女儿”。 姜紫成：地产商人，紫金置业的老板。小诺的亲生父亲。 连阿云：影片刚开始的无名女尸，台湾坐台小姐，姜紫成的情人，后被包装姜的商业伙伴。 因为剧情比较复杂，这里就不再详细梳理了。接下来的故事是以“杨家栋”开始调查唐坠楼案而展开，因为唐坠楼案后的利益关系，姜紫成对杨家栋调查这一案件而不断阻挠，最后找出了片头出现的「无名女尸案」和「唐坠楼案」。 从类型的角度的看，这是一部典型的「悬疑片」，故事情节一开始就设立了 导致唐奕杰坠楼案凶手的身份的「悬念」，叙事剪辑方式很多样，主要是过去（2006）之前，现在（2012）的不同时空间的碎片化的交错闪回，这样的好处是使整个影片的节奏非常快，能方便地铺悬疑点。叙事效率非常高，几乎没有多余的画面和情节。「过去」和「现在」两个时空去采取「时间-地点」的字幕信息去交代，这样使时故事的清晰度不高，对观众的要求也比较高。 摄影和剪辑「风雨云」摄影和剪辑也让我很享受。娄烨导演一贯的手持摄影的方式，一方面在生理上让人感觉不舒服，另一方却大大增强的真实感。尤其是一开始的城关村的骚乱场面太精彩了，由一系列俯拍、跟随、交叉、穿越的镜头组成，这个看起来像是长镜头的拼切镜头带领我们去感觉广州城中村拆迁的环境现状，各处的残楼瓦砾，瓦砾上居民晾晒的衣服，骚乱中拥挤的人群，挖掘机推到墙壁和电线杆的轰隆声，给人一种强烈的压抑感，而这一种压抑感、压迫感和整个影片所要展现的基调是一致的。 让我印象非常深刻的还有几个场景，杨家栋在城中村被陷害杀人的逃跑镜头，这组镜头充分展现了城中村特有的潮湿、逼仄的环境，之前我也在广州城中村住过一段时间，这组镜头完全勾起了我在楼房与楼房之间行走那种压抑的感觉。另外两场车内争斗戏也非常出彩，就不再具体叙述了。 最后在「风雨云」中，娄烨试图将商业片和艺术片进行融合，从这点上说，他做的很不错。片中塑造的悬疑元素、出彩的动作设计能牢牢吸引观众。整个影片的布景、光影、声音的处理都体现出娄烨的专业性的艺术追求，电影外的事情无须多言。 电影会帮我们记住，我们和我们的时代。]]></content>
      <categories>
        <category>Movie</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「如何聊电影」读书笔记]]></title>
    <url>%2Fpost%2FHow-to-watch-movies.html</url>
    <content type="text"><![CDATA[Title 如何聊电影 Author [美]安·霍纳迪 Edition 未读-艺术家 Release Date 2018-10 ISBN 9787559626295 剧本 三幕式电影结构：第一幕（铺垫）、第二幕（冲突）、第三幕（解决） 通常来说，一个好的剧本应该对环境和角色有精准细致的描绘。 剧本决定了我们在这两小时内进入的是一个怎样的世界，而编剧的水平和他的文字功底决定了这个世界是否真实、有活力，能否让我们迅速入戏。 剧情只是说事（机械复述），故事是在讲意（表达情感）。 这种给角色脸上贴金的做法有一个专门的术语叫“（加）风险”（stakes），也就是编剧将故事写得更紧张激烈，并通过赋予角色行为更戏剧化、更能获得观众同情的动机，让角色更具“共鸣感”。 可信度人类的缺点的存在或缺失瑕疵以及合反映出编剧理和不合理的人性的理解程行为的了解。 表演 表演还是取决于演员在塑造一个角色时所做的一系列决定—把握角色内在和外在的各种细节，打造出有深度、有真实感、有吸引力的角色。 最好的银幕表演应该能在“表现”与“克制”之间达到超常的平衡，也就是说，既要透明到能让观众瞬间了解角色，又要内敛到让观众好奇角色下一步会怎么做。 最忌讳被观众发现表演痕迹的类型片，可能是喜剧片。 伟大的演员能不断勾起我们的好奇心，让我们在对他们的一知半解中获得满足。 选角的艺术离不开经验、品味、直觉、风险、讨价还价，还有纯粹的运气。 相比选择家喻户晓的大明星，选用生面孔可以更有效地奠定一部影片的基调。 在电影诞生伊始，也就是在默片时代，夸张的戏剧动作不仅为观众所熟悉（当时的舞台剧和歌舞秀都是这种表演风格），更是在没有台词的情况下传达影片讯息的必要手段。进入三四十年代的“黄金时代”，即便有声电影已经普及，风格化、戏剧化的表演依然占主导地位，但浮夸、直白的动作正在逐渐消失。 衡量一个演员表演的好坏，应该看观众是否获得情感共鸣:演员的表演是帮助了我们进入银幕中的世界，还是让我们觉得出戏？ 拿一部电影的原真性（perceived authenticity）作为卖点已经成了一种廉价的营销手段。 作为观众，我们不需要知道演员为了准备一个角色进行了怎样的自我思考、即兴创作，或者热身运动，我们也不需要知道演员为了在银幕上打造一个他栖身的世界做了多少研究，我们只需要跟随他们一起进入这个世界即可。 戏中演员最重要的就是把正确的外部表演和正确的内心表演结合。 在评价一个你不喜欢的演员的表演时，观众必须把这个演员可控的地方和不可控的地方区分开来。演员没法让自己的个子忽高忽矮，也不可能随意增重或减重，但他们可以据故事需要，让自己的角色形象或优雅尊贵，或粗野，或谦逊。 艺术设计 在评价一部电影的艺术设计时，可信度、吸引力、细节度、原创性都应该列入考虑范围。 和剪辑一样丫奥斯卡最佳艺术指导奖通常都是颁给在艺术指导方面做得最张扬、最气派的电影）比如服装华丽的历史剧情片，或者在视觉上极富创新的电影。 最好的艺术设计是难以察觉、不着痕迹的。 最好的艺术设计是通过无形与有形、逼真和矫饰之间的内在张力实现的，优秀的艺术指导能为观众打造出愉悦的、富有质感的视觉体验，并提供细节丰富的布景，让表演者尽可能真实、自然地表演。 母题：指电影中有意义且重复出现的元素。母题可以是物品、颜色、地点、人物、声音等。 但电影的艺术设计一直在帮助我们感知和理解电影，并在视觉、精神乃至潜意识上影响我们。 艺术设计不仅能让观众了解角色，还能够传递主角不能传递的价值观、需求和欲望。 电影一定要尽量多给观众一点儿信息，用画面和信息淹没他们。如此一来，一部电影便可以重复欣赏，影迷每次重看都会有新的发现。 摄影 德国表现主义（Expressionism）：用极简、强烈的光影对比。 摄影机是我们进入银幕世界的通道，问题是电影制作者究竟是在用摄影机把我们拉进去，或是让我们与之保持距离，还是将我们拒之门外。 剪辑 最好的剪辑并不会引起观众的注意，而是消失在电影中。成功的剪辑能让观众获得满意的观影体验，感觉整部电影浑然天成，从头至尾没有一点儿磕绊，没有别扭的转场，没有不合逻辑的剧情，也不会让人感到厌烦或者疑惑。 我们说一部电影太长，指的是它重复、无聊，或是纯粹为了堆砌银幕奇观而加入一场又一场爆炸戏和破坏戏。 一百多年来，电影的基本语法并没有太多改变。电影依然是由场景构成，而场景由镜头构成，镜头则是叙事的基本元素。 声音和音乐 好电影不只是精彩的故事、高超的表演、迷人的画面结合的产物，它还能提供富有深度的体验，将对话、音效、音乐融合在一起，打造一个音响环境，让观众听到的声音和看到的画面一样充满了层次感和细节度。 声音对我们在电影中能看到什么有强烈的影响，这种影响通常都是潜移默化的。 奥斯卡中共设了两个声音奖项： 最佳声音剪辑奖：声音剪辑师（sound editor）负责汇集、制作、整理观众在银幕上听到的一切声音，其中包括角色对白（包括拍摄现场录制的对白和后期配音）和音效； 最佳混音奖：混音师（ sound mixer）负责决定这些声音如何相互共存，以及如何与配乐共存。混音师可以通过调整不同声音的比例，来增强真实感和情感冲击力，提升观众对影片故事的理解。 声音在打造连贯性上的另一个作用，是让场景之间的转换更加自然流畅。在声音设计的帮助下，观众可以自行在脑中将看似没有关系或者衔接比较生硬的两个场景连到一起。 一部电影的声音有多写实，完全取决于这部电影想要讲述一个怎样的故事，以及导演是想将观众的注意力引到角色身上，还是引到他们抽象的情感体验上。 音乐不应该只是重复或强调已经通过视觉画面或者角色对白传达出来的故事元素和情感。它应该有所添加，不是模仿或者强调已经发生的动作，而是在不知不觉中，赋予它更多的意义，让故事更有深度。 从本质上讲给一部电影过度配乐其实是对观众的不信任，同时也反映了电影制作者自己的不自信一只会反复告诉观众如何去感受，而不是让故事和演员去完成情感传递的任务。这种配音被叫成「米老鼠配乐」（mickey-mousing)导演 导演需要从头到尾对整个作品内容进行负责，不管是影像风格、剪辑、音乐的选择、甚至是演员的表现上。 ​]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D音频管理器「生存之战」]]></title>
    <url>%2Fpost%2FUnity3D-AudioManager.html</url>
    <content type="text"><![CDATA[Unity3D的音频系统介绍 前言想象一下如果电影没有了声音，我们的观影体验会大打折扣，声音也对于游戏有非常重要。游戏中的声音主要是指游戏交互过程中的各种音效，如走路会产生脚步声，射击时会有枪声，这些音效就是为了产生更沉浸的世界（环境），游戏中另一个声音是背景音乐，起到烘托游戏气氛的作用。 Unity3D中的声音音频管理器 Edit–&gt;ProjectSetting–&gt; Audio AudioClip（音频文件）Unity3D中支持各种格式的音频文件，可以导入的音频格式有.wav .mp3 .ogg，可以直接将音频文件拖拽到Unity3D的「Assets」中里。在Unity3D里面，这些音频文件叫做Audio Clip。 AudioListener （音频监听器组件）一个Scence中有一个AudioListener，它可以接受游戏中的所有音乐和音效，相当于人的“耳朵”，创建场景中它会自动挂载在Main Camera物体上。 AudioSource（声音源组件）在Unity3D中是通过Audio Source这个声音组件来播放声音的，在任何一个物体（gameobject）上都可以直接挂在这个Audio Source组件。 AudioClip：拖入音频AudioClip文件 Output：音频剪辑通过音频混合器输出; Mute：是否静音； Play On Awake：是否自动播放（如果这个组件时通过代码添加上的，而不是一开始就有的，不会自动播放，需要使用AudioSource.Play()来播放） Loop：是否循环播放 Priority：当场景中有多个音频共存时，设定的优先级播放 Volume：音量大小 代码控制使用代码设置音频和对音频的控制需要先获取AudioSource组件。 1234567891011// 获取AudioSouce组件AudioSource audioSource = transform.GetComponent&lt;AudioSource&gt;();// 控制音频audioSource.clip = clip; // 设置clipaudioSource.volume = 0.5f; // 设置音量大小audioSource.loop = true; // 设置循环播放 audioSource.Play(); // 开始播放audioSource.Stop(); // 停止播放audioSource.Pause(); // 暂停播放audioSource.UnPause(); // 继续播放 独立的音频管理器（生存之战音频管理器为例）需求分析需要控制的音频比较少时可以直接在物体自身的脚本中获取AudioSource组件进行控制，但如果需要控制的音频比较多时，或想后期修改音频逻辑时，需要重新打开对应的脚本比较复杂。将和音频控制相关的代码封装了独立的脚本会方便很多。需求点： 管理器必须是单例模式，方便在项目中随处使用该类的功能； 直接持有和管理几十个甚至几百个音频资源； 可以实现传递音频资源名，然后在某个位置播放音频； 可以实现动态的给某个游戏物体添加音频组件，配置音频组件相关属性； 还要提高音频管理器的“易用性”，规范音频资源命名，方便快速找到需要的资源。 导入音频将所有音频资源导入「Resources」文件夹中 脚本编写创建音频资源枚举使用资源名称枚举可以方便我们使用对应的音频时快速找到需要的音频资源，枚举值和音频资源名要一一对应 1234567891011public enum ClipName&#123; /// &lt;summary&gt; /// 野猪攻击音效. /// &lt;/summary&gt; BoarAttack, /// &lt;summary&gt; /// 野猪死亡音效. /// &lt;/summary&gt; BoarDeath&#125; 创建AudiosManager.cs，加载音频资源123456789101112131415public static AudiosManager Instance; // 单例private AudioClip[] audioClip;private Dictionary&lt;string, AudioClip&gt; audioClipDic;void Awake()&#123; Instance = this; audioClipDic = new Dictionary&lt;string, AudioClip&gt;(); audioClip = Resources.LoadAll&lt;AudioClip&gt;("Audios/All/"); // 把所有音频添加到字典中去 for (int i = 0; i &lt; audioClip.Length; i++)&#123; audioClipDic.Add(audioClip[i].name, audioClip[i]); &#125;&#125; 将该类定义为单例模式 使用Resources.LoadAll&lt;&gt;()加载所有AudioClip，得到一个AudioClip数组 将资源数组遍历存储到一个字典结构中 音频播放方法1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 通过名字获取音频资源/// &lt;/summary&gt;public AudioClip GetAudioClipByName(ClipName clipName)&#123; AudioClip tempClip; audioClipDic.TryGetValue(clipName.ToString(), out tempClip); return tempClip;&#125;/// &lt;summary&gt;/// 在指定位置播放音频/// &lt;/summary&gt;public void PlayAudioClipByName(ClipName clipName, Vector3 pos)&#123; AudioSource.PlayClipAtPoint(GetAudioClipByName(clipName), pos);&#125;/// &lt;summary&gt;/// 给游戏物体添加音频组件来播放音频/// &lt;/summary&gt;public AudioSource AddAudioSourceComponent(ClipName clipName, GameObject go, bool playOnAwake = true, bool loop = true)&#123; AudioSource audioSource = go.AddComponent&lt;AudioSource&gt;(); audioSource.clip = GetAudioClipByName(clipName); if (playOnAwake) audioSource.Play(); audioSource.loop = loop; return audioSource;&#125; 在其他脚本中使用AudioManger.cs需要先查找持有这个脚本的引用，调用该管理器内的方法 12AudiosManager.Instance. PlayAudioClipByName(ClipName.BoarInjured, transform.position); 参考资料： 关于Unity中3D声音的使用]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[降噪耳机Bose-QC-30使用体验]]></title>
    <url>%2Fpost%2FBose-QC-30.html</url>
    <content type="text"><![CDATA[这是我买的第一款“主动降噪”耳机，本文谈谈对 QC-30 这款产品的使用体验。 写在前面在买一款耳机之前，买过至少10条以上还不错的耳机。目前还在使用的有，1条小米平头耳机、2条“入耳式耳机”（分别是AKG和小米活塞耳机）、一个不知名的运动耳机、一个头戴式耳机（Sony 1AbT）。我并不是一个耳机发烧友，有HIFI音质没有很大的追求，但喜欢在不同的使用场景下使用合适的耳机。 18年底到19年初这段期间听了比较多的播客，就一直想买一款「分体式耳机」，也就是商家标称的「真·无线耳机」，以AirPorts为参考，考虑过小米AirDots、小米蓝牙耳机Air，另外还有 QCY T1，漫步者 W2等小众品牌，但考虑到颜值问题，还是优先考虑小米的两款。（值得一提的时候，小米AirDots就是Qcy T1的贴牌产品，只是换了外观设计）。但小米的这两款蓝牙耳机一直买不到，无论是线上还是在小米之家，后来想着就入手一款降噪耳机。 目前，主流的降噪耳机分3种，一种是「分体式耳机」，一种是「项圈式耳机」，一种是头戴式耳机（Sony WH-1000XM3、Bose Qc35）。考虑到自己已经有一款头戴式耳机，就只有「项圈式降噪耳机」了，千元以后的有「Sony Wi-1000x」、「Bose QC-30」，百元以内的有「DyPlay ANC30（￥279）」。前几天的晚上，逛闲鱼的时候发现有人在卖全新未拆封的 QC-30 ，直接砍了50元后，以1200元的价格买了。 外观与佩戴 Bose QC-30 的简单一点描述就是一个「项圈」，采用半圈形的结构，让耳机直接挂在脖子上，能在一定程度上提升耳机的佩戴舒适度。项圈部分采用”类肤质“的材料、耳塞外部是金属材料、按键控制是硬塑料，鲨鱼鳍耳塞是软硅胶材质的。整体来看，产品在设计风格、材料选择方面都比较协调，统一。再说一说细节部分，仔细看耳机，我都不敢相信这做工是2000价位的耳机，与Sony的做工（细节把控）有点差距，如项圈有些部分的胶并没有粘好，使用一段时间或出汗可能会导致脱胶、鼓包等问题。 因为耳式项圈部分采用了类肤质的材料，所以直接把耳机与皮肤接触并没有什么不适，长时间佩戴甚至会忽视它的存在。当穿上有领的衣服时，项圈还可以直接放在领子的外面。佩戴上另一个非常难受的问题，项圈戴久之后，项圈的位置会变歪，对强迫症来说非常难受呀！不得不过几十分钟就要把它手动放正。 另外一个关键的问题时耳塞的的舒适度。得益于Bose 独家的鲨鱼鳍耳塞，半入耳式的设计能让做到长时间佩戴都很舒适，而且怎么甩耳机都不会从耳朵里溜出来。解决了平头耳机容易掉，耳塞式耳机的堵耳，头戴式耳机夹眼镜夹耳等问题。 连接耳机QC-30支持蓝牙4.2连接，不支持LDAC以及aptX。蓝牙连接设备没什么好说的，QC-30还支持NFC连接的，但经过我多次测验，无论是通过手机NFC还是 Sony-A30 的 NFC 都无法正常连接，只能通过手动点击蓝牙连接。当然，耳机开机时如果手机的蓝牙时打开的，耳机会自动连接手机，连接的速度还是挺快的。 连接好APP后，可以拖动中间的滑动条调节降噪的等级，支持11级调节。左下角的连接蓝牙标志可以进行蓝牙连接，往右边的是Bose 音乐分享功能，介绍说时能在两台Bose设备之间无线传输音频，可惜我只有一台 Bose设备，最右边的时蓝牙当前的剩余电量。最下面的播放播放控制，这个控制可以接管连接上设备的音频控制权。比如 网易云音乐 或是 Spotify 播放音乐，或是连接上的其他播放器（Sony-A30）也可以控制。 Bose-QC-30 可以同时连接两台设备，但是使用体验并不是很好。 同时连接 Sony-A30 和手机，并使用 Sony-A30 播放音乐时，如果手机上要播放音频，需要先暂停 Sony-A30上的播放，否则手机播放没有声音。 同时连接 PC 和手机，使用 PC 播放音乐，如果手机接到任何通知或要播放声音，会中断当前音乐的播放，过一会又继续播放。 注意：在使用 Win10 连接耳机时，需要先连接手机，打开 Bose Connect ，点击蓝牙-连接新设备，再使用 Win10 搜索蓝牙设备连接 Bose QuietControl 30。 降噪表现降噪是这款耳机最主要的功能，降噪分为两种。一种是被动降噪，一种是主动降噪。对于第一种，更恰当地说是隔音，戴海绵耳塞、头戴耳机式。 被动式降噪耳机利用物理特性将外部噪声与耳朵隔绝开，主要通过隔声材料阻挡噪声，对高频率声音非常有效，一般可使噪声降低大约为15-20dB。 而主动降噪不只是简单地物理材料隔音 主动降噪的原理在于首先要收集噪音的波型特点，然后通过内置的处理芯片运算出反相的波，再通过高还原度扬声器相抵消。所以主动降噪系统必备的设备有拾音器、处理芯片、扬声器，每一个部分都要保证高质量才能达到最终的效果，故成本上就要比传统非降噪设备高。 Bose QC-30 一个特色式支持11档地「可控降噪」，可以满足在不同场景地使用需求。在嘈杂的食堂、公交、地铁上可以将降噪全开。而在需要与人交谈的时候，可以把通过线控的方式将降噪级别降低，当前我还是建议把耳机取下来再与人交谈，一是方便，二是对别人的尊重。 将降噪开到最高时，即使播放音乐，也会感觉少了很多嘈杂的声音，这些声音在没有戴降噪耳机之前不会有明显的感觉，当我把降噪耳机取下来之后，各种中频、低频的噪音「扑耳而来」，用了降噪耳机之后怕是再也回不去不用降噪耳机的时候了。 对人声的降噪情况，如果有人在你身边讲话时，还是可以清楚听清说话的声音，但是人声会有明显的变化。 Bose QC 30 并没有明显的底噪（电流声），如果旁边有手机或其他设备在充电可以听到明显的电流声。如果衣服摩擦耳机的线，会有一点点的听诊器效应。 如果使用场景有风，QC-30会有很大的风噪音，可能是拾音器又加大风声。 总的来说，QC30的降噪表现还是延续了Bose家族一如既往的高水准，比市面上很多同类型的降噪耳机效果要更优秀一些。对近距离的高频噪音和人声不能屏蔽掉，但开启降噪再用小音量放一些音乐就可以做好普通耳机需要很大音量才能隔绝噪音的效果。 音乐表现到了玄学的音效的环境，对于音质不是特别敏感的耳朵来说，Bose QC30 的音效还是能过的去的。网上的评测大都说不如 Sony WI-1000x 听感好，我没有自己听过 Sony Wi-1000x ，所以不好下判断。更何况音质这东西见仁见智，耳朵适应一段时间一般都会适应。 （各频段音乐表现待一段时间的使用之后再补充） 续航官方参数：充满电可以使用10个小时，充满电需要2个小时（实际体验2h20min） 参考： Bose-QC-30_官方介绍 平价真无线耳机们到底好用不好用【值不值得买第307期】 破解”听不见”的秘密 降噪耳机技术浅谈 BOSE QC30无线消噪耳机体验]]></content>
      <categories>
        <category>新玩具</category>
      </categories>
      <tags>
        <tag>耳机</tag>
        <tag>体验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「故事」读书笔记]]></title>
    <url>%2Fpost%2FStory-Notes.html</url>
    <content type="text"><![CDATA[罗伯特·麦基的《故事》中摘录的笔记 Part 1 故事 故事是人生必需的设备。 娱乐即使沉浸于故事的仪式之中，达到一种知识上和情感上令人满足的目的。 凡是优秀的电影、小说、戏剧，都能通过其各不相同的喜剧和悲剧色彩来达到娱乐的目的，给观众一种具有感染力的生活模式。（电子游戏亦是如此） 故事并不是对现实的逃避，而是一种载体，承载着我们去追寻显示、尽最大的努力挖掘出混乱人生的真谛。 故事艺术是世界上主导的文化力量，而电影艺术则是这一辉煌事业的主导媒体。 创作者的技巧并不是什么手艺的东西，只不过是他对所遇到的每一部小说、电影或戏剧中故事要素的无意识吸收。 创造故事必须深入地挖掘生活，找到新地见解、新版本的价值和意义，然后创造出一个故事载体。 一个好故事使一部好影片成为可能，如果故事不能成立，那么影片必将成为灾难。 所有的故事，无论真诚还是虚假，明智还是愚蠢，都会忠实地映现出作者本人，暴露出其人性…..或人性地缺乏。 每一门艺术都是由其根本形式决定地。故事地普遍形式使其作品成为一个故事，而不是肖像画或艺术拼贴。 一个作家必须掌握故事形式，但形式并不是“公式”，故事是丰富多彩、纷繁复杂、神妙莫测的。 故事是生活的比喻 一个讲故事的人即是一个生活诗人，一个艺术家，将日常生活事件、内在生活和外在生活、梦想和现实转化为一首诗，一首以事件而不是以语言作为韵律的诗一个长达两小时的比喻，告诉观众:生活就像是这样！因此，故事必须抽象于生活，提取其精华，但又不能成为生活的抽象化，以致失却实际生活的原味。故事必须像生活，但又不能一成不变地照搬生活，以致除了市井乡民都能一目了然的生活之外便别无深度和意味。 电影美学是表达故事生动内容的手段，其本身绝不能成为目的。 Part 2 ：故事的要素 ​ 节拍构成场景，场景构成序列，序列构成幕，幕构建成故事，最后达到高潮。 节拍是场景里面最小的结构成分。 场景是再某一相对连续的时空中，通过冲突表现出来的一段动作，这个动作至少是让人生的生活负荷发生转折。理想的场景是一个故事事件。 序列是一系列场景——一般是两到五个，每一个场景的冲击力呈递增趋于，直到最后到达顶峰。 幕是一系列序列的组合，以一个高潮场景为顶点，导致价值的重大转折。 高潮：故事是一系列幕的组合，渐次构成一个最后的幕高潮。引发出绝对不可逆转的变化。 总结：场景导致较小而有意义的变化，序列中的终结场景的变化更强劲、具有决定性的变化，而幕导致的价值转折比场景和序列中的冲击力更强。场景、序列、幕中的变化都是可以逆转的，但是最后一幕的高潮是不可逆转的。 故事三角故事经典设计： 经典设计是指围绕一个主动主人公构建的故事，主人公为了追求自己的欲望，与主要来自外界的对抗力量进行抗争，通过连续的时间、在一个连贯而具有因果关联的虚构现实里，到达一个表现绝对、而变化不可逆转的闭合式结局。 我们的故事大部分都是这样的经典设计的。被麦基成为大情节故事，但是这种形式并不是故事讲述形态的极限。与之不同的，有小情节和反情节，如图： 最小主义是指作者从经典设计的成分开始，对它们进行削减—对大情节的突出特性进行精炼、浓缩、删节或修剪。小情节并不意味着无情节，其故事必须像大情节一样给予精美的处理。确切地说，最小主义的情节处理是要在简约、精炼的前提下保持经典的精华，使影片仍然能够满足观众。 反情节是反小说（新小说）和荒诞派戏剧的电影翻版。反结构变体并没有削减经典，而是反其道而行，否认传统形式，以利用甚至嘲弄形式原理的要义。反情节的制造者对欲语还休的描写方法或暗度陈仓式的收敛几乎没有兴趣；相反，为了昭示他的“革命”雄心，他的影片倾向于过度铺陈和自我意识的大肆渲染。 闭合式结局 VS 开放式结局 如果一个表达绝对而不可逆转变化的故事高潮，回答了故事讲述过程中所提出的所有问题并满足了所有观众情感，则被称为闭合式结局。 一个故事高潮如果留下一两个未解答的问题和一些没被满足的情感，则被称为开放式结局。 外在冲突 VS 内在冲突 大情节强调外在冲突。尽管人物常常具有强烈的内心冲突，但重点却落在他们与人际关系、社会机构或自然界力量的斗争上。 在小情节中，主人公也许与家庭、社会和环境具有强烈的外在冲突，但其重点却集结在他与自己思想情感有意或无意的角斗里。(内在冲突即内心冲突) 单一主人公 VS 多重主人公 如果是单一主人公，则影片中所有的事件变化都围绕主角。 如果作者将影片分解成若干较小的次情节，每一个次情节都有一个单一主人公。 主动主人公 VS 被动主人公 主动主人公在欲望追求中采取行动时，与他周围的人和世界发生直接冲突。 被动主人公表面消极被动，而在内心追求欲望时，与其自身性格的方方面面发生冲突。 线性时间 VS 非线性时间 无论有无闪回，一个故事的事件如果被安排成一个观众能够跟踪的时间顺序，那么这个故事便是按照线性时间来讲述的。 如果一个故事在时间中随意跳跃，从而模糊了时间的连续性，以致观众无从判断什么发生在前什么发生在后，那么这个故事便是按照非线性时间来讲述的。 因果 VS 巧合大情节因果性强，反情节常常以巧合代替因果，强调宇宙万物的随意碰撞。 连贯现实 VS 非连管现实 连贯现实是确立人物及其世界之间互动模式的虚拟背景，在整个讲述过程中，这些互动模式一直保持着连贯性，从而创造出意义。 非连贯现实是混合了多种互动模式的背景，其中故事章节不连贯地从一个“现实”跳向另一个“现实”，以营造出一种荒诞感。 未完….]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Scrapy爬虫抓取并下载豆瓣图片]]></title>
    <url>%2Fpost%2Fcrawl-douban-image-by-scrapy.html</url>
    <content type="text"><![CDATA[上一篇笔记我直接自己写了一个Python来抓取豆瓣图片，为了让我更加熟悉Scrapy，我又用Scrapy做了一遍。 网站分析直接参考上一篇的目标和网站分析。 工具分析 需要添加一个自己的下载图片的Item Pipeline。 爬虫程序创建一个新的Scrapy项目12scrapy startproject db_img_crawlerscrapy genspider dbimg htpp://douban.com 编写items.py123class ImagesItem(scrapy.Item): image_title = scrapy.Field() # 图片的标题 image_url = scrapy.Field() # 图片的地址 编写主Spider文件，dbimg_crawler.py12345678910111213141516171819202122232425262728import scrapyimport jsonfrom doubanimg.items import ImagesItemfrom scrapy import Requestfrom requests import requestclass DbimgSpider(scrapy.Spider): name = 'dbimg' def start_requests(self): headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36',&#125; for i in range(0,300,20): url = 'https://www.douban.com/j/search_photo?q=%E7%8E%8B%E7%A5%96%E8%B4%A4&amp;limit=20&amp;start=' + str(i) yield Request(url,callback=self.parse_one) def parse_one(self, response): item = ImagesItem() images = json.loads(response.body.decode('utf-8')) images = images['images'] for i in range(0,len(images)): item['image_title'] = images[i]['title'] image_id = images[i]['id'] item['image_url'] = 'https://img3.doubanio.com/view/photo/l/public/p'+str(image_id)+'.webp' # print(item) yield item 直接在start_requeset()中开启循环抓取，方法yield Request，回调给parse_one()抓取每一次的20条数据。 图片的地址同时是由获取到的id值来组拼成的。 编辑piepelines.py123456789101112131415161718192021import scrapyfrom scrapy.pipelines.images import ImagesPipelinefrom scrapy.exceptions import DropItemclass MyImagePipeline(ImagesPipeline): def get_media_requests(self, item, info): yield scrapy.Request(item['image_url'], meta=&#123;'item':item&#125;) def file_path(self, request, response=None, info=None): # item = response.meta['item'] name = 'full/%s' % ((request.url.split('/')[-1]).split('.',1)[0]) + '.jpg' return name def item_completed(self, results, item, info): path = [x['path'] for ok,x in results if ok] if not path: raise DropItem('Item contains no images') print('Saving img...',item['image_url']) print('title',item['image_title']) return item 创建自己的Item Pipeline，继承ImagesPipeline(图片管道)，这个管道的特性有： 将所有下载的图片转换成通用的格式（JPG）和模式（RGB） 避免重新下载最近已经下载过的图片 缩略图生成 检测图像的宽/高，确保它们满足最小限制 要下载图片，需要重写get_media_requests()方法，方法内对图片URL返回一个Request。（默认返回None，表示没有图可下载）要想传递item对象可以把它写在request的meta里面。当下载完成之后，由管道接起，传递到item_completed()方法内。 如果想设置文件的名字，可以重写file_path()，可以通过item = response.meta[&#39;item&#39;]来接受item对象。 编辑Setting.py1234567891011121314151617181920212223242526272829设置HeaderDEFAULT_REQUEST_HEADERS = &#123; 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding':'gzip, deflate, sdch', 'Accept-Language':'zh-CN,zh;q=0.8', 'Cache-Control':'max-age=0', 'Connection':'keep-alive', 'User-Agent':'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36'&#125;# 图片存储路径IMAGES_STORE = 'D:\\img'# 爬虫协议ROBOTSTXT_OBEY = False# 最大Requests数CONCURRENT_REQUESTS = 16# 下载延时DOWNLOAD_DELAY = 1# 关闭CookiesCOOKIES_ENABLED = False# 开始MyImagePipelineITEM_PIPELINES = &#123; 'doubanimg.pipelines.MyImagePipeline': 1,&#125; 启动爬虫程序1scrapy crawl dbimg 参考链接： 下载项目图片-scrapy中文文档]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓取豆瓣搜索到的图片]]></title>
    <url>%2Fpost%2Fcrawl-douban-image-and-download.html</url>
    <content type="text"><![CDATA[使用Python抓取和周迅有关的图片并下载到本地。 目标豆瓣搜索“周迅”的相关图片，并且下载到本地 网站分析豆瓣图片是通过Ajax动态加载的，按F12打开Chrome浏览器的开发者工具，图片是通过GET来请求的，请求地址： 1https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;limit=20&amp;start=0 其中：【q=：关键字| limit=：一次请求的数量（修改了也没用） | start=：请求的开始位置（偏移量）】。点开Preview，看到网站给我们发送了一个20个长度的json数据包 点开第一个，这里面有几个key，我们需要的是图片的url，另外还可以存储图片的title。这里面可以看到有两个url，分别是scr和url。 把它们全部在地址栏打开，发现这个scr链接是图片的缩略图地址，这个url链接是图片post的主页地址。这两个都不是我们想要的，但是可以右键看一下图片的真实地址 复制出来图片的地址，观察到图片的命名就是上面接受的id值，这样我们就可以通过获取每张图片的id值来组拼出图片的下载地址了。 1https://img3.doubanio.com/view/photo/l/public/p637462204.webp 完整的爬取定义Header，图片的存储地址，保存抓取到的图片item 12345678910dir = './image' # 图片地址imageItemList = [] # 用列表存储所有的图片item（字典）headers = &#123; 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding':'gzip, deflate, sdch', 'Accept-Language':'zh-CN,zh;q=0.8', 'Cache-Control':'max-age=0', 'Connection':'keep-alive', 'User-Agent':'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36' &#125; 获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中1234567891011121314151617import requestsimport jsondef get_img_url(): ''' 获取图片的url下载地址 ''' for i in range(0,300,20): url = 'https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;limit=20&amp;start=0' response = requests.request('Get', url,headers=headers) images = json.loads(response.content.decode('utf-8'))['images'] for j in range(0, len(images)): imageItem = &#123;&#125; imageItem['title'] = images[j]['title'] id = images[j]['id'] imageItem['url'] = 'https://img3.doubanio.com/view/photo/l/public/p'+str(id)+'.webp' imageItemList.append(imageItem) 通过For循环获取，range(0,300,20)，表示要获取的图片数量为300张，Sep（步长）为20，因为每次获取的是20条数据。 通过response.content，获取response返回的内容，之前用response.body提示错误。这个应该是scrapy自己封装的属性。 通过json.loads()把json对象转换成Python对象，这样方便Python去解析。 图片的url是通过id值来组拼的。 从列表获取图片链接并下载图片，然后使用dwebp工具转换图片格式 1234567891011121314151617181920212223242526272829def request_download(url, path): ''' 下载文件的方法 ''' r = requests.get(url) with open(path, 'wb') as f: f.write(r.content)def download_img_from(): ''' 从数组中取出所有图片链接并下载，下载后使用dwebp转换图片格式为png，并删除dwebp源图片 ''' index = 1 # 判断是否电脑中是否有此目录，如果没有则创建一个空目录 if not os.path.exists(dir): os.mkdir(dir) for item in imageItemList: url = item['url'] fullpath = dir +'/'+ str(index) + '.webp' # 调用下载方法 request_download(url, fullpath) try: print('开始转换第'+str(index)+'张图片：') os.system('dwebp ./image/%d.webp -o ./image/%d.png' %(index,index)) print('转换第'+str(index)+'张图片完成.') os.remove('./image/'+str(index)+'.webp') #删除webp格式的图片 except Exception as err: print(err) index += 1 从上面的图片item中获取每张图片的url，调用下载方法。 注意：这里获取下载的图片是webp编码的，需要使用dwebp工具进行转换。 WebP（Google开发），是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，派生自影像编码格式VP8。在同样大小的图片文件中，能比其他格式更加清晰，能提高网页加载速度，减少网络存储。 安装webp工具直接在scoop中搜索安装（libwqbp）即可，还可以直接去google的webp地址去下载安装，安装完成之后，把安装路径里面bin文件夹路径添加到环境变量中去。 使用webp1dwebp *.webp -o *.png # 第一个是webp文件名，第二个是转换后的png文件名。 启动爬虫程序 先调用爬取路径的方法，再调用下载文件的方法。 123if __name__ == "__main__": get_img_url() download_img_from() 启动爬虫]]></content>
      <categories>
        <category>clawl</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Item Pipeline把Scrapy爬取的数据存储到MongoDB]]></title>
    <url>%2Fpost%2FScrapy-To-MongoDB-By-Pipeline.html</url>
    <content type="text"><![CDATA[使用Item Pipeline(项目管道)来保存使用Scrapy爬取的item对象 Pipeline是什么 当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。 每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。 ——Scrapy Doc item pipeline的功能： 清理HTML数据 验证爬取的数据(检查item包含某些字段) 查重(并丢弃) 将爬取结果保存到数据库中 在pipeline.py中编写MongoDBPipeline123456789101112131415161718192021222324252627from scrapy import Itemimport pymongoclass MonoDBPipeline(object): ''' 将item写入到MongoDB中 ''' @classmethod def from_crawler(cls, crawler): # 访问配置文件取mongodb的url和name，如果没有则使用默认值 cls.DB_URL = crawler.settings.get('MONGO_DB_URI', 'mongodb://localhost:27017') cls.DB_NAME = crawler.settings.get('MONGO_DB_NAME', 'scrapy_data') return cls() def open_spider(self, spider): self.client = pymongo.MongoClient(self.DB_URL) self.db = self.client[self.DB_NAME] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): collection = self.db[spider.name] # 三元表达式（调用前先对item的类型进行判断，如果item是Item对象，就将其转换为字典) post = dict(item) if isinstance(item, Item) else item collection.insert_one(post) return item from_crawler(cls, crawler) 如果存在，则调用这个类方法来从爬行器创建管道实例。它必须返回管道的新实例。爬虫对象提供对所有Scrapy核心组件的访问，如设置和信号；它是管道访问这些组件并将其功能挂钩到Scrapy的一种方式。 cls（item pipeline类）（如果创建MongoDBPipeline类就为MongoDBPipeline类对象 crawler（Crawlerobject） - 使用此管道的crawler（可以通过crawler.settings访问该配置setting.py文件） open_spider() &amp; close_spider()在Spider整个爬取过程中，数据库的连接和关闭操作只需要进行一次，应在开始处理数据之前连接数据库，并在处理完所有数据之后关闭数据库，因此实现以下两个方法(在Scrapy打开和关闭时被调用)。 process_item(self, item, spider) 每个项目管道组件是一个Python类，必须实现以下方法： process_item(self, item, spider)； 对于每个项目管道组件调用此方法。process_item() 必须：返回一个带数据的dict，返回一个Item （或任何后代类）对象，返回一个Twisted Deferred或者raise DropItemexception。 在process_item中实现MongoDB数据库的写入操作，使用self.db和spider.name获取一个集合(collection)，然后将数据插入该集合。 在配置文件中配置MongoDB的url和name打开Setting.py在任何位置写入（如果不写则默认使用MongoPipeLine.from_crwaler()中的信息）： 12MONGO_DB_URI = 'mongodb://localhost:27017'MONGO_DB_NAME = 'python_ZhuanLan' 启动MongoPipeline组件打开Setting.py，把MongoPipeline添加到ITEM_PIPELINES中，后面的数字代表它们的运算优先级（顺序），item按数字从低到高的顺序，通过pipeline（1-1000，数字越低组件的优先级越高）： 123ITEM_PIPELINES = &#123; 'zhihu_Crawl.pipelines.MonoDBPipeline':300,&#125; 参考资料： Scrapy使用Pipeline写入MongoDB Scrapy中文文档-Item Pipeline]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Crawler</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Scrapy遇到的问题汇总]]></title>
    <url>%2Fpost%2FThe-Problem-Collection-Use-Scrapy.html</url>
    <content type="text"><![CDATA[简单记录一下，自己再安装和使用Scrapy框架过程中遇到的各种问题及解决办法 安装使用环境：Win10 1803、Python 3.6.3 利用pip命令可以直接安装Scrapy，但是会出现一些安装包装不上而报错，比如Twisted。可以先去这个Pyhton Extension Packages下载Twisted到本地，然后单独安装 1pip install twisted （注意要下载Twisted‑18.9.0‑cp36‑cp36m‑win_amd64.whl不要下载错了，是cp36。否则安装的时候会提示is not a supported wheel on this platform） Scrapy输出文件编码为’utf-8’在编写爬虫中文内容输出到*.json文件后发现中文是Unicode编码，尝试了各种方法测试都不成功，后来找到一种方法终于成功了，把Scrapy项目文件夹中的Setting.py增加一行配置： 1FEED_EXPORT_ENCODING = 'utf-8' Scrapy导出csv文件乱码使用Vscode的通过编码重新保存，将文件的编码格式改为UTF-8 with BOM，再重新用Excel打开csv就正常了。 参考：https://blog.csdn.net/u011361138/article/details/79912895 Scrapy异常：http status code is not handled or allowed原因是http状态码没有被识别，需要在settings.py中添加这个状态码信息，同样在Setting.py添加一行（如果是404错误就改为404，如果是400错误，就改成400： 123HTTPERROR_ALLOWED_CODES = [状态码]HTTPERROR_ALLOWED_CODES = [404]HTTPERROR_ALLOWED_CODES = [400] 另一种方法是在Spider函数中添加 12handle_httpstatus_list = [404]handle_httpstatus_list = [400] 如果还是出现400错误问题，我观察到后面的Debug信息是：*/robots.txt。 robots.txt（爬虫协议)是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。——wiki 知乎robots地址：https://www.zhihu.com/robots.txt 淘宝robots地址：https://www.taobao.com/robots.txt 总结来说这个爬虫协议允许爬虫机器爬取的范围，不过这个协议属于君子协议，Scrapy默认是遵循robot协议，需要在Setting.py中改变ROBOTSTXT_OBEY的值为False。 在做了上面的设置之后还是400错误，可以给Reaqueset请求添加一个Headers头部，可以让爬虫伪装成浏览器 1234567headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36',&#125;def start_requests(self): url = 'http://www.hnfnu.edu.cn/index/xyxw/342.htm' # 这样就不要设置Start_urls变量了 yield Request(url, headers=self.headers) 不过在我今天在爬去知乎专栏的文章（Ajax加载），调试了很久也只能抓取到第一次加载的列表内容，检查了后面的yiled Requeset(url, callback=self.parse) 设置没有问题，然后我把Headers信息添加在Setting.py中问题就解决了： 123DEFAULT_REQUEST_HEADERS = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36',&#125; 未完待补充……]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xlua热补丁修复]]></title>
    <url>%2Fpost%2Fxlua-hotfix.html</url>
    <content type="text"><![CDATA[使用xlua热补丁修复 在使用Ulua方法进行热更新的时候，在项目的开发阶段就必要用独立的Lua脚本实现，这样才能使用Ulua来进行热更新，但是如果一个项目完成之后发现需要进行热更新，这个时候用ULua就非常不方便了。但是XLua可以解决这个问题，解决方案就是“HotFix”热补丁。（对项目进行修补）实现方式： 对要进行“修补”的C#类，在该类的头部[Hotfix]标签来标记，对于已经使用了[hotfix]标记了的类，可以通过“Lua”代码修改“类中的方法”。 使用HotFix进行热修复环境准备添加宏信息 File–&gt; Build Settings… –&gt; Player Settings… –&gt; Configuration：Scripting Define Symbols：HOTFIX_ENABLE；（对于每一个平台都需要添加这条宏信息！） 执行菜单生成命令XLua-&gt;Generate Code，该命令执行完毕后会生成一堆Wrap 文件，存放到XLua/Gen 文件夹下。 执行菜单注入命令XLua-&gt;Hotfix Inject In Editor，成功之后，会在控制台输出：“hotfix inject finish!”或者“had injected!”。 如果出现红色警告提示“please install the Tools”，就需要把Tools 文件夹拷贝到项目中，和Assets 文件夹同级别位置。 只要修改过C#中的代码，就需要重新执行注入命令！（否则会报错） HotFix热修复案例Hotfix语法 引入命名空间：using Xlua; 对要进行热修复的C#类用【hotfix】标记 编写hotfix命令：xlua.hotfix(CS.类名, &#39;方法名&#39;, lua 方法)（对于CS.类中的某个方法使用lua方法修复） 创建XLua虚拟机对象（Lua解析器），使用Dostring方法执行。 修复案例123456789101112131415161718192021222324252627282930313233343536373839using UnityEngine;using XLua;[Hotfix]public class HotFixDemo : MonoBehaviour &#123; private LuaEnv luaEnv; private string hotfixStrOne = @" xlua.hotfix(CS.HotFixDemo, 'Hello', function() print('Lua Hello~~') end) "; private string hotfixStrTwo = @" xlua.hotfix(CS.HotFixDemo, 'Add', function(self, a, b) print('Lua中的乘法:' .. a*b) end) "; void Start () &#123; luaEnv = new LuaEnv(); &#125; void Update () &#123; if(Input.GetKeyDown(KeyCode.A))&#123; Hello(); Add(5, 2); &#125; if (Input.GetKeyDown(KeyCode.Space))&#123; luaEnv.DoString(hotfixStrOne); luaEnv.DoString(hotfixStrTwo); &#125; &#125; private void Hello()&#123; Debug.Log("C# Hello~~");&#125; private void Add(int a, int b)&#123; Debug.Log("C#中的加法：" + (a + b));&#125;&#125; 有参方法修复时，需要传递当前脚本对象this，在lua 中用self 代替。 要修复无参的方法，但是那个方法内使用到了该类中的字段，如果想要在Lua代码中方法到，有两种方法： C#类中的字段公开（使用Public修饰），在lua代码中通过self.字段名的方式来方法（破坏了C#语言的“封装性”） 在lua 语言中，使用代码获取C#类中private 成员的访问权xlua.private_accessible(CS.类名)，这样就可以在Lua 脚本中访问到C#类当中的私有成员，同时不会破坏C#原有的封装性和逻辑关系。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>xLua</tag>
        <tag>Untiy</tag>
        <tag>热更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleFrameWork框架简单介绍]]></title>
    <url>%2Fpost%2FSimpleFrameWork-Introduction.html</url>
    <content type="text"><![CDATA[SimpleFramework的框架介绍 SimpleFramework 框架SimpleFramework 框架是ULua的集成开发环境 SimpleFramework 框架官网地址： http://www.ulua.org/index.html SimpleFramework 分为两个版本：NGUI 版和UGUI 版，区别是NGUI 版本的框架资源中含有NGUI 这个插件。 SimpleFramework 和ULua和Lua的关系ULua是对原生Lua 环境进行了一次“包装”，用于满足Unity 环境下的热更新需求。为了更方便的使用，于是又对ULua进行“二次包装”，包装成了一个框架：SimpleFramework，比如它们创建Lua的解析器对象都不相同。 Lua：Lua lua = New Lua(); Ulua：LuaState Lua = new LuaState(); SimpleFramework:LuaScriptMgr lua = new LuaScriptMgr(); 它们的关系是：SimpleFramework &gt; ULua &gt; Lua SimpleFramework框架资源结构 Examples：SimpleFramework 热更新案例； Lua：SimpleFramework 框架自带的Lua 源码文件；（自己写的Lua脚本放在这个路径） NGUI：NGUI3.8.2，当你需用更高版本的NGUI 时，替换即可，不需要碰； Plugins：uLua 运行所依赖的底层库文件，不需要碰； Scripts：SimpleFramework 自带的C#脚本文件； uLua：uLua 全部代码。 和Ulua紧密相关的是：Plugins、uLua。和SimpleFramework相关的是：Examples、Lua、Scripts 使用框架框架自带的编辑器命令 Lua菜单：uLua 环境相关处理命令(必备操作) Gen Lua Wrap Files：生成LuaWrap文件 该命令用于生成“Lua 包装文件”，存放在uLua\Source\LuaWrap 目录下。该文件夹下全部是C#脚本，这些脚本文件的名称特点是：脚本名+ Wrap；该文件夹下的脚本对Unity 内常用组件脚本的二次包装，、 Lua 环境运行后，会把这些Wrap 文件加载到Lua 运行环境(Lua 虚拟机)中，最终的效果就是：Lua 调用Wrap 文件，Wrap 文件调用C#，来实现Lua 调用C#。 Clear Lua….. Wrap Files：清除LuaWrap文件，也可以自己手动删除。 Game菜单：Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]Game–&gt;Build Windows Resource 生成Windows 平台下的AB 文件。生成后的AB 会存放到StreamingAssets 文件夹下。在生成的过程中同时还会把Lua 文件夹下的所有脚本拷贝到该目录，存放到lua 文件夹下。 在\Assets\uLua\Editor\Packager.cs脚本中的HandleLuaFile方法就是将/Lua/文件复制到/StreamingAssets/文件夹中（这是本地Server设置的资源的地址，模拟服务器的资源地址） Lua 文件夹结构分析 3rd：第三方的Lua 脚本插件； Common：公共Lua 文件目录； Controller：控制器目录； Logic：管理器目录； System：cstolua 的系统目录； View：视图层目录。 ULua 文件夹结构SimpleFramework 框架项目的核心是uLua，在Unity 环境下使用uLua可以实现Lua 脚本与Unity 内C#脚本的交互，通过Lua 脚本来操作Unity3D内的各种游戏组件。 Core：uLua 核心； Docs：uLua 文档，其实就是LuaInterface 的PDF 使用文档； Editor：uLua 编辑器扩展；[备注：项目内所有的Editor 文件夹都是编辑器扩展文件夹，并不局限于根目录] Examples：uLua 自带演示案例； Source：cstolua 核心目录。 备注：参考：擅码网Lua热更新文档资料]]></content>
      <categories>
        <category>Unity</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>ULua</tag>
        <tag>SimpleFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleFramwork框架下Ulua与C#的交互]]></title>
    <url>%2Fpost%2FUlua-And-Charp-Communicate.html</url>
    <content type="text"><![CDATA[在SimpleFramwork框架下，Ulua与C#的交互！ uLua环境下与C#交互（基本操作）在C#与Lua进行交互需要两个DLL文件来实现分别是Luainterface.dll（C#脚本使用Lua）、luanet.dll(Lua脚本调用C#)。因此需要事先把那两个DLL文件拷贝到项目路径中去，再引用。 在uLua 环境下本质也是通过LuaInterface 来实现Lua 与C#语言交互的。但是uLua 对LuaInterface 进行了二次的封装，不需需要自己手动拷贝这个DLL文件，但是的使用的使用还是要引入命名空间：using LuaInterface; Lua 代码与Unity 内的类的交互[反射方式/ 原生方式]1234567891011121314// 定义了一个字符串变量保存Lua代码（调用C#的类和方法来创建了一个游戏物体，并给它添加了一个“BoxCollider”组件） private string str1 = @" luanet.load_assembly('UnityEngine') GameObject = luanet.import_type('UnityEngine.GameObject') BoxCollider = luanet.import_type('UnityEngine.BoxCollider') local player = GameObject('Lemmo') player:AddComponent(luanet.ctype(BoxCollider)) ";// 创建一个Lua解析器对象，并执行上面定义的Lua脚本 void Start()&#123; LuaState lua = new LuaState(); lua.DoString(str1); &#125; luanet 已经被封装到了LuaInterface 命名空间内，所以我们可以在Lua代码中直接使用luanet 这个对象； 在Lua 环境内操作C#中的类创建对象，不要写new 关键字！ 在Lua 环境内操作C#中的类创建对象，访问对象中的方法使用分号（:）； 这种“反射方式”在项目开发中并不常用，但是也有用无之地，真正大量使用的是下方的Wrap 方式。 同样需要在C#代码中引入LuaInterface； 原生的Lua 解析器对象“Lua”被二次封装成了“LuaState”； LuaState 类存在的位置是：uLua\Core\Lua.cs。 Lua 代码与Unity 内的类的交互[Wrap 方式]1234567891011121314 // 和Str1的功能类似，只不过str2使用了Wrap的方式private string str2 = @" luanet.load_assembly('UnityEngine') GameObject = UnityEngine.GameObject BoxCollider = UnityEngine.BoxCollider local player = GameObject('WrapLemmo') player:AddComponent(BoxCollider.GetClassType()) "; void Start()&#123; LuaScriptMgr lua = new LuaScriptMgr(); lua.Start(); lua.DoString(str2); &#125; 说明： 这种是在uLua 开发过程中最常用的方式，95%+情况都是使用这种方式； Wrap 方式实现Lua 调用C#，依赖的是之前生成的LuaWrap 文件； [也就是我们通过菜单自动生成到uLua\Source\LuaWrap 下的脚本文件] 当使用Wrap 方式时，运行Lua 代码需要使用LuaScriptMgr； 需要把AppConst.cs 脚本中的的DebugMode 修改为true。 包装新的Wrap 脚本当我们用Lua 的Wrap 方式访问Unity 中的组件脚本，或者自己写的脚本的使用，如果这些脚本没有自动生成“xxxxWrap”,项目运行后，就会报错。比如在用Wrap的方式给Player对象通过Lua添加Animator组件的时候，就会报错. 12Animator = UnityEngine.Animator player:AddComponent(Animator.GetClassType()) 解决办法：往框架内添加需要处理的新的类。 找到uLua\Editor\WrapFile.cs 打开该脚本，使用该格式进行添加：_GT(typeof(类名)) ； Lua–&gt;Clear LuaBinder File + Wrap File 清空原有的Wrap 文件； Lua–&gt;Gen Lua Wrap Files 重新生成Wrap 文件； 关于Lua使用“.”和“:”来调用属性和方法在Lua语言中，直接调用操作C#中的对象的方法和属性直接使用“.”来调用，如果是在Lua代码中实例化出来的对象，再调用这个对象的方法则需要用“:”]]></content>
      <categories>
        <category>Lua - Ulua</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>热更新</tag>
        <tag>Lua</tag>
        <tag>SimpleFramwork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua与Charp交互]]></title>
    <url>%2Fpost%2Flua-with-csharp.html</url>
    <content type="text"><![CDATA[Lua与C#的交互 Lua与C#进行交互在项目中，C#语言是主语言，Lua 语言是辅助语言，如何才能让两门语言的代码互相访问那？这时候我们需要一座“桥梁”来连接两门语言。 LuaInterfaceLuaInterface 就是C#与Lua 语言相连的那座桥梁。LuaInterface 是一个开源的项目工程，内部有两个核心的DLL 文件： LuaInterface.dll：在C#代码中操作Lua 代码需要依赖该文件； luanet.dll：在Lua 代码中访问C#的类库脚本需要依赖该文件。 在项目中配置使用Lua环境 将两个dll 文件拷贝到项目工程中； 项目工程设置“引用”导入LuaInterface.dll； 将两个dll 的属性都设置成“如果较新则复制”（非常重要，如果不引用则会报错） 使用lua解析器对象 引入using LuaInterface;命名空间； 实例化lua解析器对象：Lua lua = new Lua()； 使用lua解析器对象的一些方法。 123456789101112131415using System;using LuaInterface;namespace LuaThree&#123; class Program &#123; static void Main(string[] args) &#123; Lua lua = new Lua(); lua.DoString("print('This is Lua program')"); // 这里执行的是Lua代码 Console.ReadKey(); &#125; &#125;&#125; C#中Lua代码空间分析 实际上，虽然C#代码和Lua代码是在一个脚本文件中，但是在程序执行的时候，lua代码（上面第11代码是放到了Lua的那块空间去的） C#调用Lua代码C#内执行lua代码语法：Lua解析器对象.DoString(&quot;Lua代码&quot;) 示例： 1234567891011121314151617181920Lua lua = new Lua();//1. 变量的声明与访问；lua.DoString("name = 'YangJie' age = 19 gender = 'Man' address = 'HuNan'");Console.WriteLine(lua["name"]);//2. for循环语句；[演示@符号的用途]lua.DoString(@"for i = 1,10,1 do print(i) end ");//3. 函数的定义与调用；lua.DoString(@"function Show() print('Show LuaFunction in Csharp.'); end Show()");//4. table 数组声明lua.DoString(@" MyArray = &#123;'AAA', 'BBB', 'CCC'&#125;"); C#中调用外部的Lua脚本在实际的时候中，大都汇直接调用外部的Lua脚本 语法：Lua解析器对象.DoFile(&quot;[path]fileName.lua&quot;)方法。 创建Lua脚本文件：添加-&gt;新建项-&gt;常规-&gt;文本文件，改名且后缀写为.lua;（注意要用其他的编辑器把编码格式从“UTF-8 BOM”改成 “UTF-8”或“GB2312”(中文编码)，否则会抛异常） 注意：在创建Lua文件之后，在VS里面将该文件的“复制到输出路径”设置为“如果较新则复制”，否则也会抛异常。（无法找到该文件） 示例：MyLua.lua脚本 1234567name = "Yangjie"address = "HuNan"age = 19function Fun() print("Lua脚本内的方法")end C#执行脚本 123456789lua.DoFile("MyLua.lua");string name = lua.GetString("name");string address = lua.GetString("address");Double age = lua.GetNumber("age");Console.WriteLine(name + ".." + address + ".." + age.ToString());LuaFunction luaFunction = lua.GetFunction("Fun");luaFunction.Call(); Lua调用Charp对于C#的项目来说，Lua脚本是作为资源存在资源路径下，我们可以对Lua脚本的进行热更新。而Lua脚本就需要访问C#脚本。在Lua中调用C#脚本需要使用luanet.dll这个类库。 使用步骤： 导入luanet.dll：require &quot;luanet&quot; 获取程序集：luanet.load_assembly(&quot;程序集名&quot;) 获取类型：变量名 = luanet.import_type(&quot;程序集名.类名&quot;) 示例Calc.cs（C#中创建一个类，省略了一些代码） 12345678910111213class Calc&#123; public static string name = "Calc计算器类"; public static int Jia(int a, int b) &#123; return a + b; &#125; public static void Show() &#123; Console.WriteLine("这是Calc内的方法"); &#125;&#125; LuaUpdate.lua脚本 123456require "luanet" -- 导入luanet.dllluanet.load_assembly("LuaThree") -- 导入程序集Calc = luanet.import_type("LuaThree.Calc") -- 导入类print(Calc.Jia(10, 20)) print(Calc.name) Program.cs（只保留了核心代码） 123456Lua lua = new Lua();lua.DoFile("LuaUpdate.lua");// 输出结果：// 30// 这是Calc内的方法 Lua内方法C#的类库导入步骤和上面的几乎类似，比如我想导入Console 12345require "luanet" luanet.load_assembly("System")Calc = luanet.import_type("System.Console")Console.WriteLine("Lua内调用C#的类库") 其他主要资料来自擅码网Lua课程。]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>lua</tag>
        <tag>Charp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪杰特斯拉算法(Dijkstra)]]></title>
    <url>%2Fpost%2FDijkstra's-algorithm-use-python.html</url>
    <content type="text"><![CDATA[迪克斯特拉算法（英语：Dijkstra’s algorithm）是采用了「广度优先搜索」解决在“加权图”中最短路径的问题 理解迪克斯特拉算法使用「广度优先搜索」算法，可以对「非加权图」查词最短路径 但是对于「加权图」的最短路径问题，则需要使用「迪克斯特拉算法」 这个图包括四个顶点（起点、A、B、终点），以及连接这些点的边，边上的数字是一点的另一点的「花销」，或者叫做权重。权重越大，花销就越大，反之，花销就越小。要找到从「起点」到「终点」的最短路径，需要在所有路径中找到「总权重」最小的一条路径。下图是我们任意寻找的一条路径，我们可以用迪克斯特拉算法在所有的路径中找出最短（优）的那条路径。 实现迪克斯特拉算法的步骤 找出“最便宜”的节点（花销最低），即可在最短时间内到达的节点。 更新该节点的邻居的开销。 重复这个过程，直到对图中的每个节点都这样做了。 计算最终路径。 代码实现迪克斯特拉算法需要实现找到图2的最短路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 创建一个散列表来模拟路径图graph = &#123;&#125;# 一条路径采用了两个散列表，例如["start"]表示自身节点、["a"]表示邻居节点， 6 表示自身节点前往邻居节点的花销graph["start"] = &#123;&#125;graph["start"]["a"] = 6graph["start"]["b"] = 2graph["a"] = &#123;&#125;graph["a"]["fin"] = 1graph["b"] = &#123;&#125;graph["b"]["a"] = 3graph["b"]["fin"] = 5graph["fin"] = &#123;&#125;# 创建节点的开销：表示从「起点」出发到该节点需要的“时间”，对于非起始节点的「子节点」我们并不知道它的花销，假设它为无穷大infinity = float("inf") # 表示无穷大costs = &#123;&#125;costs["a"] = 6costs["b"] = 2costs["fin"] = infinity# 创建父节点的散列表parents = &#123;&#125;parents["a"] = "start"parents["b"] = "start"parents["fin"] = None# 记录处理过的节点processed = []# 查找开销最低的节点def find_lowest_const_node(costs): lowest_const = float("inf") lowest_const_node = None for node in costs: cost = costs[node] if cost &lt; lowest_const and node not in processed: # 如果当前节点开销更低且为处理过 lowest_const = cost # 将其视为开销最低的节点 lowest_const_node = node return lowest_const_nodenode = find_lowest_const_node(costs) # 在未处理的节点中找出花销最小的节点while node is not None: # 这个while循环在所有节点都被处理过后结束 cost = costs[node] neighbors = graph[node] for n in neighbors.keys(): # 遍历当前节点的所有邻居 new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: # 如果当前节点前往该邻居更近 costs[n] = new_cost # 则更新该邻居的开销 parents[n] = node # 同时将该邻居的父节点设置为当前节点 processed.append(node) # 将当前节点标记为处理过 node = find_lowest_const_node(costs) # 找出接下来要处理的排名，并循环# 用于显示输出效果 for key,value in costs.items(): print(key + ":" + str(value)) print("\n-----------------\n")for key,value in parents.items(): print(key + ":" + value) 运行结果： 「终点」的父节点是「a」、「a」的父节点是「b」、「b」的父节点是「start」，这样就把这个加权图的最短路径给找出来了。 小结 广度优先搜索用于在非加权图中查找最短路径。 狄克斯特拉算法用于在加权图中查找最短路径。 仅当权重为正时狄克斯特拉算法才管用。 如果图中包含负权边，请使用贝尔曼-福德算法。 参考资料 《算法图解》第7章节]]></content>
      <categories>
        <category>Python</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[生存之战]_背包合成模块制作总结]]></title>
    <url>%2Fpost%2Fthe-inventory-module-of-war-game.html</url>
    <content type="text"><![CDATA[断断续续花了半个月的时间，把《生存之战》背包系统大概做出来了。这也相当于一个大项目的一个较为完整的模块，现在整理一下，也方便以后回顾。 成品 项目介绍 整体上这属于一个背包系统，包括1的「背包模块」和2「合成模块」 背包模块背包模块比较简单，由一个整体的背景，背包背景子层生成固定数量的背包框，背包物体动态生成，数据是从Json的数据进行解析。 合成模块合成模块相对比较复杂一点，整个上分为3个相对独立的部分（2.1和2.3在搭建UI层次的时候可以先分为一个，然后在拆分成2.1 和 2.3） 2.1是合成的类型，比如武器类可以有弓箭、长矛；而建筑类可以有窗户、门。 2.2是具体的合成物品的种类，比如上面提到的弓箭、长矛等。 2.3是某个物品的合成图谱，也就是说合成这个物品需要哪些原材料，在合成之前需要把原材料从背包模块拖拽到对应的图谱位置。 2.4是进行合成的具体区域，当某个物品的合成图谱全部被填充好之后，才可以进行合成。 搭建UI布局这里的UI布局是“死”的UI，先把整个的UI布局确定好，后面再根据这个UI布局进行灵活的“动态生成”，“逻辑控制”。搭建UI布局要注意的点： “大元素套小元素”，相对大的元素与覆盖在它表面的相对小的元素形成父子关系。这也是在Web开发中常常会使用到的「Div + CSS」布局的思路。 重复的子元素（比如合成图谱分类的Tab、各种的物品框）才表格布局的方法，先手动复制多个元素调试到适合的布局，再将这个元素制作成一个「预制体」，最后在代码中动态生成。 代码部分M.V.C架构介绍在以前的案例制作中，常常会把「数据控制」「UI控制」「逻辑控制」放到一个Manager的控制脚本中，这样做的问题时，单个脚本的代码量非常庞大，管理起来不方便。因此，我们可以把UI相关的脚本分为三块： 数据控制[Model] (对XML、Json 读取，存储，更新…) 界面控制[View] (组件查找，UI 数据更新…) 整体逻辑[Controller] (循环生成子元素，UI 的事件处理，商品购买…) 迷你版MVC迷你版MVC 主要应用在UI 功能模块的Panel 上，也就是模块的整体控制。 XxxxPanelView.cs XxxxPanelController.cs XxxxPanelModel.cs 而Panel 的子级物体还是单个脚本控制，叫做XxxxItemController.cs，因为子级物体逻辑相对简单，可以先不分层。 使用迷你版MVC的注意事项 创建好MVC的三个脚本挂载到XxxPanel之后，「Controller脚本」要分别持有「View脚本」「Model脚本的引用」。因为「Controller脚本」处于主导地位。「View脚本」与「Model脚本」不直接通信。 Model脚本把加载好的数据以字段封装成属性的方式公开，Controller脚本可以调用，View的设置UI的方法也公开，通用供Controller脚本使用。 View 和Model 脚本当中的初始化操作需要放到Awake 方法内，Controller的初始化放到Start 方法内。目的是为了Controller 控制界面和数据的时候，这两个脚本必须已经初始化完毕。 脚本分析 从上面的脚本关系图可以看出，整体上有两个「MVC框架」，因为我们之前已经把背包系统分为了两个模块，背包模块和合成模块，所以使用两个「MVC」分别对背包模块和合成模块进行控制： 背包模块 InventoryPanelController.cs InventoryPanelView.cs InventoryPanelModel.cs 合成模块 CraftingPanelController.cs CraftingPanelView.cs CraftingPanelModel.cs 背包模块背包模块比较简单： View层查找相关组件，并加载（Resources）生成UI所需的预制体供Controller层使用； Model层从Json文件中解析出生成背包物体所需要的数据，并公开相应的方法让Controller使用这些数据；注意这里还创建想背包物体的「数据实体类」InventoryItem.cs Controller层负责调用View层和Model层的数据，循环生成UI物体 合成模块合成模块相对于背包模块来说复杂一些，主要体现在Controller脚本中有几个子类物体的控制脚本。主要是因为北城模块的UI层次就很复杂，但是合成模块的MVC职责分工和背包模块的MVC的职责分工是一样的。 需要注意的是，「CraftingPanelController.cs」负责总的逻辑控制，而它的子物体的控制脚本只需要负责公开方法供它使用就可以的。 如果生成子类物体的时候想要初始化它的控制脚本的数据，可以在子类的控制脚本定义一个初始化的方法Init（），在生成子类的之后就调用它的子类控制脚本的初始化方法，并传递必要的数据。 模块间进行通信两个模块进行通信，可以先把两个MVC的「Controller脚本」封装成单例，然后通过XxxxPanelController.Instance.方法名()的方式进行通信。 需要注意的是，模块与模块之间，最好只是两个Controller层通信，比如：》 InventoryItemController.cs想要调用CarftingPanelController.cs的方法则可以先在InventoryPanelController.cs声明一个公开的方法去调用CarftingPanelContoller的方法 然后InventoryItemController.cs再去调用那个公开的方法。 这样做的目的是单一“脚本的职责”，减少脚本的耦合 工具类在上面的脚本关系图中，最右边有两个工具类，分别是ResourcesTools.cs和JsonTools.cs，这两个脚本是在脚本编写过程中抽离出来的（在实际开发过程中，这些工具类是事先已经提供好的，可以直接进行使用，一般是“主程”编写好的），它与游戏逻辑没有直接业务关系。但是游戏逻辑需要使用到这些工具类。工具类的特点： 工具类的实现有两种语法格式：密封类，结构体；最常用的还是密封类（sealed）格式； 工具类内的成员全部用static 静态关键字修饰； 工具类不需要实例对象，使用格式是：工具类名.字段名/属性名/方法名/； 工具类就是一个普通的C#类，不需要继承Mono 行为类。 其他 项目文件：链接: https://pan.baidu.com/s/1yeGrQNXHshJfAWG9N9gzhA 密码: wfnk]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>UI</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-简单的递归]]></title>
    <url>%2Fpost%2Frecursion-algorithm-with-python.html</url>
    <content type="text"><![CDATA[什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身称为递归调用。 递归什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身成为递归调用。 “庙里的老和尚”的故事可以用来理解这种模式 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’” ——维基百科 递归函数使用递归函数的关键： 找出基线条件，退出递归函数 缩小问题的规模 用递归来求和 用循环来求和 12345def sum(arr): total = 0 for x in arr: total += x return total 用递归的求和 1234567def sum(arr): if arr == []: return 0 return list[0]+sum(list[1:]) print(sum([12,4,17,9])) # 输入结果：42 用递归来计算列表的长度1234567def countElem(arr): if arr==[]: return 0 return 1+countElem(arr[1:]) print(countElem([12,4,17,9]))# 输出结果：4 用递归来找出最大元素1234567def maxElem(arr): if len(arr) == 1: return arr[0] return arr[0] if arr[0] &gt; maxElem(arr[1:]) else maxElem(arr[1:])print(maxElem([12,4,17,9]))# 输出结果：17 理解return-if-else：这是Python支持的一种语法。 1return "a" if 1&lt;2 else "b" 在这里1&lt;2是判断条件，如果条件成立则返回“a”，如果条件不成立则返回“b” 快速排序（quick）1234567891011def quicksort(array): if len(array) &lt; 2: return array else: pivot = array[0] # 递归条件 less = [i for i in array[1:] if i &lt;= pivot] greater = [i for i in array[1:] if i &gt; pivot] return quicksort(less) + [pivot] + quicksort(greater) print(quicksort([12,4,17,9])) # 输出结果：[4, 9, 12, 17] 基线条件：2行：当数组为空或者只包含一个元素，这样最后只需要原样恢复数组，不用再进行排序 pivot是基准值，用于对其他的数进行分类 less存储的是比pivot小的数组成的数组 greater存储的是比pivot大的数组成的数组 快速排序的算法复杂度O(n * Log n) 参考资料 递归算法详解]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪米特原则]]></title>
    <url>%2Fpost%2Flaw-of-demeter.html</url>
    <content type="text"><![CDATA[迪米特原则也叫最小知道原则 定义： 一个对象应该对其他对象保持最少的了解。 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另外一个类的某一个方法的话，可以通过第三者转发这个调用。 一个对象应当对其他对象有尽可能少的了解。 迪米特原则的切入点 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。 Unity 项目开发，不要使用public 公开字段，然后面板拖拽资源赋值这种方式。应该把字段全部private 修饰，然后public 属性公开调用。 迪米特原则主要是强调了类与类之间的松耦合 类与类之间的耦合度越低，越有利于代码的复用，一个处于低耦合的类被修改了，不会对有关系的类造成影响 参考资料 迪米特原则]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP六大原则</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖倒置原则]]></title>
    <url>%2Fpost%2Fdependence-inversion-principle.html</url>
    <content type="text"><![CDATA[针对抽象编程，不要针对实现编程； 官方定义 A. High-level modules should not depend on low-level modules. Both should depend on abstractions. B. Abstractions should not depend on details. Details should depend on abstractions. 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口)。 模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。 理解参考擅码网的讲解 PHP中的依赖倒置原则 代码逻辑并不是直接操控数据库，而是通过一个抽象的PDO类来进行增删改查，这样的好处是如果要更改使用的数据库类型，比如原本是使用「MySQL」，现在要改成「SQLite」，只需要对PDO类更改操作数据库的逻辑，而关键的「代码逻辑」不需要发生任何变化。 Unity引擎的依赖倒置Unity引擎的跨平台性很强 早期开发游戏 Android 平台的游戏，需要使用Eclipse 开发，只能运行于Android 平台； IOS 平台的游戏，需要使用XCode 开发，只能运行于IOS 平台； 因为编写这些游戏时，使用的代码，都是各个平台提供的针对性的API。 高层依赖于底层：开发游戏需要依赖于该平台的底层API。 Unity开发游戏 使用C#开发一个版本，稍作调整就能发布到N 个平台。在我们发布成不同平台的游戏的时候，Unity 本身就做了一个“对接”的任务，把我们的代码里面的API，对接到该平台上相应的API。 高层和底层都依赖于抽象：我们的游戏是依赖Unity 的，各个平台的API 也是Unity 完成对接任务的。]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP六大原则</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开闭原则]]></title>
    <url>%2Fpost%2Fopen-closed-princicle.html</url>
    <content type="text"><![CDATA[开闭原则 规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的” 定义：软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。 面对需求，对程序的改动应该是以增加新代码的方式解决，而不是更改旧的代码。 在实际开发过程中，开发的某个功能，可能因为需求有变化，要重新构建新的代码。但是原来的代码也不能删掉，如果之后需求再发生变化，又要换到之前的代码，则只需要简单更换一个业务逻辑即可。 开放封闭原则，其中的封闭不是绝对的封闭。]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP六大原则</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jieba库制作统计水浒传角色的词频]]></title>
    <url>%2Fpost%2Frole-name-count-in-shuihu-use-Jieba.html</url>
    <content type="text"><![CDATA[这是学习Python一个星期依赖独立制作的一个比较小的案例脚本，计算一段文本的「词频」 案例介绍统计出某一文本中词条的词频。这个案例我是用水浒传文本来统计出每一名角色(108将)出现的次数 案例知识点 使用Jieba模块分词 使用json模块将字典导出成json文本 Python的IO操作 案例准备 Windows 10 Python 3.6 安装好JieBa库 《水浒传》.txt文本 水浒108将.txt文本 项目文件结构12345.├── namerate.json├── RoleCount.py├── role.txt└── shuihu.txt 安装JieBa库 jieba 是一个python实现的分词库，对中文有着很强大的分词能力。 Git链接：https://github.com/fxsjy/jieba 1py -3 -m pip install Jieba 处理素材文本“水浒传.txt”不需要额外处理，但是“108将”需要使用「正则表达式」进行处理，处理结果最后应该是，每一行文本只有一个将领的名字。 实验脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import jiebaimport json# 108将字典roles = &#123;&#125;# 存储水浒所有的文本shuihu_str = ''# 导入文件的名字filename = 'namerate.json'# 把108将添加到jieba词库中去def AddWords(): for name in roles: jieba.add_word(name)# 打开role文本，创建字典with open("role.txt", 'r', encoding='UTF-8') as file_Object: for name in file_Object: roles[name.strip()] = 0AddWords()# 打开shuihu文本，存储到shuihu_str变量中去with open("shuihu.txt", 'r', encoding='UTF-8') as file_Object: lines = file_Object.readlines() for line in lines: shuihu_str += line.strip()# 分词匹配seg_list = jieba.cut(shuihu_str, cut_all=False)for word in seg_list: for role in roles: if(role == word): roles[role] += 1 breakprint("匹配完毕")with open(filename, 'w') as f_obj: f_obj.write(json.dumps(roles, ensure_ascii=False))# 在Cmd窗口输出字典for key, value in roles.items(): print(key) 案例制作总结这个项目遇到的最大的问题是“中文字符”的编码问题，比如在30行open的文本无法与str相加，可能是字符编码不相同，存储字典到.json的中文字符也是乱码的。]]></content>
      <categories>
        <category>Python</category>
        <category>Module</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Module</tag>
        <tag>案例</tag>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用bat脚本一键部署Hexo文章]]></title>
    <url>%2Fpost%2Fcreate-new-article-with-bat.html</url>
    <content type="text"><![CDATA[使用「Alt Run」和「Bat」脚本实现写Hexo文档的一键部署 每次用Hexo写文章，都需要先打开Cmd窗口转到D盘的Hexo的路径下，然后运行hexo new **，再定位到_post路径用「Typor」打开，最后还要使用hexo g hexo s等命令去部署，写一篇文档之前要浪费这样时间，尤其是复杂的操作降低了写作的积极性。为了减少操作，想到可以用脚本来代替自己的手动操作。最后使用alt run来打开脚本，更加快捷。 配置准备 Win10 操作系统 Hexo 博客 ALT Run：快速启动软件 编写的Bat脚本 编写脚本 一键创建文章 创建Hexo文章.bat 123456@echo offset /p name=input pages name:echo name:%name%echo please waithexo new %name% &amp;&amp; call 1.bat %name%pause 2行：从cmd窗口获取文章的名字 5行：创建从窗口获取的名字，同时调用1.bat这个脚本 1.bat脚本 12345start /min /w mshta vbscript:setTimeout("window.close()",1000)echo The InputValue is %1set name=%1echo %name%start /d "D:\Program Files\Typora\Typora.exe" Typora.exe "D:\Hexo\blog\source\_posts\%name%.md" 1行：延迟1秒执行 3行：「继承 创建hexo文章.bat」的变量 5行：使用D盘的「Typora.exe」MarkDown编辑器打开刚才创建好的文章 发布到本地服务器 发布到本地服务器.bat 123start hexo_g.batstart /min /w mshta vbscript:setTimeout("window.close()",3000)start hexo_s.bat hexo_g.bat 1hexo g hexo_s.bat 1hexo s 发布GitHub Page 发布到github.bat 123start clean.batstart /min /w mshta vbscript:setTimeout("window.close()",1200)start hexo_d.bat clean.bat 12345@echo offecho cleanecho Please waithexo cleanexit hexo_d.bat 1234@echo offecho postting.....hexo g -dpause 搭配AltRun快速启动什么，AltRun都不知道是什么，那还不快去了解一下，当然也可以使用其他的快速启动软件，或者把这些脚本的快捷键放到系统环境中，使用Win + Q启动。 在AltRun用到的热键： new：创建文章，并使用Typora打开 start：生成静态网页，并打开本地hexo服务器 post：用hexo clean清除public文件夹，并且发布到「github page」中去 参考资料： 使用bat批处理脚本优化hexo的使用体验 AltRun快速启动工具]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Pillow对图片转为字符画]]></title>
    <url>%2Fpost%2Fpython-learning-use-pillow.html</url>
    <content type="text"><![CDATA[这个案例来自实验楼的学习案例 实验知识点 pillow 库的使用 argparse 库的使用 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#-*- coding:utf-8 -*-from PIL import Imageimport argparse# 创建一个解析对象parser = argparse.ArgumentParser()# 向对象中添加要关注的命令行参数和选项parser.add_argument('file') #输入文件parser.add_argument('-o', '--output') #输出文件parser.add_argument('--width', type = int, default = 80) #输出字符画宽parser.add_argument('--height', type = int, default = 73) #输出字符画高#获取参数args = parser.parse_args()# 定义变量存储parser对象获取到的参数IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.outputascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. ")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]# 下面一行代码表示模拟程序的入口if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = "" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) # 实参前面使用*号表示传递元组 txt += '\n' print txt #字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open("output.txt",'w') as f: f.write(txt) 参考资料： Python 图片转字符画 用Python处理图像——PIL]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块之命令行解析工具-argparse]]></title>
    <url>%2Fpost%2Fpythone-argparse-tools.html</url>
    <content type="text"><![CDATA[如果设计的软件需要命令行参数（比如需要调用程序时附加一些参数，文件、字符或数字）就需要argparse模块，该模块是Python的标准库中的模块。 使用方法12345678import argparse # 首先导入该模块；parser = argparse.ArgumentParser() # 然后创建一个解析对象# 然后向该对象中添加你要关注的命令行参数和选项，每一个add_argument方法对应一个你要关注的参数或选项；parser.add_argument() # 最后调用parse_args()方法进行解析；解析成功之后即可使用 args = parser.parse_args() 案例1234567891011import sysimport argparseif __name__ == "__main__": parser = argparse.ArgumentParser() parser.add_argument("-m", type = int) parser.add_argument("-n", type = int) args = parser.parse_args() print "%d ^ %d = %d" % (args.m, args.n, args.m ** args.n) 分析： 在两条parser.add.argument方法中，接受运行的参数设置 -m后面的参数赋值给args.m -n后面的参数赋值给args.n 运行结果： 参考资料 https://blog.csdn.net/gatieme/article/details/45917173]]></content>
      <categories>
        <category>Python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python环境搭建]]></title>
    <url>%2Fpost%2Fpyton-env-build.html</url>
    <content type="text"><![CDATA[最近的在学Python，在搭建Python环境的时候遇到了很多困惑，这里整理总结一下留做以后参考，这篇文档是在Windows的环境下进行的 一台电脑可以安装多个Python吗答案是肯定的，我在电脑同时安装了两个版本的Python，分别是 Python 3.6.4 Python 2.7.14 先在python.org下载两个版本的安装包 安装在硬盘的不同路径中，比如我把Python 3.6安装在默认位置 把Python 2.7安装在D盘的路径下，并且在安装的时候勾选「Add to Path」添加路径到系统环境变量中去。​同时安装Python 3和Python 2如何快捷切换打开cmd窗口直接运行Python默认打开的Python 2但是我如果想使用Python 3怎么办？ Windows 上的 Python 自带启动器 py.exe，默认安装到系统盘的Windows文件夹里。如果你同时安装了 Python 2 和 Python 3，用的时候直接在终端里输入： 1py -3 就是打开的Python 3 的 REPL(控制台)同理如果你运行1py -3 #打开的是Python 3 而如果直接运行Py，默认打开的是Python 3，就是系统盘Windows文件下那个py.exe. 如果运行Python，则打开的Python 2,可能是因为后来安装了Python 2把Python 3给覆盖了。为了避免每次运行都需要通过py -2或py -3的方式启动，在编写Python程序的时候，可以在代码的前面加入声明说明该文件是由Python 2启动还是Python 3启动：12#! python2 #用Python2启动#! python3 #用Python3启动 其他方法： 改名：把Python 2版本中的文件名改成Python2，则默认运行的Python 3的版本 这样修改了名字的那个python对应的pip将无法使用。 在同一台电脑下如何进行 Python 2 与 3 的切换？——知乎Python和pip的关系什么刚开始，安装好Python 3之后，要导入第三方的库，别人的教程里面有很多pip命令，只是依葫芦画瓢，不懂是什么意思。后来要导入如一个turlte， 这是一个绘制图像的库。1pip install turtle #使用的Python 3 的pip工具 但是，提示错误Command &quot;python setup.py egg_info&quot;应该是安装脚本中脚本错误的啥的，具体也不清楚，想着再用Python 2试一下，这时候就完全懵逼不知道怎么来操作了。随后在网上了解了一下：pip就是Python的一个包管理工具 pip是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包。当然，Python也有其他的包管理工具，比如还有easy_install，这是Python 2.7中的默认包管理工具，现在pip已经基本取代了easy_install，如果要需要pip在老版本的Python 2.7 中则需要手动安装，在Scripts文件夹内运行cmd命令1easy_install pip 安装好pip后如何使用每个版本的Python都有自己的pip工具，如果电脑上只有一个存在一个版本的「Python」时，可以直接使用pip1pip install &lt;包名&gt; 但如果同时存在多个版本的Python，使用pip命令时就需要指明Python的版本，比如要给Python 3下载导入模块则需要「Python 3」的pip：1py -3 -m pip install &lt;包名&gt; pip的常用命令 列出已经安装的包，列出所有的包是pip list 1pip freeze 在线安装包： 1pip install &lt;包名&gt; 本地安装包 1pip install &lt;目录&gt;/&lt;文件名&gt; 卸载包 1pip uninstall &lt;包名&gt; 升级包 1pip install -U &lt;包名&gt; pip常用命令 更换pypi镜像国内pypi镜像 豆瓣：https://pypi.douban.com/simple 中国科学技术大学：https://mirrors.ustc.edu.cn/pypi/web/simple/ 清华大学TUNA： https://pypi.tuna.tsinghua.edu.cn/simple https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/指定单次安装源12# pip install &lt;包名&gt; -i &lt;pypi源地址&gt;pip install &lt;包名&gt; https://pypi.tuna.tsinghua.edu.cn/simple/ 指定全局安装源 在unix和macos，配置文件为：$HOME/.pip/pip.conf 在windows上，配置文件为：%APPDATA%\pip\pip.ini 打开CMD，输入 echo %APPDATA% 的路径为C:\Users\Lemmo\AppData\Roaming 先打开%APPDATA%文件夹后，打开pip文件夹，如果没有则新建一个命名为pip的文件夹，然后创建文件pip.ini，打开文件输入下面的内容后保存 1234[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cn 使用pip安装的module的路径我的Python 2.7是安装在D盘的，这些module路径就是：1D:\Program Files\Python 2.7\Lib\site-packages Python 包管理工具解惑]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pyhton</tag>
        <tag>package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2Fpost%2FSingleton-Pattern-With-Csharp.html</url>
    <content type="text"><![CDATA[一、单例模式介绍“单例”字面意思上理解为——一个类只有一个实例，所以单例模式也就是保证一个类只有一个实例的一种实现方法罢了 [test][1] (设计模式其实就是帮助我们解决实际开发过程中的方法, 该方法是为了降低对象之间的耦合度,然而解决方法有很多种,所以前人就总结了一些常用的解决方法为书籍,从而把这本书就称为设计模式) 官方定义：确保一个类只有一个实例,并提供一个全局访问点。 二、为什么会有单例模式为什么要有单例模式的？它在什么情况下使用的？从单例模式的定义中我们可以看出——单例模式的使用自然是当我们的系统中某个对象只需要一个实例的情况， 例如:操作系统中只能有一个任务管理器,操作文件时,同一时间内只允许一个实例对其操作等,既然现实生活中有这样的应用场景,自然在软件设计领域必须有这样的解决方案了(因为软件设计也是现实生活中的抽象)，所以也就有了单例模式了。 三、Mono子类C#脚本单例 定义一个当前类的公开，静态，当前类类型返回值的一个字段； 1public static Master Instance; //一个名为Master的类 在Awake 事件方法中完成该字段的赋值。 1234void Awake()&#123; Instance = this;&#125; 在其他类中使用单例 1Master.Instance.字段/方法; 四、非Mono 子类C#脚本单例 定义一个当前类的私有，静态，当前类类型返回值的字段； 1private static ClassNmae instance; 创建一个无参私有构造方法 1private ClassNmae() &#123; &#125; 创建一个公开，静态，用于封装字段的属性；在该属性内实现单例，（或者可以创建公开的、静态的方法） 1234567891011public static ClassNmae Instance &#123; get &#123; if (instance == null) &#123; instance = new ClassNmae(); &#125; return instance; &#125; &#125; 在其他类中使用单例]]></content>
      <tags>
        <tag>Csharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2Fpost%2Flambda-expression.html</url>
    <content type="text"><![CDATA[1. Lambda表达式概念官方概念 Lambda 表达式是一种可用于创建 委托 或 表达式目录树 类型的 匿名函数 。 通过使用 lambda 表达式，可以写入可作为参数传递或作为函数调用值返回的本地函数。 Lambda 表达式，是一种代码的语法格式； Lambda 表达式是对匿名方法语法格式的进一步简化； Lambda 表达式可以理解成是匿名方法的升级版。 【方法的三种表现形式】普通方法–&gt; 匿名方法–&gt; Lambda 表达式越往后越抽象，越往后理解成本也就越高。 2. Lambda表达式的语法 语法格式 委托类型变量= （[参数列表]）=&gt; { 方法体; }; 语法格式分析 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public delegate void ShowDelegate(); //无参.public delegate void NameDelegate(string name); //有参.public class LambdaTest : MonoBehaviour &#123; public ShowDelegate showDel; public NameDelegate nameDel; void Start () &#123; showDel = Hello; showDel += delegate() &#123; Debug.Log("MKCODE"); &#125;; showDel += () =&gt; &#123; Debug.Log("擅码网"); &#125;; //语法分析1 showDel(); //-----------------Lambda语法分析----------------------- nameDel = (string name) =&gt; &#123; Debug.Log("我的名字是:" + name); &#125;; nameDel += (string name) =&gt; &#123; Debug.Log("My Name Is" + name); &#125;; nameDel += name =&gt; &#123; Debug.Log("你是:" + name); &#125;; //语法分析2 nameDel += info =&gt; Debug.Log("Hello:" + info); //语法分析3 nameDel("LKK"); &#125; private void Hello()&#123; Debug.Log("Monkey"); &#125;&#125; =&gt; 是Lambda 表达式特有符号，读音是：goes to 如果没有参数列表，（）也不能省略，如：（）=&gt; 如果参数列表中只有一个参数，（）可以省略 如果方法体内只有一句代码，可以省略代码块符号，也就是不用写{ }]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2Fpost%2Flambda-expression.html</url>
    <content type="text"><![CDATA[1. Lambda表达式概念官方概念 Lambda 表达式是一种可用于创建 委托 或 表达式目录树 类型的 匿名函数 。 通过使用 lambda 表达式，可以写入可作为参数传递或作为函数调用值返回的本地函数。 Lambda 表达式，是一种代码的语法格式； Lambda 表达式是对匿名方法语法格式的进一步简化； Lambda 表达式可以理解成是匿名方法的升级版。 【方法的三种表现形式】普通方法–&gt; 匿名方法–&gt; Lambda 表达式越往后越抽象，越往后理解成本也就越高。 2. Lambda表达式的语法 语法格式 委托类型变量= （[参数列表]）=&gt; { 方法体; }; 语法格式分析 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public delegate void ShowDelegate(); //无参.public delegate void NameDelegate(string name); //有参.public class LambdaTest : MonoBehaviour &#123; public ShowDelegate showDel; public NameDelegate nameDel; void Start () &#123; showDel = Hello; showDel += delegate() &#123; Debug.Log("MKCODE"); &#125;; showDel += () =&gt; &#123; Debug.Log("擅码网"); &#125;; //语法分析1 showDel(); //-----------------Lambda语法分析----------------------- nameDel = (string name) =&gt; &#123; Debug.Log("我的名字是:" + name); &#125;; nameDel += (string name) =&gt; &#123; Debug.Log("My Name Is" + name); &#125;; nameDel += name =&gt; &#123; Debug.Log("你是:" + name); &#125;; //语法分析2 nameDel += info =&gt; Debug.Log("Hello:" + info); //语法分析3 nameDel("LKK"); &#125; private void Hello()&#123; Debug.Log("Monkey"); &#125;&#125; =&gt; 是Lambda 表达式特有符号，读音是：goes to 如果没有参数列表，（）也不能省略，如：（）=&gt; 如果参数列表中只有一个参数，（）可以省略 如果方法体内只有一句代码，可以省略代码块符号，也就是不用写{ }]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插件记录]]></title>
    <url>%2Fpost%2Fhexo-plug-in-collection.html</url>
    <content type="text"><![CDATA[记录一些常用的Hexo插件 NexT官方集成插件介绍：https://theme-next.iissnan.com/third-party-services.html 本地搜索：Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 采坑注意：：在Next的主题配置文件中已经存在了local_search的语句了，不要重复添加，否则会报错。只需要搜索到相关位置，将false更改为true即可。搜索效果如下： 图片预览插件：FancyBoxHexo-Next主题中已经有图片预览的功能了，如果要使用，在主题的配置中文件中把FancyBox:False改为true。但是不知道什么原因，我开启之后无法打开网站。考虑到可能是没有下载FancyBox这个插件的原因。FancyBox有两个版本，FancyBox2和FancyBox3，一般来说v2版本就够用了。 下面是安装插件的步骤（参考fancybox的github地址）） 转到Next主题的目录 1$ cd themes/next 安装FancyBox到Source/lib路径 1git clone https://github.com/theme-next/theme-next-fancybox source/lib/fancybox 在NexT的_config.yml中开启 1fancybox: true 更新 12$ cd themes/next/source/lib/fancybox$ git pull 添加评论插件：Valine实现过程： 使用 Valine 给 Hexo 博客添加评论系统 Hexo博客常用插件及用法!]]></content>
      <categories>
        <category>默认</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题显示摘要]]></title>
    <url>%2Fpost%2Fhexo-next-show-summary.html</url>
    <content type="text"><![CDATA[刚创建好的网站，把几篇以前写的MarkDown文件放在_Post文件夹中，但是打开网站一下，发现在页面中每篇文章都全部显示了，翻看起来不方便。如何解决这个问题. 官方提供了三个解决办法! 在文章中使用手动截断的方法，截断的语句是&lt;!-- more --&gt; 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在主题配置文件中添加，默认截取的长度为 150字符，可以根据需要自行设定：123auto_excerpt: enable: true length: 150 文章模版1234567891011---title: git的基本使用date: 2017-01-24categories:- cate1tags: - tag1---&lt;img src="/img/git.png" width = "900" height = "600" alt="git" align=center /&gt;摘要内容......&lt;!-- more --&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo本地建站]]></title>
    <url>%2Fpost%2Fbuild-hexo-blog.html</url>
    <content type="text"><![CDATA[整理总结一下如何在本地安装Hexo，因为本人的电脑是Windows系统，所以以下都是在Windows环境下进行的。 安装前提 GIt Node.Js 1. 安装Git 下载Git：Git官网 安装Git 2. 安装Node.js 直接下载Node.Js的安装包 安装并Add 到Path（自动选择了） 安装Hexo 打开Node.js Command Prompt 运行命令1$ cd d:/hexo #要安装的Hexo的路径 安装hexo的命令 1$ npm install hexo-cli -g 在Blog的目录下初始化 hexo博客，名字可以是任意取 1$ hexo init blog #安装landscape的速度的比较慢 进入博客根目录，并且安装相关插件依赖等 12$ cd blog$ npm install 运行hexo的几个名字，查看效果 12hexo g #生成静态文件，汇总当前目录下生成一个新的叫做public的文件夹hexo s #启动本地的Web服务，启动完成后，可以在地址栏输入「http://127.0.0.1:4000/」查看 运行之后的效果 hexo的官方文档 如何安装主题Hexo中很有很多不同类型的主题： 一些参考 NexT.Mist：示例网站 Next官方使用文档! pure：示例网站 下载主题1git clone https://github.com/iissnan/hexo-theme-next.git themes/next themes/next为下载主题的路径 启动主题修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为next(网站应该会启动themes下的next主题) 更新12git g #生成git s #启动本地服务器]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文件目录]]></title>
    <url>%2Fpost%2Fhexo-basic.html</url>
    <content type="text"><![CDATA[刚接触到Hexo，已经被Hexo的简洁性和部署网站的便捷性所惊叹到了，但是Hexo的一些概念在大脑中还不是很清晰，在网上也没有找到一篇特别好的文章来介绍总结。因此本文作为个人使用Hexo认识的比较重要概念的的一些总结。 创建好Hexo后的路径树12345678910111213.├── _config.yml├── package.json|── public├── scaffolds├── source| ├── _drafts| └── _posts| ├── categories| └── tags└── themes |_ next(主题的名字) |_config.yml config.yml配置文件，采用yml的格式 root目录下的_config.yml:站点配置文件 应用的某个主题（如NexT）下的_config.yml:主题配置文件 public文件夹这个文件夹存放的是当我们使用命令hexo g命令后，自动生成的一些html文件, 这些文件都是要上传到远程服务器中。 source文件夹 _posts：保存markdown的源文件 _categories：使用命令hexo new page categories创建分类分页自动生成的文件夹； _tags：同上，这里创建标签分页； 如何创建分页!]]></content>
      <categories>
        <category>Computer skills</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
</search>
