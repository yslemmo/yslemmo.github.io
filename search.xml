<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「政治哲学」读书笔记]]></title>
    <url>%2Fpost%2FPolitical-Philosophy.html</url>
    <content type="text"><![CDATA[Title 牛津大学哲学通识课：政治哲学 Author [英] 乔纳森·沃尔夫（Jonathan Wolff） Edition 中信出版社 Release Date 2019-07 ISBN 9787521704419 点评 这是每个人应该接受的公民教育，阅读完后如何没能记住任何东西也无所谓至少在阅读的过程中思考了，思考那些我们不熟悉的事物，反思那些我们习以为常的东西。 导论 洛克将政治权力界定为“一种制定法律的权利，这些法律可以规定死刑，从而也可以规定所有更轻的惩罚” 政治哲学家的任务之一就在于确定自主性与权威之间恰当的平衡，或者换句话说，确定政治权力的恰当范围与分配。 政治哲学是一门规范性学科，意思就是说，它试图建立规范（规则或理想的标准）。 我们所有人都有一定的发言权，就算不是通过投票来发言，也可以通过争论与讨论来让别人知道我们的观点，无论是在公共场合，还是以某种“地下”的方式。 霍布斯 布斯观点的实质就是认为，在没有政府的情况下，人性不可避免地会把我们带向严重的冲突。 霍布斯看到了自然状态下发动攻击的三条主要理由：为了利益（gain），为了安全（先发制人防范侵犯者），以及为了荣誉（glory）或名声。 洛克 洛克主张，我们在自然状态下有一种显而易见的义务，就是不要伤害他人（除非是出于自我防卫等有限的目的），我们甚至还有义务帮助他人，如果这样做对我们自己没有损害的话。 洛克认识到，我们所有人都有一种惩罚违法者的自然权利 。洛克看到，自然状态首要的缺陷在于执行正义 卢梭 卢梭赋予了人两种驱动力量，即自我保存和同情，而这两种力量很有可能发生冲突 消费主义不正是如此吗？我们变得依赖于我们最初视为奢侈品的东西。随着新鲜感的消失，拥有它们只给我们带来很少快乐，或者甚至根本就没有快乐，而失去它们将是灾难性的，即便我们曾经没有它们也过得很好。 第二章 证成国家 社会幸福总量意味是否意味着，为了达到实现某项能促成多数人利益的目标，牺牲少部分的利益是可取的？最粗糙的功利主义理论说，我们应该以社会中幸福总量的最大化为目标。 最粗糙的功利主义理论说，我们应该以社会中幸福总量的最大化为目标。 国家 国家是政治实体，它可能有也可能没有一个单一的民族身份（national identity） 国家在一定领土范围内垄断了合法的（legitimate）武力 证成的目标 通常认为，“证成国家”的意思就是要表明，存在着服从法律的普遍义务。 社会契约 事实上，所有主要的社会契约论者——霍布斯、洛克与卢梭——都以不同的方式依赖以默示同意为基础的论证。这里，核心的思想是，通过默默地享受国家的保护，你就是在对国家表达默示的同意 假想契约的方法可以看作一种让我们意识到自己真实想法的方式。通过反思自然状态下我会如何行动——如果可以，我会立刻奔向政治社会——我意识到我确实是同意国家的。其要义不是说，经历了一场思想实验后，我才开始第一次表示同意。这个观点的意思是，经历这一过程后，我开始意识到我一直以来都是同意的。根据这种解释，假想契约论证的目的就是揭示倾向性的同意，即到此为止尚未表达出来的一种同意态度。 “哲学无政府主义者”建议我们对国家与警察的行为采取一种高度批判性的立场。有时他们的行动有道德权威，但是当他们的行动没有道德权威时，我们就有权利不服从、阻挠或者忽视他们。 负责任的公民不应该盲目地遵循法律，而应该始终在法律是否正当的问题上运用他或她自己的私人判断。 这种“妥协”也可能是最优解。在合理范围内有一套共同的法律，要比任何人对最好的法律应该是什么这个问题做出的私人判断重要得多。 功利主义 功利主义存在的问题在于「个体的差异性」与「对幸福的衡量」难以量化（这是人性）功利主义要求，与同时可以做出的其他行为相比，你应该采取能够在世界上带来更多幸福（或更少不幸）的那个行为。 公平原则 罗伯特·诺齐克在《无政府、国家与乌托邦》（1974）一书中主张，没有主动要求的利益不能创设任何回报的义务。 第三章 谁应当统治？ 民主理论内部的张力之一存在于两种民主观念之间，一种观念视民主为一种奉行“多数派统治”（majority rule）的制度，而另一种观念则认为民主要“考虑个人”。 反民主的柏拉图 很有意思的观点业余爱好使一个人能够丰富并检验自己的体能与智能，发展其自我价值感。而这种价值并不依赖于可以制作出的产品的价值。 业余爱好使一个人能够丰富并检验自己的体能与智能，发展其自我价值感。而这种价值并不依赖于可以制作出的产品的价值。 卢梭与公意 通识教育的意义柏拉图主张，统治需要一种专门的训练或教育。卢梭并不怀疑这一点，但是他否认应该只对少数人进行这种训练。如果每个人都获得了恰当的技能，并作为“主权者”（卢梭用这个术语来指拥有针对他们自己的权威并以集体的方式行动的公民群体）的一部分承担一种积极的，也就是民主的角色，这要好得多。因此，一个民主的国家应该高度重视公民教育。 柏拉图主张，统治需要一种专门的训练或教育。卢梭并不怀疑这一点，但是他否认应该只对少数人进行这种训练。如果每个人都获得了恰当的技能，并作为“主权者”（卢梭用这个术语来指拥有针对他们自己的权威并以集体的方式行动的公民群体）的一部分承担一种积极的，也就是民主的角色，这要好得多。因此，一个民主的国家应该高度重视公民教育。 那么制定法律得是人民，他们对某项提议对与错，该与不该的看法，这样下的投票是是基于“公意”，即普遍利益而非个人利益。柏拉图的哲学家国王与卢梭的选举贵族制之间的关键差异就在于，卢梭的统治者并没有权力制定法律。 柏拉图的哲学家国王与卢梭的选举贵族制之间的关键差异就在于，卢梭的统治者并没有权力制定法律。 依据公意而行动，公意即为群体中多数派的决定。卢梭所持的自由观是后来以赛亚·伯林所谓的“积极”自由观。我们将在第四章更详细地考察这个观念，不过这种自由观的基本立场是，自由不仅关乎能够遵循自己的欲望且不受他人约束（一种“消极的”观念），它还要求做出某些行为。 卢梭所持的自由观是后来以赛亚·伯林所谓的“积极”自由观。我们将在第四章更详细地考察这个观念，不过这种自由观的基本立场是，自由不仅关乎能够遵循自己的欲望且不受他人约束（一种“消极的”观念），它还要求做出某些行为。 代议制民主 在穆勒看来，政府的目的有两个方面：让公民得到“提高”，以及管理公共事务。 公民教育最重要的手段就是参与公共事务 第四章 自由的地位 这里的人指的是心智成熟、受过基本教育的社会中的人。穆勒的自由原则（本章开篇引用过）宣称，只有当一个人有可能会伤害到另一个人时，你才能限制其行动自由而不至于不正当。 穆勒的自由原则（本章开篇引用过）宣称，只有当一个人有可能会伤害到另一个人时，你才能限制其行动自由而不至于不正当。 穆勒主张，无论有争议的观点是对还是错，抑或既有对的也有错的，拒绝让其发声对我们绝没有任何好处。如果我们压制一个正确的观点（或一个部分正确的观点），我们就失去了以谬误（整个谬误或部分谬误）换真理的机会。而如果我们压制一个错误的观点，我们就以一种不同的方式有所失：我们失去了一个质疑、再思考并有可能重新肯定我们正确观点的机会。因此，压制并不能给我们带来任何好处，无论所压制的观点是不是真理。 我们对一个观点确定无疑与这个观点是确定无疑的之间仍然有很大的距离。 我们很难确定新旧观点究竟哪个是真理（正确的） 新观点是正确时，不允许讨论则使我们失去真理。 新观点是错误的，不允许讨论、去辩证会使之前认为真理失去活性，变成教条，甚至可能让错误的观点被人盲目认同。 大部分情况是两个观点都部分正确，不允许讨论失去了多样性。真理最终要想显现出来，唯一的办法就是允许争论的各方充分而自由地讨论。因此，穆勒得出结论说，在所有情形下，人类都会因为表达与当前正统观念相反的观点而受益，因而绝没有任何理由支持审查制度。 真理最终要想显现出来，唯一的办法就是允许争论的各方充分而自由地讨论。因此，穆勒得出结论说，在所有情形下，人类都会因为表达与当前正统观念相反的观点而受益，因而绝没有任何理由支持审查制度。 证成自由原则 穆勒试图捍卫一种权利观，根据这种观点，权利既不是自然的或根本性的，也不是对国家法律所规定的权利的简单重复，而是从功利主义理论推出来的。 根据穆勒的看法，要想实现最大幸福，我们可以赋予人们一个私人领域，这个领域由“以权利为基础的利益”构成，不允许受到任何干涉，与此同时，我们还要允许一个可以受到干涉的公共领域存在，但这种干涉只能出于功利主义的理由而进行。 穆勒愿意承认，自由并非总是带来“进步”。但是他强调，“进步唯一可靠和恒久的源泉是自由”。￼与其他可能的策略相比，提升自由为人类幸福做出的贡献要多得多。 正如只要人类未臻于完善，存在着不同意见就是有益的，同样，存在着不同的生活试验也是有益的；各种品格只要不伤及他人就应该给予其自由发展的空间；不同生活方式的价值应该通过实践去证实。……这是构成个性与社会进步的主要因素。 穆勒假设人类是可以进步的，能够从经验中学习。没有这种能力，则没有自由可言。进步是穆勒学说的基石。 进步是穆勒学说的基石。 穆勒主张，我们应该自由地从事商业竞争，但是不能未经他人同意而自由地使用他人的财产。他的立场允许我们在给予自由极大尊重的同时，又为自由设定限制。 自由主义的问题 社群主义者说，自由主义把人设想为孤立的个人，他在自己受保护的狭小空间里以他们自己的方式追求自己的利益。自由主义的个人认为自己与他们所属社会的习俗、文化、传统和惯例没有任何特别的关系。社群主义者主张，我们是十足的社会动物，我们的身份（identities）、自我理解与我们所处的共同体密切相关。如果脱离了我们具体的、地方性的社会环境，不再有所坚持、有所忠诚，严格地说，我们就会成为另外一种人。 消极自由与积极自由之间的区分有时被表述为“免于……的自由”（freedom from）与“去做……的自由”（freedom to）之间的区分。根据这种解释，消极自由就是免于约束的自由，积极自由就是去行动的自由 结论 穆勒自己对自由的辩护在很大程度上依赖于人类能够取得道德进步这种观点。 马克思的学说不太可能鼓动从首都以外的地方来的富裕的法律系学生，但是穆勒关于言论自由和自由的那些观点就完全不同了。 财产与市场 我们对自然的占取要想成为正当的，就必须受到两个条件的限制，这两个条件被称为“洛克条件”（Lockean provisos）：我们一定不能占取太多，以至于我们使用不完（不浪费条件）；我们必须给他人留下“足够多且同样好”的东西。这两个条件不仅适用于从生存角度对财产权的论证，而且也适用于洛克对财产权的所有论证。 市场的两个关键特征：它发出信息，并让人们有动力通过改变生产方式来对该信息做出反应。 计划经济必然要限制个人的行为。 罗尔斯的正义理论 罗尔斯认为，人们对正义的看法通常带有偏见，而这种偏见在一定程度上是由他们自己的特殊利益造成的。 休谟指出，在某些条件下，正义观念似乎并不适用。如果我们的条件极度匮乏，连每个人的生存都无法确保，那么我们批评某人的行为不正义看上去就很荒唐。 更喜欢小中取大原则，是因为其他理性选择原则的结果都要看运气，而鉴于这是一个一次性且不可反悔的选择，这样做太冒险了，在这种情况下，选择不可能是理性的。 罗尔斯及其批评者 即时性正义理论认为，你可以通过看一种情况的结构来判断这种情况是否正义。 但是如果你认为我们需要更多地了解人们是如何获得其资源的，或者更多地了解资源分配的依据，你信奉的就是一种历史性理论。 对罗尔斯来说，自由原则优先于差别原则。因此，如果坚持差别原则真的限制了自由，那么罗尔斯自己的观点似乎就迫使他放弃差别原则。因此诺齐克主张，对自由的恰当尊重与强制实施任何模式化的财产分配都是不相容的。 诺齐克说，差别原则就像所有模式化的正义观一样，唯有不断地干预人们的生活，才能得到维系。 罗尔斯会辩称，诺齐克关于如何维系模式的看法是很奇怪的。抽象地说，确实，要用差别原则来规范社会，就有必要禁止某些交易，并强制实施财产再分配。但是我们可以通过我们熟知的税收与福利制度，以一种完全文明的非侵犯性方式进行财产再分配。 第六章 每个人的正义？每个地方的正义？ 整个社会进步史就是一系列的转变。由于这些转变，一种习俗或制度变成了另一种习俗或制度，它们曾经被认为是社会存在所必需的，现在已经逐渐成了人人唾弃的不正义与残暴。奴隶和自由人、贵族与农奴、古罗马贵族与平民之间的区分正是如此，充满肤色、种族与性别歧视的贵族政治也会如此，而且在一定程度上已经如此。 每个人的正义？ 就算法律没有某种缺陷，社会也仍然可能有那种缺陷。宣布歧视为非法行为，并没有让歧视不再发生。 没有理由认为，承认男女有别就意味着女性更软弱或较为逊色。 承认一个群体有特殊的需要，这本身并不是说他们就更软弱。 生理性别被当作一个纯粹的生物学范畴，而社会性别则是一个社会性范畴。社会性别角色在不同社会的差异可能很随意。我们可以举一个看上去无关紧要的例子。 社会分化不仅表现为种族差异，宗教、族群、民族以及社会阶层也产生了社会的分界线。 在当今世界，我们所面临的一个核心问题就是：人们被视为不同种族、宗教、族群的成员，他们如何能够作为平等的人生活在一起？ 在世界的某些地方，对于具有严重行动障碍的人来说，生活就是一种折磨，但是在另一些地方，他们的生活与“正常人”的生活并没有太大的差异。至少在这种意义上，一个身心障碍者的生活到底有多艰难，取决于个人能力之外的社会性与物质性因素。 正如在铲平古建筑并修建新建筑之前我们应该非常谨慎一样，在撕碎更古老的道德传统之前，我们也应该非常谨慎。 压迫并非总是，甚至也并非经常是蓄意的阴谋。这就有点像空气污染，它完全是由很多单个的微不足道的行为造成的。 杜波依斯认为，支配性群体——无论是哪一个支配性群体——构建了一套神话，让他们觉得自己的支配性地位是应得的。 结束语 反思问题是一回事，解决问题则是另一回事。 在政治哲学中并没有最终的结论。]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>政治</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「有所不为的反抗者」读书笔记]]></title>
    <url>%2Fpost%2Fyou-suo-bu-wei-de-fan-kang-zhe.html</url>
    <content type="text"><![CDATA[Title 有所不为的反叛者 Author 罗新 Edition 上海三联书店 Release Date 2019-05 ISBN 9787542666468 摘录笔记历史学家的美德 历史是对过去的讲述，无比巨大、混沌一团的过去中被赋予了秩序和意义并且被讲述出来的那很小很小的一部分，才是我们所说的历史。 历史学家有三大美德：批判、怀疑和想象力。 历史并非无中生有，而是有中生有，是从已有的历史当中生产出新的历史来。 历史会影响我们的未来，但是真正决定未来的，是我们的现实，是我们当前的立场、意志和选择，以及我们的行动。 有所不为的反叛者 不是一首浪漫曲，不是英雄史诗，其中充满了征服、反抗、血泪和压迫，充满了人类历史上许多近似情形下已为我们所知的那种人群对人群、体制对个体、强力对弱者所制造的痛苦。 当我们反感、反对乃至痛恨此刻正在发生着的历史时，不要忘记这个时代是慢慢形成的，不是一两天突然冒出来的。 今天我们必须知道可以做什么，不可以做什么。不可以做的，坚决不做。作为一个rebel，一个反叛者，有所不为是一条原则。 一切史料都是史学 传统叙述中，关于那些时代的哲学和历史充斥着神话与传说，考察这些由来已久的论述，会发现其构建基础都是经不起科学方法检验的史料。 一切可借以认识过去的都是史料（包括传世文献和出土文献，也包括文字材料和物质文化），我们视之为史料而非直接等同于历史； 今天的历史学家应该为所有那些被遗忘的、失去了声音的人发出声音，去探究现有的在竞争中胜出的历史叙述是如何形成的。当然这主要是年轻的、未来的历史学家们的责任。现有的历史叙述充满了神话和陷阱，因为历史是被说出来的，被制造出来的。我们要知道，历史越是单一、纯粹、清晰，越是危险，被隐藏、被改写、被遗忘的就越多。我们要拂去竞争的烟尘理解过去，展示历史本来的多种可能。 我们必须知道，我们的过去有非常丰富的可能，而不是如今天呈现在我们面前、特别是呈现在某些叙述中的那样单一和绝对。 遗忘的竞争 对于生命来说，遗忘比记忆更重要，或者说，正是遗忘塑造了记忆，理解记忆的关键正在于理解遗忘。 制造遗忘是社会用以构建并维持集体记忆的手段之一。 历史叙述的竞争主要体现为政治权力要排斥一切不利于或无助于政治权力的历史叙述，从而使服务于政治权力的历史叙述获得独尊地位。 遗忘研究已经指出，要实现遗忘，不仅可以通过缄默，而且可以通过喧哗。全社会对一个事件的缄默不语固然会造成该事件彻底从记忆中消失，而全社会热议与该事件相关的其他事项却完全不提该事件本身，同样会造成该事件的遗失。 历史是社会健康的基本要素，其功能是通过讲述过去而帮助现在。 不确定的历史因应现实的需求而改变，历史编纂就成为一项永不止息的政治作业，因而历史论述本身也具有了命中注定的不确定性。 语言不只是表意的交流符号，任何语言都内置有整套的文化价值与历史传统，跨语言通常也意味着跨文化和跨历史 中国历史上各个时期，都有相当数量的非华夏人群加入华夏社会，这些人群都要通过不同途径实现其文化转型，最终转换其历史叙述，使得他们的社会面貌与其他华夏人群没有差别。这个过程中，集团和个体都积极进行了遗忘。 走出民族主义史学 “人们把本世纪的两次世界大战都归罪于民族主义，可是民族主义不一定就意味着军国主义。而且，民族——国家正是自由（liberty）得以诞生的实验室。” 民族主义者痴迷于历史书写的原因，就是他们要给自己创造出一个脱离真实和现实的幻境，在这个幻境里，民族主义者可以获得胜利、优越与复仇的满足感，或是找到足以使“本民族”同仇敌忾的被欺辱的共同经历。 民族主义史学都会把现有国土说成自古以来的合法领土，还会强调历史上失去的领土，把领土争议中的他国说成理亏的一方。对历史上国家之间的复杂关系，民族主义史学总是把本民族描绘成和平主义者、助人为乐者、输出文化和财富者，并刻意强调受侵略、受凌辱的经历。民族主义史学不仅要激起读者对本民族（本国）的骄傲，还要激起读者对他民族（他国）的隔膜、敌意，甚至仇恨。 民族主义固然是建立民族——国家的利器，但这把利器其实是双刃剑或多刃剑。 中华民族为了规避经典民族概念所内含的道德、法律和政治风险，20世纪的民族——国家偏向于以主权国家为单位重建民族，即所谓“国族” 为了规避经典民族概念所内含的道德、法律和政治风险，20世纪的民族——国家偏向于以主权国家为单位重建民族，即所谓“国族” 无论是身处、生活在哪一个民族——国家，我们都事实上共享同一个历史，而且共享同一个未来。这个认识要求我们所讲的历史，固然是为某一个人群、某一个地区、某一个国家的，但也要超越这个具体的人群、地区和国家，最终可以成为人类整体历史的一个有机组成部分。 世上本无黄种人——读奇迈可《成为黄种人》 这许多年间，如同周伯通努力忘记《九阴真经》那样，我们逐渐把一团又一团的教育糨糊从脑子里清除出去 色彩不单单是对物理现象的客观描述，还带着各文化传统所赋予的价值与情感。 人类基因多样性主要存在于个体之间，比较而言，地域与族群间的差异反倒无关紧要，而且在种族与种族之间、族群与族群之间，根本不可能描画出有科学依据的分界线。 双螺旋的低语 关于人群分类，20世纪有两个影响很大的学派：一个是英美学派，强调主观认同；一个是德苏学派，强调客观标准，包括物质文化与生物学特征。 忽必烈的历史挑战——读杉山正明《忽必烈的挑战》 最伟大的蒙古英雄没有第二人。不仅蒙古人这样看，在世界范围内，成吉思汗不仅足以当作蒙古的代名词，而且，他甚至比蒙古更有名。 著有《忽必烈传》的李治安教授说：“与祖父成吉思汗一样，忽必烈堪称蒙元一代的伟人。……成吉思汗以征服武功震撼世界，忽必烈则以文治著称于天下。忽必烈是成吉思汗继承者中最杰出的政治家。” 中华帝国体制的内外轻重 现行中国断代史体系把1840年前的中国历史（所谓中国古代史）分成两段，唐末以后是一段，先秦到唐末是一段。 点评 不能说这本书是彻底刷新了我的是”史观”，至少也是给我提供了一些有趣、新颖的史观。]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影发展史]]></title>
    <url>%2Fpost%2Fmovie-history.html</url>
    <content type="text"><![CDATA[早期电影（1893~1903） 1826年「摄影技术」的发明使电影的出现成为可能 1878年：英国摄影师「麦布里奇」在旧金山用一字排开的十二台双镜头照相机，拍摄下马匹在运动中的连续影像，这就是“奔马实验”。 1893年：爱迪生的助理「狄克逊」发明了可以拍摄35mm电影短片的摄影机。 每次只能一人观看。 1895年：「卢米埃尔兄弟」在巴黎大咖啡馆创下了电影第一次公开放映的记录。 不局限于在摄影棚里面，而是把摄像机带到室外拍摄，记录日常生活和新闻事件。 作品《火车进站》 1896年：「梅里爱」购买了一台放映机并把它改装成摄影机。 梅里爱师一个魔术师，发明了一些电影特效。早期使用「停机再拍」「多重曝光」「低速摄影」「淡入淡出」等制作技术。 《月球旅行记》是最早的科幻片，最大的特点是使用拥有「多场景情节」，和舞台剧很像。 早期电影的形式与风格都非常简单，通常是一个镜头，一个固定画面，单一剧情，远镜头居多。 经典好莱坞的发展（1908~1927） 1903年，第一个运用叙事和发展拍摄的影片《一个美国消防员的生活》。 1903年，《火车大劫案》是经典美国电影的原型。 1908年，爱迪生与比沃格拉夫公司组建了企业联合组织，命名为电影专利公司，即MPPC，意图控制制片厂，利用垄断收取授权的赚钱。 1910年左右，许多电影公司搬迁到加州，洛杉矶的一个叫好莱坞的小城成为主要聚集地。 这些电影公司为了远离MMPC的控制来到加州。 这里的天气晴朗，全年都可以拍片，地形景观多样，能提供多样的拍摄景观。 发展出了「片厂」结构，制作人负责某部影片的制作，但不负责作品的具体创作。 20世纪前20年代，小厂合并成较大的电影公司，有米高梅（MGM）、福克斯（FOX）、华纳（Warner Bros）、环球（Universal）和派拉蒙。 到20世纪20年代左右，「连续性技巧」已经成为好莱坞导演的标准风格。 连续性技巧是为了构成叙事的连贯与不露痕迹，使观众在无提放的心理状态下观看电影，观众更容易接受电影叙事所给予的时空状态，认同荧幕的运动方向，比如正反打手法、动作的连续性。经典范例如基顿的《我们的好客之道》。 德国表现主义（1919~1926） 一战初期，德国的电影院放映的大都放映的是法国、美国、意大利的电影。为了打击进口片、生产官方政治宣传片，1916年德国政府全面禁止外片进口，而后德国制片公司数量增长很快。 1917年，政府为了宣传战争思想，与德意志银行合作，合并小公司，成为了UFA公司。 同期，一些小公司仍坚持独立制片，其中一个Decla公司的三位设计师加入该公司，他们认为电影必须以「表现主义风格」出现。（表现/主义最早是出现在1910年绘画上的一个前卫运动） 表现主义电影 德国表现主义大部分依靠场面调度，有极度风格化的影像，为了达到表现的目的，形状被用扭曲或夸大的手法处理，演员化浓妆，整个画面的元素皆以图形方式来彼此互动，人物也是构成视觉要素。 典型范例《卡里加利博士的小屋》，另外还有茂瑙的《浮士德》、弗里茨·朗的《大都会》 法国印象主义和超现实主义（1918~1930） 印象主义 叙事形式上呈现主角的内心意识。 印象主义强调个人情感，明显地赋予电影叙事一个心理学的焦点。 为了想到画面的主观性，印象派电影以摄影和剪辑来呈现剧中人物的知觉经验。采用主观镜头、失焦的画面和迂回的摄像机运动来表现主角的感觉。 超现实主义 超现实主义基于一种信仰，相信现实之外，某些被忽略的、特定的结合形式；它们存在梦境之中，并在不受支配的思想中。 超现实主义反对「叙事体」，攻诘因果关系。 在超现实主义的影片中，主角的心理状况根本不存在，影片真正的目的是系统用自由的电影形式，来激发观众潜在心底最深处的冲动。 超现实主义影片拒绝将任何特殊技巧奉为准则，因为那样将“不受支配的思想”理想化。 苏联蒙太奇运动（1924~1930） 俄国十月革命成功后，1918年，苏联国家教育委员会部门开始管制底片的供应，导致私营公司囤积底片并逃到别的国家。 库里肖夫在国家电影艺术学院授课，并开战一系列的剪辑实验 库里肖夫效应：通过「库里肖夫实验」表明：镜头剪辑语言所带来的表演效果，电影情绪不仅仅从单个镜头的内容来反映，而是通过多个画面之间的组合连接来暗示表达的。 创造性景观（人造景观） 经典蒙太奇风格作品导演：爱森斯坦、普多夫金、维尔托夫、亚历山大·杜甫仁科（乌克兰） 1930左右，苏维埃当局鼓励制作简单易懂的影迷，供大众观看，这一浪潮慢慢结束. 声音技术引入后的经典好莱坞电影 在无声电影时期，播放电影时需要让影片发声，需要放置留声机或乐队演奏。 同期声技术、彩色摄影技术的出现。 出现了「音乐片」类型。 《公民凯恩》是这个时期好莱坞经典及变革制作，使用并普及了深焦摄像。 意大利新写实主义（1942~1951） 新写实主义代表着年轻的一代想从意大利电影工业的老朽电影惯例脱颖而出的现象。 战后许多导演开始拍摄揭发当代社会问题为主题的影片，形成了一股写实主义运动的潮流。 战争导致大制片厂炸毁，场面调度只能依赖真实场面，摄影倾向纪录片的粗粝感。 意大利电影事后配音的惯例，使得导演可以在场景中探索种种写实的可能性。 新写实主义倾向于记录真实生切面结构和非限制性叙述，从而使该运动的电影拥有一个和好莱坞电影封闭式结局相反的开发式结尾。 1949后，意大利开始从战争中复苏，政府的审查制度开始限制新写实主义运动。 法国新浪潮（1959~1964） 起于一群年轻作者在《电影手册》上攻击当时的著名的大导演，并攻击当时的法国电影制度，赞同电影的拥有「作者（导演）属性」。 特点： 最明显的创新特质在于它们不羁的外貌，反对棚内摄影。 摄像机运动更大，经常使用横移和推轨镜头。 剧情片内的因果关系松散。 快速切换场景镜头等创新剪辑手法，或是像“跳接”，在整体叙事上制造突兀不连贯效果。 片中的主角缺乏目标。 有开放式的、不明确的结尾 代表影人： 让·吕克·戈达尔 弗朗索瓦·特吕弗：《华式451》《四百击》《野孩子》 新好莱坞与独立制片 60年代中期，随着美国观影人数的下降，大厂拍摄的高预算片亏损，制片开始瞄准针对年轻人的反文化片，出现《教父》、《驱魔人》、《大白鲨》、《第三类接触》、《星球大战》、《出租车司机》、《愤怒的公牛》等一系列卖座电影。 到70年代、80年代、90年代都一直出现新的年轻导演，他们在遵循经典美国电影的基础，采用新式或流行的视觉技巧润饰好莱坞传统的说故事策略。 当代香港电影 20世纪50年代，邵氏兄弟是当时最大的制片厂，以武侠片最成功。 70年代，李小龙的武打动作片引起了全世界的注意。 80年代，传统武侠片开始走下坡，后来武打冒险片，当代警匪片开始流行。 90年代，艺术电影开始壮大，代表有王家卫。 补充资料： 《电影艺术》 CrashCourse电影史]]></content>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「薛兆丰经济学讲义」读书笔记]]></title>
    <url>%2Fpost%2FEconomics-Lecture-Notes.html</url>
    <content type="text"><![CDATA[Title 薛兆丰经济学讲义 Author 薛兆丰 Edition 中信出版社 Release Date 2018-07 ISBN 9787508689586 经济学与我们每一个个体都是息息相关的，即使你不去了解它，只要你生活在现代社会之中，它就会深深地影响着你，因为经济学是以研究陌生人的互动规律为己任。学习经济学知识可以帮助我们理解当下的一系列的经济社会运作的逻辑和规律。它是一种思维方式，让我们可以理性、客观地看待一些社会经济现象。 经济学是一门科学，它是可证伪，可以被验证的，它包含了很多社会运转的规律。经济学又数学是紧密联系中，经济学理论中有大量的数学、模型和方程式。经济学也是一门研究人的行为规律的学科。由于要经济学中包含了人性的因果规律的探索，人性是一个灵活多变的变量，所以经济学的问题往往是复杂的。 经济学关心的是「事与愿违」的现象，而不是「事与愿符」的现象。不是“好人做好事，坏人做坏事”的问题，而是为什么有时好心会办坏事？比如最常见的例子。 最低工资制度，本来是要保护穷人的，但最后穷人的境遇反而更糟了； 同工同酬制度，本来是要保护弱势群体的利益，但最后却损害了他们的利益； 福利制度，本来是让那些没有依靠的人能够找到依靠，但最后这些人的境遇却变得更惨了； 稀缺：经济学的基础产生「稀缺」的两个原因： 我要的东西别人也想要； 人的需求在不断变化、升级。 第一个原因，因为资源总是有限的，而大家都想要（需求），这形成了稀缺。第二个原因，人的欲望总是无法被满足了，人总是追求好的东西（需求），而好的东西（供给）是有限的。稀缺必定导致歧视，因为有稀缺的存在，必定意味着要有所选择，做选择就会区别对待（歧视）。 成本：成本是放弃了的最大代价比如，现在我手上有一项资源，可以是一块地，也可以是一笔资金。我可以把这项资源用于A、B、C、D等若干选择，被选中的那个选项的成本就是“所有放弃了的选项中价值最高的那个”。当你把手中的资源用作某个选项时，也就放弃了其他选项的可能性，所以这个选项的成本是所有选项中能产生的最大收益的那项的收益。 成本是放弃了的最大代价，放弃的东西越多，代价就越高；放弃的东西越少，代价就越少；如果没有放弃，就没有成本。「沉没成本」是已经发生的不可回收的支出，无法回收也就是没办法再放弃了，所以「沉没成本」不是成本。 盈利与亏损从成本的角度来看盈利与亏损，它们都是意外发生的。每当发生意外，我们就重新调整资源的未来估值，而资源使用的成本，就要按照这个新的估值来计算。所以，一旦出现盈利，资源的使用成本就会提高；一旦出现亏损，资源的使用成本就会下降。 产品的价格 成本决定论（与直觉相符，逻辑错误） 产生的价格等于原材料的成本的综合，乘以合理的利润率； 需求决定论（反直觉，与事实相符） 产品的供需关系决定产品的价格，产品的价格又来原材料的价格。 科斯定律在社会利益冲突中（伤害是相互的），哪一方执行解决方案的总成本最小，社会规则倾向于让他成为责任方。——科斯在《社会成本问题》 需求个人估值 阿尔钦的定义，“一个人对一件商品的个人估值，是他为了得到这件商品所愿意支付的其他商品的最高数量” 个人估值是个人的估值，不是集体的估值 是绝对主观的，没有所谓的客观的估值 是以个人的愿望为基础的 价值论 客观价值论能够解释的现象，主观价值论（个人估值）也能解释。 客观价值论不能够解释的现象，主观价值论（个人估值）也能解释。 主观价值论呢更好地指导生产。 边际 边际的概念：边际是由“新增”带来的“新增“。 边际成本：每新增一个单位产品所需要付出的新增成本； 边际收入：每多卖一个产品能够带来的新增收入； 边际产量：每新增一份投入所带来的新增产量； 边际效用：每消耗一个单位的商品所能带来的新增享受。 边际效用递减定律 在单位时间内随着人们消耗的某种商品的数量不断增加，消耗这种商品所能带来的新增享受迟早都会下降。 边际效用和边际成本是一对成对概念，通过追求它们之间的平衡，就能够使总收益最大化。 需求三大定律需求第一定律 当其他情况不变时，只要价格提高，商品的需求量就会减少；价格降到一定程度，需求量就会增加。 需求曲线使永远向下倾斜的，产品的价格很低时，需求量高；价格逐渐上涨，需求量就逐渐减少，当价格上升到一定程度，需求量就萎缩为零。 当价格持续上涨时，需求变为负（虚线），需求也就变成了供给。需求和供给没有黑白之分，取决于市场价格。 需求第二定律 需求对价格的弹性，和价格变化之后流逝的时间长度成正比。也就是说，随着时间的推移，需求对价格的弹性会增加。 需求的价格弹性是指：在经济学中需求的数量随商品价格的变动而变化的弹性。弹性大于1时，指得是奢侈品；弹性小于1时，指的是必需品。它的公式是：$$需求的价格弹性=\frac{需求量的变化比例}{价格的变化比例}=\frac{\Delta Q/Q}{\Delta P/P}$$影响需求弹性的因素有： 替代品得多寡：替代品越多，商品得需求弹性越大。 时间得长短：随着时间的长度增加，商品会愈来愈有弹性。 必需品还是奢侈品：必需品得需求弹性小，奢侈品得需求弹性大。 需求第三定理 每当消费者必须支付一笔附加费的时候，高品质的产品就相对低品质的产品变得便宜了，这笔附加费越高，高品质的产品就变得越便宜。这个定律也叫“好东西运到远方去定律”。 附加成本使精选产品相对价格变低。 附加成本对于交易得双方都是坏事。 价格资源配置 计划经济不可预测 人际效用不可比较，因为每个人对物品有不同的偏好，同步的估值。 数据不可得，在人类社会，很难获取精准的数据（人的能动性） 奖惩很难恰如其分，不能解决奖惩问题，人们就不能即使修正他们对未来的预期，并作出调整。 “人类社会要解决的问题不是怎么让边际平衡的问题，而是发生了新的变化以后，我们应该如何应对的问题。”——哈耶克 与变化相关的知识，是关于谁在什么地方、愿意以什么样的代价、购买什么商品的局部信息。哈耶克把这些局部信息称作“知识”。由于这些知识永远分散在不同人的大脑里，不可能集中，所以如何把这些分散的知识利用起来，从而对时刻不停的变化做出反应，才是人类社会要完成的艰巨任务。 价格的作用 解决「人际效用不可比较」的问题，价格可作为一把共同的尺子。 解决了「数据不可得」的问题，传递了稀缺的信息和数据 价格能指导生产 价值体系能解决奖惩的问题 竞争的逻辑 人面临的一个最基本的约束就是「稀缺」，东西不够，拿该如何分配呢？有很多种竞争规则，如： 暴力（最古老也是最常见的竞争方式） 拼智力（考试） 论资排辈界定产权（中国传统的“长幼尊卑”） 按社会身份分配财产 按劳动时间；随机分配；先到先得分配 按需分配。 价高者得 每一个竞争规则对于不同的人来说都有各自的优势和劣势，而每一种竞争规则都会带来成本。但是按照「价高者得」会引导不同的人从事自己最擅长的工作，积累资金相对容易，造成的无谓损失也是最少的。 「短缺」 短缺不是供应的减少，而是指在商品的价格受到抑制的情况下人们不仅要通过出价的方式去竞争，还需要依靠其他非价格的方式去竞争的一种特殊现象。 「过剩」 同样，过剩不是供给过多，而是商品的价格被人为地抬高，以至卖家必须搭配其他的竞争手段或服务，才能把商品卖出去的现象。过剩是价格被人为拔高的结果。 要解决「过剩」问题，就要限制产量。比如我们常听的”腐朽的资本主义把牛奶倒掉“、还有”巴西烧毁咖啡豆“。 「稀缺」是永恒的，而「短缺」和「过剩」都是价格收到认为干预的解决。价格低（展开价格以外的竞争）出现短缺，价格高（采用价格以外的方式）出现过剩。 价格管制张五常先生，他的重要论文《一种价格管制理论》（1974）首先解释了什么叫价格管制。价格管制跟收税不一样。比方说一间公寓它的市价是100块钱，政府说这100元中，要征收40元的税。那么，其实政府就变成了二房东，房子的主人得60%的房租，40%就柜二房东，我们的政府所有。那这就是收税。 但价格管制不是收税，政府并没有要你的钱。政府说，你这房子的市价是100元，但是还是太高了，这房价不能超过60，那房东就少拿了40元，而这40元政府也并没有拿。政府只是颁布法令，说房租不能超过60元。 价格管制会产生两个重要的后果： 价格管制必然导致价值耗散只要有价格管制，房东得不到那40块钱，这时候他就不能够把房子用到价值最高的用途上去，也就是价值会耗散掉。就是说资源没有被用在刀刃上的时候，它举不那么值钱了。 人是追求损失最小化的动物追求利润的最大化与损失最小化都是人性的特点，因此只要存在资源的损耗，人就会想办法选择能够尽可能挽回最大利益的竞争方式。 权力 权力的定义 产权是一种通过社会强制而实现的、对某种经济物品的多种用途进行选择的权利。（ property right is socially enforced right to select uses of an economic good socially enforced）—— 阿尔钦 权力通过社会强制而实现； 权力是别人授予我们的； 别人愿意来保护我们行使的自由才叫权力。 「能力」和「权力」 能力（might）取决于自己能够占有多少，而权力（right）取决于社会上其他人愿意给你多少。（拓展《你的权力从哪来？》） 产权产权的明确、产权的行使和保护都需要消耗成本。当权力的安排带来的好处够时，就会考虑界定产权。 产权的兴起动力 外部性由于资源有限，一个占有资源时，其他人就没有了。比如大航海时，猎人打猎人数很少。大航海后，动物的皮毛变得更加珍贵了，打猎人变多了，动物的数量越来越少，就产生了「外部性」。 人口聚集交通运输成本持续大幅下降，使得人和货物远距离的旅行和运输成为可能，而这导致的直接后果，就是人和货物的高度集聚。人可以密集地居住在一起，这时人与人之间的各种冲突也就越来越多，于是便产生了对产权，也就是对“排他性权利安排”的需求。 使用权、收益权和转让权 使用权：我们能决定资源怎样使用。「使用权」与「所有权」看似冲突，它们支付指的时在不同条件下的使用权。很多国家，地主持有土地的所有权，而农民有土地的使用权。 收益分配权：一份资产会不断地提供服务，提供服务就会有报酬，无论是产权的暂时拥有者，还是它的永久拥有者，都有权去分配资产得到的收益，这是资产的收益权。 转让权：转让权意味着把一份资产未来永久的、全部的使用权和收益权，一下子批发转让了。一个人，只有当他完全拥有一份资产时，他才能一次性地把一份资产未来每一个时刻的使用权和收益权都转让出去。 产权保护的三大原则 财产原则 一个人想要剥夺别人的产权，只有一个办法，就是向这个人付费，付到他愿意放弃为止。（政府对产权干预一次） 责任原则 当一个人侵害了别人的产权以后，侵害者就要向产权所有者赔偿，但是赔偿的金额不是由所有者确定，而是由第三方确定（政府干预两次，一次确权，二次在发生侵权时，政府来决定赔偿的金额） 采用责任原则的一个核心理由是，采用财产原则来保护产权的成本太高，而伤害已经造成，这时只能由第三方对伤害做一个赔偿定价。 不可转让原则 政府禁止所有权人把他所拥有的资产卖给别人。（政府干预三次，……第三次政府禁止原来的产权所有者出让他的产权） 政府采取不可转让原则的原因有： 避免麻烦（涉及到国家安全，污染的企业；威胁现有的道德观：禁止买卖器官、卖淫等。） 父爱主义（政府觉得自己比个人更了解他们的利益，想像替儿子做决定一样） 自我执行的父爱主义（自己对自己信不过） 公共服务 公用品和私用品的区别 私用品（private goods）的含义是一个人用了之后，别人就不能用。比如一个鸡蛋，一支铅笔。 公用品（public goods）的含义是一个人用的同时不影响别人使用的商品。比如一首歌，一个物理定律。 「竞争性」和「排他性」是公用品和私用品判别维度一个物品，一个人用了之后，别人就不能用了，把这称作“有竞争性”。排他性，是指一件商品在实际使用时，物主能不能很方便地把其他的使用者排除在外。如果能比较方便地做到，就说它有排他性；不方便做到，就说它不具有排他性。 道路是公用品还是私用品，该不该对车辆收道路拥堵费道路是私用品，因为某条道路上有一辆车在行驶（使用）就意味着会少一辆车能够上路。具有竞争性。道路作为典型的商品，征收道路拥堵费有意义： 征收拥堵费会让道路产生排他性的使用权。 征收拥堵费可以刺激道路供给，收取拥堵费后，使用需求低的人就不会来参与竞争，自然就增加了供给。 征收拥堵费可以调节需求。 耐心易耗品和耐用品利息是人类社会最古老的现象之一，它起源于时间，起源于人的耐心。只要与时间有关的现象，都涉及利息。而根据时间的维度，世界上所有的产品、商品、资源，都可以简单地划分为两种：一种叫「易耗品」，一种叫「耐用品」。——费雪《利息理论》 易耗品 一次性能消费完毕的物品叫易耗品，比如一个苹果，一杯牛奶。 耐用品 必须在一个时间段内慢慢发散出来，只有在时间的维度才能体现它的价值。比如人力资源，艺术品。 利率不耐（impatience）是指，因为未来具有不确定性（自然灾害、人为因素），人们总喜欢早一点消费，而不喜欢晚一点消费。 由于人与人之间的不耐程度是不同的，对自己手上的物品的估值不一样，有些人偏好现货，有些人偏好期货（未来），由「不耐」而产生的交易就叫不耐产生交易，现货和期货的比价，就是利率。不耐是利率的基础，未来越是不确定，接受期货的人所要索取的补偿就越大，这时候利率就越高。 利率管制会产生的影响 人们不愿意借钱给别人。 黑社会会应运而生，暗规则保证让人还钱。 人会选用迂回的方法支付利息。 贴现率的概念 贴现率就是未来价值（期值）转换为当前价值（现值）的打折程度。 市场是否有规律 有效市场假说——尤金·珐玛 资产的价格已经反映了关于资产的内在价值的所有可得信息。 「有效市场假说」说的是市场没有泡沫，资产价格的波动非常有效，已经准确反映了所有可得的信息。 市场泡沐沦——罗伯特·希勒人是非理性的，人们的反应有时不足，有时又过激，而导致出现了一次次的股市泡沫。 保险与期货 人的3个风险偏好，风险厌恶、风险偏好与风险中性，举个例子，我愿意给你10元钱，但有不同的给法。 第一种给法，直接给你10元，没有任何风险；（属于风险厌恶） 第二种给法，给你10％的机会拿到100元，当然也有90％的可能一分钱都拿不到。（属于风险偏好） 第三种是哪一种都无所谓 保险的原理买保险的人是风险厌恶型的人，不喜欢变化。他们想要一种服务，无论未来如何，自己的收入是一样的。 保险成立的三个前提 事件的概率性：不能是确定的，有一定的发生几率。 概率的不相关性：投保的风险不能是全局性的，不能涉及到所有人。 概率的独立性：投保人自己不能控制风险的概率。 保险运作的原理 细分：将投保人细分可以把不同的人的风险做精确的划分，可以降低细分组里成员“占便宜”的现象，从而降低保费。 加总：在一个细分组里增加成员的数量，根据「大数定律」的原理，同样风险的人越多，他们之间产生风险的数学期望就月准确，离差越小，也能降低保费。 失业保险和养老保险都不是保险失业保险不是随机的事件，也不是独立的事件。而养老保险是一种社会补贴，它知识一个财产转移，把年轻人交的钱给老年人。 期货期货的全称是期货合约 其中一方被称为期货合约的买方，他答应在未来规定的时间内，按照规定的价格向期货合约的卖方购买规定数量的某种产品。 期货的本质是分配风险，风险是不可能彻底避免了，有的人喜欢风险，让他们承担风险（可能更高的收益），有的人不喜欢风险， 让他们少承担风险（付出一定的代价），这种重新分配风险让两方都各的其所。 期货市场鼓励人们对未来做更准确的预测，对期货市场的预测越准确，又有更多的机会赚钱。 供应比较优势大卫·李嘉图在《政治经济学及赋税原理》 在一个社会里，每个个体如果把有限的资源，包括时间和精力，只用来生产对他们来说机会成本比较低的那些产品，然后跟别人进行交换，这样整个社会产品的总价值就能达到最大，而且每一个个体的境遇都能得到改善，而不论他们的绝对生产能力是高还是低。 可以是个人，可以是家庭，地区和国家。 每个个体的 时间和资源都是有限的。 比较优势可以自己和自己做比较。 每个个体都生产自己具有比较优势的产品，这样的成本最小，整个社会总产量会达到最大。 受价者和觅价者 完全竞争状态与受价者完全竞争状态：市场里有数不清的买家和卖家，交易的都是同一种商品，任何一位买家或者卖家都不能通过控制买卖量来影响价格，因为他个人的买卖量跟整个市场的买卖量相比是微不足道的。与此同时，任何一位买家或者卖家都可以随时进出市场，整个市场的交易费用很低。在这种状态下，所有卖家只能被动得接受市场得价格。 不完全竞争状态与觅价者与完全竞争状态相对的一种状态，卖家对价格和产量具有一定的操控权。当价格提高时，需求量会降低，当价格过低时，收益和利润也会受影响，为了追求利润的最大化，卖家就寻求一个价格，并调整产量，这种卖家就是“觅价者”。 价格歧视价格歧视可以消除无所谓损失，可以减少浪费，增加消费者满足感。 价格歧视的三种方法（越是难以阻止消费者转售的产品，就越难实施价格歧视） 完美的价格歧视：卖家对消费者所消费的每一个单位产品，都分别收取最高价格，但这只是一种理想状态。 二级价格歧视：对不同的购买量收取不同的价格，多买就便宜。 三级价格歧视：对不同人群或不同地区收取不同的价格。 信息不对称 信息不对称的表现：欺骗、偷懒、逆向选择、道德风险、敲竹杠 人际互信并不是天然存在的，如何通过制度来建立互信： 重复交易，尤其在熟人市场的交易是基于重逢的重复交易 第三方背书，通过中间人担保，买家和卖家可以克服信息不对称的障碍。 增加产品的附加成本，好的产品才配得上更高的附加值。 品质三包服务 付出沉没成本、给出人质或抵押。 汉德公式汉德公式是被广泛接受的判定各方责任的方法和标准之一，汉德公式的来源是1947年“美国诉卡罗尔拖船公司案”。 拖般公司在一次拖船作业时的错误操作而未固定好一艘驳船，这艘载有美国政府面粉的驳船就在港口附近漂泊。这期间因与一艘油船相撞而损坏，并在漂泊了21个小时之后沉没。这原本是一件普通的因操作失误引起的沉船事故。只是因为起事故中沉没的驳船上载有大量美国政府的面粉，而产生了巨大的经济损失。 汉德公式的三个变量：避免意外的成本记作B，产生意外的概率记作P，意外产生的损失记作L $$B &lt; P × L$$ 涉案方 B L B&lt;P×L 责任权重 美国政府 低 高 成立 主要责任 驳船公司 低 高 成立 主要责任 拖船公司 高 低 不成立 非主要责任 油船公司 高 低 不成立 非主要责任 来源：https://www.jianshu.com/p/301f2d2e5409 汉德公式告诉我们：在众多选项中，成本最小的选项才是最优解。 合作 企业的本质，企业能够无中生有的带来恶来收益的一种经济组织，每一个成员的收入取决于他对团队的边际贡献。 企业的存在是因为有个人单干会有交易成本，企业内部的交易费用很低。 交易费用会限制企业的规模，随着企业规模的扩大，企业内部会有管理成本。 企业存在是因为有团队效用 资本与劳动力资本是弱者，劳动力是强者。因为资本投入的资金一旦投出就很难收回，而对于劳动者来说，他们投出的是劳动力，可以随时付出，也可以随时收回。 专用资源与通用资源 专用资源：经济学家把那些高度依赖于所在企业平台的资源，称为企业的专用资源； 通用资源：那些无论放到哪个企业平台都能发挥差不多的功能、获得差不多收益的资源。 企业的专用资源必须是在特定的平台上才能发挥作用，所以让他们作为管理者会更在乎企业的成败。 固定收入与剩余索取剩余索取者的收入不根据他们的投入来计算，而根据企业产出—剩余的利润—来计算。企业剩下多少他们拿多少，他们越努力企业剩下的就越多，他们得到的就越多。因此不需要再有人监督他们的工作，监督他们到底卖不卖力。他们自己监督自己，企业管理者往往是「剩余索取者」。 协调货币货币的作用在于，人人都觉得它有用，人人都觉得别人应该接受它，货币是一种「自发秩序」，货币的作用有： 避免交易中双重偶然性的要求 如果采取 物-物 交易，就要求交易的双方对彼此交换的物品有需求，比如我有一头羊，想换一头猪，我恰好遇到有一个卖猪的人，这是第一种偶然性，而卖猪的也想要我手上的羊，这是第二重偶然性。 降低质量的检验成本 增加市场的交易量没有了双重偶然性和较低的检验成本，市场的交易量将大大增加。 商业银行是如何创造货币的当一个人有1000块钱的时候，第一天把这1000一千块钱存到银行里。银行就会急于把这1000块贷出去，银行会收取利息。第二天，口袋里面有钱的人又把钱存到银行里面去，这时银行账户上又多了1000块钱。看似银行只要不断贷款，人们不断往银行里面存钱，银行上的钱会无止境地增加，但实际原来市场上的货币只有1000块钱。 但政府对于银行会有一个规定，收到储户存到银行账户上的钱必须要留下一部分钱当作“法定准备金”，如果规定的准备金是20%，银行在收到这1000块钱后只能贷出800块钱，这样1000块钱最多有5000块钱的货币流通。 因此，当银行的储户都要求把自己存的钱从银行里面取出来时，银行就会倒闭。 通货膨胀通货膨胀是指物价的持续增长，这里的物质是指社会总的物价水平。可以通过货币数量论来理解理解通货膨胀$$MV=PY$$货币数量论：M是货币的流通量，V是货币流通的速度，P是平均物价，Y是社会的货物总量。经过简单的移项：$$P = \frac{MV}{Y}$$通过这个公式我们可以知道： 货物总量越大，产生通货膨胀的机会越小。 货币的流通量和货币的流通速度越大，产生通货膨胀的机会越大。 当货币发行量过大时，M就会无限增大。 经济周期奥地利学派奥地利学派并不是在学者的国籍，而是一种特有的研究方法和思路。 奥地利学派的主张 只有个人能做出选择 研究交易所在的市场是研究经济学的焦点所在，是在具体的市场环境中的。 研究经济现象要研究人的动机，要了解相应的人文背景。 奥地利学派对经济周期的基本观点 货币不是中性的，货币长期来看，对经济体中人与人的相对关系不会有什么影响。 资本是异质的，不是同质的，资本有其独特的使用方式，经济决策一旦做出，就很难撤回。 各种社会机构和安排是人们共同行为的结果，而不是计划的结果。 奥地利学派看经济周期的起源经济周期的起源是政府过度印钞，他们提出两点建议。 金本位，以黄金的数量为发钞的依据。 实施自由发钞，现在的数字货币就是一种自由发钞制度。 凯恩斯主义学派 凯恩斯主义看经济周期凯恩斯主义认为社会总需求的降低，对就业、产量和价格的影响不是对等的。由于每当出现一需求不足的冲击时，价格的调整总是迟钝和缓慢的，因此真正受到冲击的是就业和产量，这是经济周期产生的原因。 凯恩斯主义的主张：加大政府开支价格反应迟缓，市场没有办法自行调整，当社会总需求量不足时，政府代替人们形成需求，产生费用。那么政府的钱从哪来，靠货币政策（发钞）和财政政策（收税或借债）。 货币主义学派和理性预期学派 货币主义学派 坚持货币数量论，认为通货膨胀时因为货币超发。 货币长期来看是中性的。 制造通货膨胀不能降低失业率。 永久收入假说（人们拿到钱之后并不会马上取消费，而是存起来慢慢消费，追求长期幸福） 理性预期学派基本认可货币主义学派，但他们进一步提出，人们在决定自己的消费水平时会有预期，会盯住自己的长期收入。 真实的经济周期理论这个理论认为经济周期时很自然的事，生活中到处都是冲击，要应付这些冲击，人们的反应不是即时的，而是滞后的，不是全面的，而是渐进的。这本身就是合理的。额外的干预不会解决问题，而只会产生新的问题。这就是真实经济周期理论的核心思想。 宏观经济经济学争论的原因 第一，宏观经济现象涉及的变量太多，而我们研究的宏观经济现象本身，数量又是有限的。 第二，宏观变量本身是一些加总的变量，这些变量之间未必具有必然的因果关系。 第三，是人会形成预期，会产生对策。知识和信息不仅会影响人的行为，更重要的是，知识和信息本身就存在一个增长的过程，它们本身就是不可预测的。 人类无法用科学的方法应对不确定性。不确定性，指的是我们都不知道我们不知道的事情。当人们面对不确定性的冲击，当他们发现用精准的数学根本无力招架、无法应对的时候，他们就只能诉诸直觉、比喻、经验、自信以及勇气。这是宏观经济学真正深不可测的原因。 好的经济学家有什么样的特征： 一个很重要的特征，就是他们能够看见看不见的。好的经济学思维不追求某种单一维度上的最大化，它追求的永远是在各种选项当中边际成本和边际收益的平衡。我们要从各种可能的选项入手，去看见那些看不见的。 END断断续续，通过做笔记的方式摘录、梳理章节内容，相当于又把这本书读了一遍，甚至比读一遍花了更多的时间，所以在读第一遍时没看懂的地方也看通了，最后谢谢薛老师带给我们这么好的作品。]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 家庭版启动组策略组件]]></title>
    <url>%2Fpost%2Fwin10-home-gpedit.html</url>
    <content type="text"><![CDATA[前言我之前用的系统一直是WIn10专业版，但是我手上这台笔记本是自带的家庭版，刚好今天需要在组策略中配置一些设置，通过Win+R 运行 gpedit.msc时却无法打开组策略，才知道家庭版是没有组策略这一功能的。本来都想着更换专业版的密钥，再用ksm来激活。 但通过搜索后发现，专业版和家庭版的镜像文件其实时一样的，想起来之前装系统的时有一个选择系统版本的选项，既然镜像文件时一样的，那么家庭版系统中肯定也有「组策略」这个功能，只是系统限制了这一功能，我们只要手动让它启动起来即可。 启动组策略功能 新建一个txt文件，比如a.txt 在文本文件中，粘贴进几行代码： 123456@echo offpushd "%~dp0"dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txtdir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txtfor /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i"pause 把该文本文件的后缀改成可执行文件，如a.cmd 右键单机a.cmd，并以管理员身份运行 等待执行完毕 Win+Q或Win+R搜索运行gpedit.msc，即可打开组策略]]></content>
      <categories>
        <category>Computer skills</category>
      </categories>
      <tags>
        <tag>gpedit</tag>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速迁移系统]]></title>
    <url>%2Fpost%2FMove-System.html</url>
    <content type="text"><![CDATA[前言我的笔记本内置的固态是三星的一款M.2的SSD，但是是SATA协议的，因此只有500M/S的速率，但是另外空出来的一个插槽支持NVME协议。618的时候在京东上买了Intel 760P，装上之后才发现，这个插槽虽然支持NVME协议，但是只有2个通道，所以应该是PCIE * 2，速度只能达到正常速度的一半（读写都在1700M/S左右），后来想想买都买了懒得换了，至少比SATA的快。 装上固态，迁移系统装固态没啥好写的，这里说一下装固态期间发生的一个小插曲。话说去取快递那天中午是刚参加完毕业典礼回来，下午还要去修改论文。因此想趁着中午的时候，就把固态装上测试一下，用买固态附送的小螺丝刀三五下就把外壳取下来，但取固态插槽那颗螺丝的时候给我整懵逼了，刚扭了一下螺丝就滑丝了。当时就在吐槽，机械革命你踏马为什么多此一举在这放一颗螺丝，放的话为什么不放一颗质量好一点的螺丝，吐槽归吐槽，还是要想办法把螺丝取下来，然后我就用小刀一点点给这颗螺丝刻凹槽，然后用一字起把这颗螺丝刀取出来了，最后换上买固态附送的螺丝。 Fine，装上固态之后，测了一下速便感觉一切索然无味。 直到今天，才想着把系统迁移到这块NVME的固态上，那么究竟用什么工具来迁移呢？其实很简单，大部分的磁盘工具都支持「磁盘克隆」，比如傲梅分区助手、DiskGenius。而我使用的是因特尔数据迁移软件（Intel Data Migration Software），软件界面如下图所示： 这里有很多工具可以使用，但目前只需要使用第一个工具——「复制磁盘」，该工具的介绍为: 该实用程序可帮助您将操作系统、应用程序和数据复制到新磁盘。新磁盘将与旧磁盘完全相同，而且会保留系统可启动性。 进入工具后，在向导窗口根据步骤一步一步来操作就可以了，第一步是选择源磁盘，第二步选择目标磁盘，大概10分钟左右就可以全部完成（取决去你的两块硬盘的速度） 克隆完成后，在资源管理器看不到目标磁盘，为了等会开机后区分新旧磁盘，可以在当前系统桌面上随便创建一个问题，比如创建一个txt文件。一些准备就绪之后，关机，再直接开机，发现桌面上没有刚才创建的那个txt文件，说明当前的系统已经是克隆后的系统，另外新硬盘的盘符也会与旧硬盘的盘符交换了，也不用自己取手动变更盘符了。]]></content>
      <categories>
        <category>Hardware</category>
      </categories>
      <tags>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「我不知道该说什么，关于死亡还是爱情」书评]]></title>
    <url>%2Fpost%2FVoices-from-Chernobyl.html</url>
    <content type="text"><![CDATA[Title 我不知道该说什么，关于死亡还是爱情 Author [白俄罗斯]S.A.阿列克谢耶维奇 Edition 花城出版社 Release Date 2014-06 ISBN 9787536071377 近期HBO的美剧《Chernobyl》的播出再次引起了我们对发生了三十多年前的那场悲剧的关注，由于前几年读也阅读了一本记录了切尔诺贝利的书，因此旧文重发，注意这本书还有另一个翻译版本——《切尔诺贝利的悲鸣》。以下部分为原文： 我从未读过如此悲伤的文字，切尔诺贝利——这里所遇到在灾难是我从未看到的或者知道的，我只能用然人间地狱来称呼这里。 背景切尔诺贝利是前苏联的一部分，属于白俄罗斯的领土。在1986年切尔诺贝利核电站四号反应堆发生大爆炸，这次灾难所释放出的辐射线剂量是投在广岛的原子弹的400倍以上。因这次事件死亡的人物不计其数，现在在这个只有一千多万人的小国中每五个人就有一个住在辐射区，总数为二百一十万，其中七十万是儿童。在受灾最重的地区死亡率比出生率高了20%！ 这里的一切都是真实发生的，书中的每一段文字都是作者 S.A.阿列克谢列维奇走访受灾群众口述而成的。 国家的英雄消防员瓦西里是最先进入爆炸核电站的人员之一，几个小时后他便被救护车送回来了，14天后由于大量辐射死于器官衰竭。“他是被自己的内脏呛到的，稍微咳嗽一下，他的肺和肝都可能随时从嘴巴里跑出来。”，讲述这个故事的人是他的妻子，那个时候她正怀有4个月的身孕，对于一般的人来说，原本这个时候正是她人生中最幸福的时刻，但却不得不面对这样的现实。对于吸收了1600伦琴辐射的丈夫（400伦琴就可致死），她选择的不是逃避，她骗了所有人，甚至不顾肚子里面的孩子偷偷跑到隔离间去照顾他，他全身溃烂，衣服沾到身上，妻子一点一点的帮他清理，给他喂药，陪着他说话。 什么是爱情，我没有经历过。但我想为了心中的挚爱就算是冒着生命危险也在所不惜，如果面对如此情形，我会如何选择呢？是转身离开把他和他的记忆留在记忆深处，开始一段新的生活。还是默默陪伴在她的身边，就算是死亡也在所不惜。 在这里，和瓦西里一样的年轻人不断从各地赶来。他们被叫做是国家的英雄，而国家给他们的任务却是用“铲子对抗原子”，多么荒谬的事情，他们在几百伦琴辐射工作，没有任何有效的保护装备。在年轻人中流传着一个笑话，一个美国机器人上屋顶作业五分钟，然后就发生故障了。日本机器人也上去作业了五分钟，然后也发生故障了。俄罗斯机器人来了，一上去就是两个小时！这时扩音器里传来了命令：“二等兵伊凡诺夫！再过两个小时，你就可以下来休息，抽根烟了。” 他们是国家的绿色机器人，在他们死亡时留给家人的只有刻有马克思、列宁头像的奖章。而国家给他们承诺的房子、车子消失了。 无处不在的污染切尔诺贝利是最可怕的战争，你无处可逃，地下、水里，空中都躲不了。牛奶，事物，土地中都含有大量的辐射。母亲在家门口哺乳，就像是切尔诺贝利的圣母，但她的母乳里却含有大量的铯元素，相当于是另一种凶猛的毒药，但是母亲是不自知的。 切尔诺贝利的人民，他们都不知道发生了什么。政府给他们的回复是“情势稳定”，一切还是和爆炸以前的一样。他们依然坚守在自己的土地上，对于他们来说，少了政府的管制倒也自由些了。而正是由于政府的愚弄和科学家的沉默让更多的切尔诺贝利的居民生活在辐射之中。 切尔诺贝利的人突然有一天，你变成了切尔诺贝利人，变成了某种特殊的物种，大家对你感兴趣，却没有人真正愿意了解你。 如果仅仅只是这样，那也并不糟糕，让人感到痛心的是，切尔诺贝利的人们不仅要背负辐射的污染，更要背负人心的疏离。 他们坐火车的时候，当得知他们是从切尔诺贝利来的，乘务员不愿意供给他们餐具和被子，周围的人也一下子保持沉默和疏离。上学的孩子一旦被得知是切尔诺贝利人，所有的小孩都排斥他，疏远他，不愿意更他交朋友，更不愿意亲近他。 而更让人感到荒诞的是，从切尔诺贝利事件中的幸存者，在面对爱情和婚姻时，遭到拒绝的理由却是：“你不能生孩子，生小孩对你来说是罪恶的。爱一个人对你来说都是一种罪恶”。亲历的讲述者说，你知道生小孩可能是一种罪吗？我以前从来没听过这种事。 受到核污染之后的好几年里，很多人并不愿意离开切尔诺贝利，他们知道自己无时无刻不遭受着污染，但是他们不愿离开，而这其中的原因是，因为在切尔诺贝利没有人会以怪异的眼光来看待你，也不会遭到他人的疏离、冷遇和提防。“至少当我拿自家的苹果给对方吃时，他会很高兴坦然的接受，而不是在转身就把这苹果处理掉。” 让人感到痛心的是，切尔诺贝利的核污染现在仍然在继续，战争的伤痛总有停止的那一天，但是核辐射带来的污染却是无止境，也无从消灭。当我们在享受科技带来的便捷的同时，也不应忘却科技曾带给我们的灾难！]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>纪实</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「中国国家治理的制度逻辑」读书笔记]]></title>
    <url>%2Fpost%2FThe-Institutional-Logic-of-Governance-In-China.html</url>
    <content type="text"><![CDATA[Title 中国国家治理的制度逻辑 Author 周雪光 Edition 三联书店 Release Date 2017-02 ISBN 9787559626295 摘录 中国国家治理的一个深刻矛盾是一统体制与有效治理之间的矛盾。 国家治理模式决定了其政治运行特定的优势、负荷、困难和挑战。国家治理模式不是任意选择的，常常与个国家的历史演变过程有着深刻关系，有明显的途径依赖性。 一统体制的集中程度越高、越刚性，必然以相应程度上削弱地方治理权为代价，其有效治理的能力就会相应减弱；反之，有效治理能力的增强意味看地方政府治理权的扩张，常常表现在或被解读为各自为政，又会对一统体制产生巨大威胁。]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>政治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「民主的逻辑」读书笔记]]></title>
    <url>%2Fpost%2FDemocracy-Logic.html</url>
    <content type="text"><![CDATA[Title 民主的逻辑 Author 包刚升 Edition 社会科学文献出版社 Release Date 2018-06 ISBN 9787520125819 摘录 一个自由社会的良好公民需要同时做到两点，一是主张和捍卫自己应用的权力，二是遵守经合法程序指定的法律及服从合法的权威。 人是生而自由的，但却无往不在枷锁之中。自以为是其他一切的主人的人，反而比其他一切更是奴隶。——《社会契约论》 没有人假装民主是完美的和全智的（all wise），民主其实是最坏的政府形式，但要除了所有过去已经被尝试过的政府形式以外。——丘吉尔 经验告诉我们，民主转型更可能是一个结果不确定、充满各种挑战、历时漫长的政治过程。 自由是“一个人不受其他某人或某些人武断意志的强制”，或者说自由就是免于强制。——弗里德里希·哈耶克 现代民主是一种复合型政体，包含了古希腊贡献的民主因素古罗马贡献的共和主义传统、英格兰贡献的成熟代议制以及欧洲北美所贡献的政治平等逻辑。——罗伯特·达尔 欧洲历史意义上的封建主义体制是封君与封臣之间基于土地、融合了财产权利与政治权利的契约关系。这种契约关系的核心是:封君或领主应提供保护和尊重习惯，而封臣或附庸应提供兵役和表示效忠。 《独立宣言》开篇语是对英国哲学家约翰·洛克《政府论》下篇的模仿洛克认为，人类组成政治社会的目的，是为了保护每一个社会成员的生命权、自由权与财产权。《独立宣言》还认为，政府需要经过被治者的同意。 美国的土地制度和自耕农模式的结合还强化了美国的个人主义文化。 自耕农模式下的美国人更崇尚个人奋斗与自力更生，崇尚依靠自己而不是依靠国家、相信通过自己的努力来改善命运而不是依赖政府供给与社会福利。 在一个尚未充分工业化的农业社会土地分配的不平等就是最大的不平等。 资产阶级最想要的制度安排应该是立宪政治、法治国家、有限政府、分权制衡以及自由市场体制。 一个稳定的和有效率的民主政府，不光是依靠政府结构和政治结构；它依靠人民所具有的对政治过程的取向，即政治文化。——里埃尔·阿尔蒙德 一旦政治竞争是完全意义上的赢家通吃，政治斗争就容易走向不择手段和丧失底线。 多数决定制更容易导致两党制比例代表制更容易导致多党制。——迪韦尔热 对一个国家来说，有什么样的政治精英就有什么样的政治；对一个国家的民主转型来说，有什么样的政治精英就有什么样的民主转型。 政府——无论是民主的还是威权的一—本身无法创造财富，它能做的就是转移财富。 民主选举往往是政治动员的重要驱动力，而在那些族群、宗教多样化程度很高的国家，精英们容易选择将这种族群、宗教分歧政治化，并以此为基础进行政治动员，结果就容易导致政治暴力。——《从投票到暴力》 在人类历史的长河中，文明的此起彼伏乃是一种常态。 当特定族群、宗教和语言的人口到达一定规模后，就容易产生聚居效应。 今天全球威权政体或多或少都面临着一个基本问题，那就是合法性的困境。 从20世纪以来的人类政治史来看，很多愚蠢的乃至灾难性的重大决策都是威权体制下少数领导人刚愎自用、一意孤行的产物。 与民主政体相比，威权政体往往需要维持更为庞大的内务部门（警察与安全部门），需要花费更高的成本来压制潜在的反对力量，这种成本最终都需要整个社会来承担。 威权体制通常还会禁止某些外部思想或信息的输入，甚至需要建立一个更封闭的经济、政治与信息体系这种做法有时看起来不过是维护体制稳定的权宜之计，但其长期后果可能非常严重，有可能阻碍一个国家的经济增长、科学进步、产业升级与整体创新能力。 通往奴役的道路，往往是由善良的愿望铺成的。——哈耶克《通往奴役之路》 政治生活的另一面是，即便人类无法实现完美的政治乌托邦，但现实政治通常都有着巨大的可改善空间，而且我们也不应该放弃这种改善现实政治的希望。 主要内容民主的概念1.0版本：人民的统治 谁是“人民” 公民 政治共同体的大多数人 政治共同体中政治正确的那部分人 怎么统治 直接统治 间接统治 采取某种程序和方式来制定国家制度 问题 无法辨别“民主”的真伪 2.0版本：竞争性的选举制度 要素 政治竞争：政治精英展开政治竞争 政治参与：普通公民具有投票权 问题 无法确保选举的公正性 3.0版本：选举民主+法治 法治的作用 保护了公民的基本权利 确保法治的自由与公正 约束执政者守法、恪守民主规则 解决政治争端 问题 不是存粹讨论民主，而是民主和其他的混合物 民主的起源雅典城邦民主 形成的原因 地理因素古希腊海岸曲折、岛屿众多、陆地多山 阶级斗争假说 军事技术假说 三次改革 卢梭改革 BC594 经济改革 取消平民债务 取消土地抵押 政治改革 将雅典公民划分为四个财产登记 设立四百人制度 司法审判制度（陪审团） 克里斯提尼改革 卢梭改革80年之后 设立以德谟（村）为基础的治理单位 选举产生十将军制度 伯里克利改革 公元前五世纪 设立支薪制度给出席五百人会议、陪审团和行政长官提供日薪 确定“公民权”父母双方皆为雅典公民，子女自动成为雅典公民 如何运作 公民大会（最高权力单位） 五百人议事会 行政官员（抽签+选举 产生） 陪审法庭（至少200人，且为单数） 陶片放逐对可能的“危险分子”实施放逐，放逐时间为10年，但放逐者的财产和地位不受影响。每个公民持有陶片并写上放逐人的姓名，在指定的时间放到投票箱，如果有效票数超过6000，则出现姓名最多的人将被放逐。 古罗马共和制 混合政体&amp;制衡政制 君主因素（执政官） 由两名执政官和多名副执政官构成 由平民大会选举构成 职责是领导国家和指挥战争 贵族因素（元老院） 最初由贵族组成，后期人数慢慢扩大 职责 控制共和国政府的预算和资金 管理日常公共事务 任命行省官员 民主因素（平民大会、保民会） 选举产生执政官 颁布法律 问题与挑战 国家规模和行省统治 无休止的战争导致军事化倾向 财富结构和阶级结构的变化 影响 共和制政体持续了五个世纪 对欧洲和世界产生了近千年的影响 英国议会制度 约束国王权利 1215年《大宪章》 国王的权利应该受到原则性的约束（“国王不应受限于任何人，但应该首先于上帝和法律”）。 纠正国王过去的错误。 1258年《牛津条约》 重新确立的《大宪章》的有效性。 规定了国王违法《大宪章》后，贵族和公民反抗的合法性。 国王处理国家公共事务需要遵从贵族会议。 议会主权形成 1688年“光荣革命”国王成为一个符号，统而不治 责任政府形成 1720年起组建内阁 落实普选权 1832年—1928年 原因 社会因素工业革命、城市化以及大规模工厂组织的出现。普通人的公民意识和政治参与意识开始觉醒。 政治因素 三波民主化浪潮 民主政体的最低标准亨廷顿《第三波》 50%成年男子有普选权 政府首脑依靠民选议会的多数支持或定期普选产生 第一波：始于欧美 主要时间：1828—1926 两个重大事件 美国革命 重要文件 1776年《独立宣言》 1783年《美国宪法》 1965年《投票权利法案》 民主化进程的因素 共和制宪法为国家指明了道路 政治家、立法者和大法官的努力 英国的政治制度对美国的影响 美国的土地制度 影响 美国经济、科学和学术的成为成为全球发展的典范 直接影响了全球民主政体发展（德国、日本等） 美国确立的“民主化外交，推动全球意识形态的重塑 法国革命 重要文件 《人权与公民权宣言》 《拿破仑法典》 历程 1789年“法国大革命”：第一共和国 1799年-1815年：拿破仑第一帝国 持续30多年：波旁王朝和六月王朝 1848年-欧洲革命：第二共和国 1875年-1940：第三共和国 特征 现代世界民主化的第一次尝试 逐步民主化，普选权扩大 民主国家作为工业化和全球化影响了全球民主化 西方重大事件对世界民主化进程产生了影响 民主化主要集中在西方少部分地区 第二波：走出西方 主要时间：1943—1963 两个大事件 第一次世界大战的结束 亚洲和非洲去殖民化浪潮 典型国家 德国 1918年之前：德意志第二帝国有宪法、议会、定期选举和政党政治。但德国首相和议会对皇帝负责而非对议会负责 1918—1933：魏玛共和国 1933—1945：法西斯极权体制 1945后：联邦德国（西德）启动民主化进程 印度 尼日利亚 特征 驱动力：二战的结束、去殖民化运动 民主已经成为全球支配性的意识形态 大规模进入欧洲，亚非也开始兴起 收到了全球化深入发展的影响 第三波：全球时代 主要时间：1974— 西班牙 西班牙竞争性政体的传统 佛朗哥时期的经济发展 处于西南欧（周围有英法德意） 俄罗斯 20世纪80年代—1911苏联解体：戈尔巴乔夫 1911—1999：叶利钦改革 2000—至今：普京时代 韩国 智利 阿拉伯之春（冬） 代表 突尼斯 利比亚 埃及 土耳其 影响中东北非政治改革的因素 威权政体类型（君主制/非君主制） 是否拥有丰裕的石油资源政府有石油资源有利于维护本国政体的稳定 伊斯兰世界极端恐怖注意势力 特征 1.规模最大的民主化运动 2.民主国家的数量超过非民主国家 3.受到冷战结束、欧盟的影响 4.处于完全工业化和充分全球化环境 民主治理绩效民主能否带来经济增长？ 能 1.政府权利受到了限制，立宪和法治的政府能促进经济增长 2.公共政策能得到更好的回应，能体现公共利益 3.公共教育文化和人力资本的提升速度更快 4.民主的国家具有更好的创新能力，因为自由的环境下更利于创新 否 1.民主不一定能形成有效的政府、形成有效的决策和解决问题的能力 2.基于民意和多数决定不一定能形成明明智的决策 3.民主更容易导致较低的投资率 4.民主政体下的政策更导致民粹化 民主能否带来好的公共治理？ “全球治理指数”标准 公共表达和问责制 政治稳定和控制暴力 政府效能 管制质量 法治 控制腐败度 能 1.政府权利受到约束 2.公共政策更有回应性 3.民主的治理是基于公共利益的 否 1.低民主国家处于无法治理的状态 2.政治精英能力和品质不行 3.不能形成良好的公共政策 民主能否促进平等？ 政治平等 形式：每个公民有同等的政治权利 实质：每个公民的政治影响力均等化 经济平等 形式：每个具有同等基本经济权利 实质：每个人的财富均等化 民主和非民主相比，实现了更大程度上的形式或程序平等 民主能否减少政治冲突？ 政治冲突的来源 阶级政治的挑战 身份认同的危机（宗教和种族） 意识形态的分歧 民主程度低 政治暴力概率低 导致冲突的诱因被威权政体控制住了 民主程度提高 政治暴力发生概率提高 政治斗争和政治动员被强化了 民主程度高 政治暴力的概率下降 民主机制和平、有效解决政治分歧 民主的兴衰成因经济社会条件论 经济发展 富裕的国家更容易维持民主，而在贫穷的国家更容易崩溃。 阶级结构 资产阶级有利于民主 对于威权政体和民主政体，资产阶级面对的是“两害相权取其轻”而采取的政治抉择。 民主政体：一人一票的普通民众会对自己的资产造成威胁。 威权政府：威权政府的胡作非为，政府的权利不受限制。可能会面临政府通过各种方式剥夺有产阶级的财产。 无产阶级推动落实普选权推动民主 中产阶级更少的阶级斗争有利于民主 群组宗教结构 族群或宗教的分化结构与民主转型挫败的可能性是一个倒U曲线的关系： 族群较少，由族群分歧或宗教分歧导致的政治冲突可能性较少 族群较多，可能导致的严重政治冲突会增大 族群宗教分化继续增大时，基于族群-宗教的政治认同感降低了。 政治文化 国际因素 国家因素 政治制度论 民主政治制度 总统制 半总统制 议会制 选取的制度 议会的规模： 规模大：好处是代表性很充分，坏处是议事效率和效能受到影响 规模小：好处是议事简便，坏处是代表性不足，容易被少数政治家操控 多数决定制 比例决定制 混合制 政治精英论 政治精英影响国家政治 政治精英影响民主转型 民主的现状及未来民主政体国家的治理挑战 大政府的兴起 原因 工业化、城市化对公共服务的需求 民主化时代选民的需求 现代国家官僚体制的扩张 后果 政府责任和权利范围的扩张 高福利倾向和在分配倾向 社会税负会越来越重 小政府模式的终结和个人精神衰退 市场经济、贫富分化和民主治理 群组宗教的多样化 新兴民主国家的转型难题 民主运行起来 没有重要政治力量反对民主 政治力量的竞争能达到均衡 民主产生绩效 有效的国家治理和治理绩效 民主得到巩固 民主的制度化、管理话和稳固化 政治文化的转型 威权政体的困境、复兴与前景 威权政体的价值取向 发展导向 掠夺导向 多层委托代理关系的困境 大型威权政体面临代理链长而导致的治理难度更大 威权国家的官方腐败问题严重影响着治理的效能问题 政治决定和公共政策的风险 威权政体下，决策失误可能性更高。纠错成本也更高 更高的维护稳定的成本 庞大的内务（国安、警察）系统 需要封闭的经济、政治和信息体系（阻碍经济增长、产业和创新能力） 独权的领导人风险 威权政体下领导人的选择透明度低 没有有效对领导人权利的限制制度 思维导图MindNode笔记： https://my.mindnode.com/NxH7GR6a6krujfBLqu2B5EJ43DQ21DCmx7nVznLx 评价花了几天时间阅读包老师《民主的逻辑》，首先在这本书作为一个可读性很高，阅读起来没有想象中的难。整本书的逻辑框架非常清晰，很有条理性。内容上来说，介绍民主的起源，民主的内涵，分析了高民主国家、民主转型中国家、威权政体国家发展的现状及其优势和问题。书中有非常多的引述，包括常见的政治哲学类、社科类的专著。比较遗憾的是大部分内容只是作者对目前上学术界观点的总结概括，而自己的观点相对比较少。总的来说，通过这本能帮助我们理清民主的各个方面，全面地理性地看待“民主”这一政体。比刘瑜的《民主的细节》更加系统全面，也更加严谨。]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>包刚升</tag>
        <tag>政治</tag>
        <tag>民主</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在NAS上搭建FTP服务]]></title>
    <url>%2Fpost%2FBuild-Ftp-Server-On-NAS.html</url>
    <content type="text"><![CDATA[前言之前在家的时候，多设备之间共享文件是直接访问NAS，很方便。但目前在学校的校园网环境下，虽说可以远程登陆NAS来传输文件，但是两端的设备都需要先登陆NAS，再找到指定路径，再上传/下载。所以一般我要多设备同步文件，一般是通过QQ、微信和Telegram来发送。 今天突然想起来可以使用「FTP服务」来同步文件，首先想到的是在「VPS」上搭「FTP服务」，但是有几个问题：一是连接速度和流量限制的问题，毕竟VPS在海外，而且也会浪费VPS的流量；二是VPS的存储容量有限；还有就是资料安全性的问题，如果要更换VPS了，这些资料还要下载下来。 记起来QNAP是支持搭建FTP服务的，本来NAS上存放的就是一些文件，安全性和速度都比VPS上好一些。 环境准备 网络环境为公网IP（如果没有需要需要「内网穿透」服务） 路由器支持DDNS和端口转发（一般的路由器都支持） 支持搭建FTP服务的NAS 开始搭建QNAP中打开「FTP服务」登陆NAS后，操作流程：点击【控制台】-&gt;【网络&amp;文件服务】-&gt;【FTP】 把「启动FTP服务器功能」勾选上 协议类型：FTP 端口：默认是21 Unicode支持：默认是关闭的，使用的 FTP 软件不支持 Unicode 的话，请将 Unicode 支持设成”否” 允许匿名：如果不允许匿名，则需要NAS用户名和密码来登陆 连接：按字面意思设置即可，一般为默认 高级设置-设置根目录：FTP连接的路径地址 路由器设置 设置DDNS设置路由器的远程管理的时候，我已经设置过DDNS了，如图： 添加端口转发注意：服务器IP是指NAS的内部IP地址，我已经在「DHCP」中将NAS的ip地址固定了 连接FTP服务Windows连接FTP服务 Windows可以直接在「资源管理器-此电脑」右键中「添加一个网络位置」，网络地址填： 1ftp://ip地址或动态域名地址/子路径 再填用户名和密码，通过这种方式可以像使用自己的磁盘一样使用，但是不用直接双击直接打开文件，需要先复制到本地路径，它的速度取决于两端的上传和下载速度。 使用FTP连接软件如Total Command、FlashFXP等等 移动端连接方式和Windos类似，都需要FTP服务器地址、用户名和密码。 Android可以使用「Solid Explorer」。 IOS可以使用「Documents（Readdle公司）」]]></content>
      <categories>
        <category>computer skills</category>
      </categories>
      <tags>
        <tag>文件管理</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「风中有朵雨做的云」观后]]></title>
    <url>%2Fpost%2FCloud-in-the-Wind.html</url>
    <content type="text"><![CDATA[情节概述 这是一部在改革开放背景下，由城市建设拆迁而引发的利益、官商勾结的故事。因为「风雨云」并不是宏大叙事，所以上面的只是故事的背景而已，通过这一切口去展示其中“腐烂的现实”。 电影是以一场拆迁地坠楼案展开的，坠楼的是人正是开发区的领导—— 唐奕杰。因为当地抗拆居民和开发商发生了骚乱，唐奕杰为了维稳而赶到拆迁现场，去勘察楼层情况时突然坠楼身亡。唐的死亡原因就成了电影的最大疑点和情节发展的主要驱动力，是失足跌落、自杀还是ta杀，考虑了唐的性格和当前的现场环境，最大的可能是“ta杀”，围绕着这一事件，角色一个个登场了： 杨家栋：当地年轻的警官，负责唐的坠楼案，揭露真相唐死亡的真相，也是为了揭露他父亲车祸的真相。 林慧：唐奕杰的妻子，和姜紫成是朋友兼情人。 小诺：唐奕杰的“女儿”。 姜紫成：地产商人，紫金置业的老板。小诺的亲生父亲。 连阿云：影片刚开始的无名女尸，台湾坐台小姐，姜紫成的情人，后被包装姜的商业伙伴。 因为剧情比较复杂，这里就不再详细梳理了。接下来的故事是以“杨家栋”开始调查唐坠楼案而展开，因为唐坠楼案后的利益关系，姜紫成对杨家栋调查这一案件而不断阻挠，最后找出了片头出现的「无名女尸案」和「唐坠楼案」。 从类型的角度的看，这是一部典型的「悬疑片」，故事情节一开始就设立了 导致唐奕杰坠楼案凶手的身份的「悬念」，叙事剪辑方式很多样，主要是过去（2006）之前，现在（2012）的不同时空间的碎片化的交错闪回，这样的好处是使整个影片的节奏非常快，能方便地铺悬疑点。叙事效率非常高，几乎没有多余的画面和情节。「过去」和「现在」两个时空去采取「时间-地点」的字幕信息去交代，这样使时故事的清晰度不高，对观众的要求也比较高。 摄影和剪辑「风雨云」摄影和剪辑也让我很享受。娄烨导演一贯的手持摄影的方式，一方面在生理上让人感觉不舒服，另一方却大大增强的真实感。尤其是一开始的城关村的骚乱场面太精彩了，由一系列俯拍、跟随、交叉、穿越的镜头组成，这个看起来像是长镜头的拼切镜头带领我们去感觉广州城中村拆迁的环境现状，各处的残楼瓦砾，瓦砾上居民晾晒的衣服，骚乱中拥挤的人群，挖掘机推到墙壁和电线杆的轰隆声，给人一种强烈的压抑感，而这一种压抑感、压迫感和整个影片所要展现的基调是一致的。 让我印象非常深刻的还有几个场景，杨家栋在城中村被陷害杀人的逃跑镜头，这组镜头充分展现了城中村特有的潮湿、逼仄的环境，之前我也在广州城中村住过一段时间，这组镜头完全勾起了我在楼房与楼房之间行走那种压抑的感觉。另外两场车内争斗戏也非常出彩，就不再具体叙述了。 最后在「风雨云」中，娄烨试图将商业片和艺术片进行融合，从这点上说，他做的很不错。片中塑造的悬疑元素、出彩的动作设计能牢牢吸引观众。整个影片的布景、光影、声音的处理都体现出娄烨的专业性的艺术追求，电影外的事情无须多言。 电影会帮我们记住，我们和我们的时代。]]></content>
      <categories>
        <category>Movie</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「如何聊电影」读书笔记]]></title>
    <url>%2Fpost%2FHow-to-watch-movies.html</url>
    <content type="text"><![CDATA[Title 如何聊电影 Author [美]安·霍纳迪 Edition 未读-艺术家 Release Date 2018-10 ISBN 9787559626295 剧本 三幕式电影结构：第一幕（铺垫）、第二幕（冲突）、第三幕（解决） 通常来说，一个好的剧本应该对环境和角色有精准细致的描绘。 剧本决定了我们在这两小时内进入的是一个怎样的世界，而编剧的水平和他的文字功底决定了这个世界是否真实、有活力，能否让我们迅速入戏。 剧情只是说事（机械复述），故事是在讲意（表达情感）。 这种给角色脸上贴金的做法有一个专门的术语叫“（加）风险”（stakes），也就是编剧将故事写得更紧张激烈，并通过赋予角色行为更戏剧化、更能获得观众同情的动机，让角色更具“共鸣感”。 可信度人类的缺点的存在或缺失瑕疵以及合反映出编剧理和不合理的人性的理解程行为的了解。 表演 表演还是取决于演员在塑造一个角色时所做的一系列决定—把握角色内在和外在的各种细节，打造出有深度、有真实感、有吸引力的角色。 最好的银幕表演应该能在“表现”与“克制”之间达到超常的平衡，也就是说，既要透明到能让观众瞬间了解角色，又要内敛到让观众好奇角色下一步会怎么做。 最忌讳被观众发现表演痕迹的类型片，可能是喜剧片。 伟大的演员能不断勾起我们的好奇心，让我们在对他们的一知半解中获得满足。 选角的艺术离不开经验、品味、直觉、风险、讨价还价，还有纯粹的运气。 相比选择家喻户晓的大明星，选用生面孔可以更有效地奠定一部影片的基调。 在电影诞生伊始，也就是在默片时代，夸张的戏剧动作不仅为观众所熟悉（当时的舞台剧和歌舞秀都是这种表演风格），更是在没有台词的情况下传达影片讯息的必要手段。进入三四十年代的“黄金时代”，即便有声电影已经普及，风格化、戏剧化的表演依然占主导地位，但浮夸、直白的动作正在逐渐消失。 衡量一个演员表演的好坏，应该看观众是否获得情感共鸣:演员的表演是帮助了我们进入银幕中的世界，还是让我们觉得出戏？ 拿一部电影的原真性（perceived authenticity）作为卖点已经成了一种廉价的营销手段。 作为观众，我们不需要知道演员为了准备一个角色进行了怎样的自我思考、即兴创作，或者热身运动，我们也不需要知道演员为了在银幕上打造一个他栖身的世界做了多少研究，我们只需要跟随他们一起进入这个世界即可。 戏中演员最重要的就是把正确的外部表演和正确的内心表演结合。 在评价一个你不喜欢的演员的表演时，观众必须把这个演员可控的地方和不可控的地方区分开来。演员没法让自己的个子忽高忽矮，也不可能随意增重或减重，但他们可以据故事需要，让自己的角色形象或优雅尊贵，或粗野，或谦逊。 艺术设计 在评价一部电影的艺术设计时，可信度、吸引力、细节度、原创性都应该列入考虑范围。 和剪辑一样丫奥斯卡最佳艺术指导奖通常都是颁给在艺术指导方面做得最张扬、最气派的电影）比如服装华丽的历史剧情片，或者在视觉上极富创新的电影。 最好的艺术设计是难以察觉、不着痕迹的。 最好的艺术设计是通过无形与有形、逼真和矫饰之间的内在张力实现的，优秀的艺术指导能为观众打造出愉悦的、富有质感的视觉体验，并提供细节丰富的布景，让表演者尽可能真实、自然地表演。 母题：指电影中有意义且重复出现的元素。母题可以是物品、颜色、地点、人物、声音等。 但电影的艺术设计一直在帮助我们感知和理解电影，并在视觉、精神乃至潜意识上影响我们。 艺术设计不仅能让观众了解角色，还能够传递主角不能传递的价值观、需求和欲望。 电影一定要尽量多给观众一点儿信息，用画面和信息淹没他们。如此一来，一部电影便可以重复欣赏，影迷每次重看都会有新的发现。 摄影 德国表现主义（Expressionism）：用极简、强烈的光影对比。 摄影机是我们进入银幕世界的通道，问题是电影制作者究竟是在用摄影机把我们拉进去，或是让我们与之保持距离，还是将我们拒之门外。 剪辑 最好的剪辑并不会引起观众的注意，而是消失在电影中。成功的剪辑能让观众获得满意的观影体验，感觉整部电影浑然天成，从头至尾没有一点儿磕绊，没有别扭的转场，没有不合逻辑的剧情，也不会让人感到厌烦或者疑惑。 我们说一部电影太长，指的是它重复、无聊，或是纯粹为了堆砌银幕奇观而加入一场又一场爆炸戏和破坏戏。 一百多年来，电影的基本语法并没有太多改变。电影依然是由场景构成，而场景由镜头构成，镜头则是叙事的基本元素。 声音和音乐 好电影不只是精彩的故事、高超的表演、迷人的画面结合的产物，它还能提供富有深度的体验，将对话、音效、音乐融合在一起，打造一个音响环境，让观众听到的声音和看到的画面一样充满了层次感和细节度。 声音对我们在电影中能看到什么有强烈的影响，这种影响通常都是潜移默化的。 奥斯卡中共设了两个声音奖项： 最佳声音剪辑奖：声音剪辑师（sound editor）负责汇集、制作、整理观众在银幕上听到的一切声音，其中包括角色对白（包括拍摄现场录制的对白和后期配音）和音效； 最佳混音奖：混音师（ sound mixer）负责决定这些声音如何相互共存，以及如何与配乐共存。混音师可以通过调整不同声音的比例，来增强真实感和情感冲击力，提升观众对影片故事的理解。 声音在打造连贯性上的另一个作用，是让场景之间的转换更加自然流畅。在声音设计的帮助下，观众可以自行在脑中将看似没有关系或者衔接比较生硬的两个场景连到一起。 一部电影的声音有多写实，完全取决于这部电影想要讲述一个怎样的故事，以及导演是想将观众的注意力引到角色身上，还是引到他们抽象的情感体验上。 音乐不应该只是重复或强调已经通过视觉画面或者角色对白传达出来的故事元素和情感。它应该有所添加，不是模仿或者强调已经发生的动作，而是在不知不觉中，赋予它更多的意义，让故事更有深度。 从本质上讲给一部电影过度配乐其实是对观众的不信任，同时也反映了电影制作者自己的不自信一只会反复告诉观众如何去感受，而不是让故事和演员去完成情感传递的任务。这种配音被叫成「米老鼠配乐」（mickey-mousing)导演 导演需要从头到尾对整个作品内容进行负责，不管是影像风格、剪辑、音乐的选择、甚至是演员的表现上。 ​]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity3D音频管理器「生存之战」]]></title>
    <url>%2Fpost%2FUnity3D-AudioManager.html</url>
    <content type="text"><![CDATA[Unity3D的音频系统介绍 前言想象一下如果电影没有了声音，我们的观影体验会大打折扣，声音也对于游戏有非常重要。游戏中的声音主要是指游戏交互过程中的各种音效，如走路会产生脚步声，射击时会有枪声，这些音效就是为了产生更沉浸的世界（环境），游戏中另一个声音是背景音乐，起到烘托游戏气氛的作用。 Unity3D中的声音音频管理器 Edit–&gt;ProjectSetting–&gt; Audio AudioClip（音频文件）Unity3D中支持各种格式的音频文件，可以导入的音频格式有.wav .mp3 .ogg，可以直接将音频文件拖拽到Unity3D的「Assets」中里。在Unity3D里面，这些音频文件叫做Audio Clip。 AudioListener （音频监听器组件）一个Scence中有一个AudioListener，它可以接受游戏中的所有音乐和音效，相当于人的“耳朵”，创建场景中它会自动挂载在Main Camera物体上。 AudioSource（声音源组件）在Unity3D中是通过Audio Source这个声音组件来播放声音的，在任何一个物体（gameobject）上都可以直接挂在这个Audio Source组件。 AudioClip：拖入音频AudioClip文件 Output：音频剪辑通过音频混合器输出; Mute：是否静音； Play On Awake：是否自动播放（如果这个组件时通过代码添加上的，而不是一开始就有的，不会自动播放，需要使用AudioSource.Play()来播放） Loop：是否循环播放 Priority：当场景中有多个音频共存时，设定的优先级播放 Volume：音量大小 代码控制使用代码设置音频和对音频的控制需要先获取AudioSource组件。 1234567891011// 获取AudioSouce组件AudioSource audioSource = transform.GetComponent&lt;AudioSource&gt;();// 控制音频audioSource.clip = clip; // 设置clipaudioSource.volume = 0.5f; // 设置音量大小audioSource.loop = true; // 设置循环播放 audioSource.Play(); // 开始播放audioSource.Stop(); // 停止播放audioSource.Pause(); // 暂停播放audioSource.UnPause(); // 继续播放 独立的音频管理器（生存之战音频管理器为例）需求分析需要控制的音频比较少时可以直接在物体自身的脚本中获取AudioSource组件进行控制，但如果需要控制的音频比较多时，或想后期修改音频逻辑时，需要重新打开对应的脚本比较复杂。将和音频控制相关的代码封装了独立的脚本会方便很多。需求点： 管理器必须是单例模式，方便在项目中随处使用该类的功能； 直接持有和管理几十个甚至几百个音频资源； 可以实现传递音频资源名，然后在某个位置播放音频； 可以实现动态的给某个游戏物体添加音频组件，配置音频组件相关属性； 还要提高音频管理器的“易用性”，规范音频资源命名，方便快速找到需要的资源。 导入音频将所有音频资源导入「Resources」文件夹中 脚本编写创建音频资源枚举使用资源名称枚举可以方便我们使用对应的音频时快速找到需要的音频资源，枚举值和音频资源名要一一对应 1234567891011public enum ClipName&#123; /// &lt;summary&gt; /// 野猪攻击音效. /// &lt;/summary&gt; BoarAttack, /// &lt;summary&gt; /// 野猪死亡音效. /// &lt;/summary&gt; BoarDeath&#125; 创建AudiosManager.cs，加载音频资源123456789101112131415public static AudiosManager Instance; // 单例private AudioClip[] audioClip;private Dictionary&lt;string, AudioClip&gt; audioClipDic;void Awake()&#123; Instance = this; audioClipDic = new Dictionary&lt;string, AudioClip&gt;(); audioClip = Resources.LoadAll&lt;AudioClip&gt;("Audios/All/"); // 把所有音频添加到字典中去 for (int i = 0; i &lt; audioClip.Length; i++)&#123; audioClipDic.Add(audioClip[i].name, audioClip[i]); &#125;&#125; 将该类定义为单例模式 使用Resources.LoadAll&lt;&gt;()加载所有AudioClip，得到一个AudioClip数组 将资源数组遍历存储到一个字典结构中 音频播放方法1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 通过名字获取音频资源/// &lt;/summary&gt;public AudioClip GetAudioClipByName(ClipName clipName)&#123; AudioClip tempClip; audioClipDic.TryGetValue(clipName.ToString(), out tempClip); return tempClip;&#125;/// &lt;summary&gt;/// 在指定位置播放音频/// &lt;/summary&gt;public void PlayAudioClipByName(ClipName clipName, Vector3 pos)&#123; AudioSource.PlayClipAtPoint(GetAudioClipByName(clipName), pos);&#125;/// &lt;summary&gt;/// 给游戏物体添加音频组件来播放音频/// &lt;/summary&gt;public AudioSource AddAudioSourceComponent(ClipName clipName, GameObject go, bool playOnAwake = true, bool loop = true)&#123; AudioSource audioSource = go.AddComponent&lt;AudioSource&gt;(); audioSource.clip = GetAudioClipByName(clipName); if (playOnAwake) audioSource.Play(); audioSource.loop = loop; return audioSource;&#125; 在其他脚本中使用AudioManger.cs需要先查找持有这个脚本的引用，调用该管理器内的方法 12AudiosManager.Instance. PlayAudioClipByName(ClipName.BoarInjured, transform.position); 参考资料： 关于Unity中3D声音的使用]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[降噪耳机Bose-QC-30使用体验]]></title>
    <url>%2Fpost%2FBose-QC-30.html</url>
    <content type="text"><![CDATA[这是我买的第一款“主动降噪”耳机，本文谈谈对 QC-30 这款产品的使用体验。 写在前面在买一款耳机之前，买过至少10条以上还不错的耳机。目前还在使用的有，1条小米平头耳机、2条“入耳式耳机”（分别是AKG和小米活塞耳机）、一个不知名的运动耳机、一个头戴式耳机（Sony 1AbT）。我并不是一个耳机发烧友，有HIFI音质没有很大的追求，但喜欢在不同的使用场景下使用合适的耳机。 18年底到19年初这段期间听了比较多的播客，就一直想买一款「分体式耳机」，也就是商家标称的「真·无线耳机」，以AirPorts为参考，考虑过小米AirDots、小米蓝牙耳机Air，另外还有 QCY T1，漫步者 W2等小众品牌，但考虑到颜值问题，还是优先考虑小米的两款。（值得一提的时候，小米AirDots就是Qcy T1的贴牌产品，只是换了外观设计）。但小米的这两款蓝牙耳机一直买不到，无论是线上还是在小米之家，后来想着就入手一款降噪耳机。 目前，主流的降噪耳机分3种，一种是「分体式耳机」，一种是「项圈式耳机」，一种是头戴式耳机（Sony WH-1000XM3、Bose Qc35）。考虑到自己已经有一款头戴式耳机，就只有「项圈式降噪耳机」了，千元以后的有「Sony Wi-1000x」、「Bose QC-30」，百元以内的有「DyPlay ANC30（￥279）」。前几天的晚上，逛闲鱼的时候发现有人在卖全新未拆封的 QC-30 ，直接砍了50元后，以1200元的价格买了。 外观与佩戴 Bose QC-30 的简单一点描述就是一个「项圈」，采用半圈形的结构，让耳机直接挂在脖子上，能在一定程度上提升耳机的佩戴舒适度。项圈部分采用”类肤质“的材料、耳塞外部是金属材料、按键控制是硬塑料，鲨鱼鳍耳塞是软硅胶材质的。整体来看，产品在设计风格、材料选择方面都比较协调，统一。再说一说细节部分，仔细看耳机，我都不敢相信这做工是2000价位的耳机，与Sony的做工（细节把控）有点差距，如项圈有些部分的胶并没有粘好，使用一段时间或出汗可能会导致脱胶、鼓包等问题。 因为耳式项圈部分采用了类肤质的材料，所以直接把耳机与皮肤接触并没有什么不适，长时间佩戴甚至会忽视它的存在。当穿上有领的衣服时，项圈还可以直接放在领子的外面。佩戴上另一个非常难受的问题，项圈戴久之后，项圈的位置会变歪，对强迫症来说非常难受呀！不得不过几十分钟就要把它手动放正。 另外一个关键的问题时耳塞的的舒适度。得益于Bose 独家的鲨鱼鳍耳塞，半入耳式的设计能让做到长时间佩戴都很舒适，而且怎么甩耳机都不会从耳朵里溜出来。解决了平头耳机容易掉，耳塞式耳机的堵耳，头戴式耳机夹眼镜夹耳等问题。 连接耳机QC-30支持蓝牙4.2连接，不支持LDAC以及aptX。蓝牙连接设备没什么好说的，QC-30还支持NFC连接的，但经过我多次测验，无论是通过手机NFC还是 Sony-A30 的 NFC 都无法正常连接，只能通过手动点击蓝牙连接。当然，耳机开机时如果手机的蓝牙时打开的，耳机会自动连接手机，连接的速度还是挺快的。 连接好APP后，可以拖动中间的滑动条调节降噪的等级，支持11级调节。左下角的连接蓝牙标志可以进行蓝牙连接，往右边的是Bose 音乐分享功能，介绍说时能在两台Bose设备之间无线传输音频，可惜我只有一台 Bose设备，最右边的时蓝牙当前的剩余电量。最下面的播放播放控制，这个控制可以接管连接上设备的音频控制权。比如 网易云音乐 或是 Spotify 播放音乐，或是连接上的其他播放器（Sony-A30）也可以控制。 Bose-QC-30 可以同时连接两台设备，但是使用体验并不是很好。 同时连接 Sony-A30 和手机，并使用 Sony-A30 播放音乐时，如果手机上要播放音频，需要先暂停 Sony-A30上的播放，否则手机播放没有声音。 同时连接 PC 和手机，使用 PC 播放音乐，如果手机接到任何通知或要播放声音，会中断当前音乐的播放，过一会又继续播放。 注意：在使用 Win10 连接耳机时，需要先连接手机，打开 Bose Connect ，点击蓝牙-连接新设备，再使用 Win10 搜索蓝牙设备连接 Bose QuietControl 30。 降噪表现降噪是这款耳机最主要的功能，降噪分为两种。一种是被动降噪，一种是主动降噪。对于第一种，更恰当地说是隔音，戴海绵耳塞、头戴耳机式。 被动式降噪耳机利用物理特性将外部噪声与耳朵隔绝开，主要通过隔声材料阻挡噪声，对高频率声音非常有效，一般可使噪声降低大约为15-20dB。 而主动降噪不只是简单地物理材料隔音 主动降噪的原理在于首先要收集噪音的波型特点，然后通过内置的处理芯片运算出反相的波，再通过高还原度扬声器相抵消。所以主动降噪系统必备的设备有拾音器、处理芯片、扬声器，每一个部分都要保证高质量才能达到最终的效果，故成本上就要比传统非降噪设备高。 Bose QC-30 一个特色式支持11档地「可控降噪」，可以满足在不同场景地使用需求。在嘈杂的食堂、公交、地铁上可以将降噪全开。而在需要与人交谈的时候，可以把通过线控的方式将降噪级别降低，当前我还是建议把耳机取下来再与人交谈，一是方便，二是对别人的尊重。 将降噪开到最高时，即使播放音乐，也会感觉少了很多嘈杂的声音，这些声音在没有戴降噪耳机之前不会有明显的感觉，当我把降噪耳机取下来之后，各种中频、低频的噪音「扑耳而来」，用了降噪耳机之后怕是再也回不去不用降噪耳机的时候了。 对人声的降噪情况，如果有人在你身边讲话时，还是可以清楚听清说话的声音，但是人声会有明显的变化。 Bose QC 30 并没有明显的底噪（电流声），如果旁边有手机或其他设备在充电可以听到明显的电流声。如果衣服摩擦耳机的线，会有一点点的听诊器效应。 如果使用场景有风，QC-30会有很大的风噪音，可能是拾音器又加大风声。 总的来说，QC30的降噪表现还是延续了Bose家族一如既往的高水准，比市面上很多同类型的降噪耳机效果要更优秀一些。对近距离的高频噪音和人声不能屏蔽掉，但开启降噪再用小音量放一些音乐就可以做好普通耳机需要很大音量才能隔绝噪音的效果。 音乐表现到了玄学的音效的环境，对于音质不是特别敏感的耳朵来说，Bose QC30 的音效还是能过的去的。网上的评测大都说不如 Sony WI-1000x 听感好，我没有自己听过 Sony Wi-1000x ，所以不好下判断。更何况音质这东西见仁见智，耳朵适应一段时间一般都会适应。 （各频段音乐表现待一段时间的使用之后再补充） 续航官方参数：充满电可以使用10个小时，充满电需要2个小时（实际体验2h20min） 参考： Bose-QC-30_官方介绍 平价真无线耳机们到底好用不好用【值不值得买第307期】 破解”听不见”的秘密 降噪耳机技术浅谈 BOSE QC30无线消噪耳机体验]]></content>
      <categories>
        <category>新玩具</category>
      </categories>
      <tags>
        <tag>耳机</tag>
        <tag>体验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「故事」读书笔记]]></title>
    <url>%2Fpost%2FStory-Notes.html</url>
    <content type="text"><![CDATA[罗伯特·麦基的《故事》中摘录的笔记 Part 1 故事 故事是人生必需的设备。 娱乐即使沉浸于故事的仪式之中，达到一种知识上和情感上令人满足的目的。 凡是优秀的电影、小说、戏剧，都能通过其各不相同的喜剧和悲剧色彩来达到娱乐的目的，给观众一种具有感染力的生活模式。（电子游戏亦是如此） 故事并不是对现实的逃避，而是一种载体，承载着我们去追寻显示、尽最大的努力挖掘出混乱人生的真谛。 故事艺术是世界上主导的文化力量，而电影艺术则是这一辉煌事业的主导媒体。 创作者的技巧并不是什么手艺的东西，只不过是他对所遇到的每一部小说、电影或戏剧中故事要素的无意识吸收。 创造故事必须深入地挖掘生活，找到新地见解、新版本的价值和意义，然后创造出一个故事载体。 一个好故事使一部好影片成为可能，如果故事不能成立，那么影片必将成为灾难。 所有的故事，无论真诚还是虚假，明智还是愚蠢，都会忠实地映现出作者本人，暴露出其人性…..或人性地缺乏。 每一门艺术都是由其根本形式决定地。故事地普遍形式使其作品成为一个故事，而不是肖像画或艺术拼贴。 一个作家必须掌握故事形式，但形式并不是“公式”，故事是丰富多彩、纷繁复杂、神妙莫测的。 故事是生活的比喻 一个讲故事的人即是一个生活诗人，一个艺术家，将日常生活事件、内在生活和外在生活、梦想和现实转化为一首诗，一首以事件而不是以语言作为韵律的诗一个长达两小时的比喻，告诉观众:生活就像是这样！因此，故事必须抽象于生活，提取其精华，但又不能成为生活的抽象化，以致失却实际生活的原味。故事必须像生活，但又不能一成不变地照搬生活，以致除了市井乡民都能一目了然的生活之外便别无深度和意味。 电影美学是表达故事生动内容的手段，其本身绝不能成为目的。 Part 2 ：故事的要素 ​ 节拍构成场景，场景构成序列，序列构成幕，幕构建成故事，最后达到高潮。 节拍是场景里面最小的结构成分。 场景是再某一相对连续的时空中，通过冲突表现出来的一段动作，这个动作至少是让人生的生活负荷发生转折。理想的场景是一个故事事件。 序列是一系列场景——一般是两到五个，每一个场景的冲击力呈递增趋于，直到最后到达顶峰。 幕是一系列序列的组合，以一个高潮场景为顶点，导致价值的重大转折。 高潮：故事是一系列幕的组合，渐次构成一个最后的幕高潮。引发出绝对不可逆转的变化。 总结：场景导致较小而有意义的变化，序列中的终结场景的变化更强劲、具有决定性的变化，而幕导致的价值转折比场景和序列中的冲击力更强。场景、序列、幕中的变化都是可以逆转的，但是最后一幕的高潮是不可逆转的。 故事三角故事经典设计： 经典设计是指围绕一个主动主人公构建的故事，主人公为了追求自己的欲望，与主要来自外界的对抗力量进行抗争，通过连续的时间、在一个连贯而具有因果关联的虚构现实里，到达一个表现绝对、而变化不可逆转的闭合式结局。 我们的故事大部分都是这样的经典设计的。被麦基成为大情节故事，但是这种形式并不是故事讲述形态的极限。与之不同的，有小情节和反情节，如图： 最小主义是指作者从经典设计的成分开始，对它们进行削减—对大情节的突出特性进行精炼、浓缩、删节或修剪。小情节并不意味着无情节，其故事必须像大情节一样给予精美的处理。确切地说，最小主义的情节处理是要在简约、精炼的前提下保持经典的精华，使影片仍然能够满足观众。 反情节是反小说（新小说）和荒诞派戏剧的电影翻版。反结构变体并没有削减经典，而是反其道而行，否认传统形式，以利用甚至嘲弄形式原理的要义。反情节的制造者对欲语还休的描写方法或暗度陈仓式的收敛几乎没有兴趣；相反，为了昭示他的“革命”雄心，他的影片倾向于过度铺陈和自我意识的大肆渲染。 闭合式结局 VS 开放式结局 如果一个表达绝对而不可逆转变化的故事高潮，回答了故事讲述过程中所提出的所有问题并满足了所有观众情感，则被称为闭合式结局。 一个故事高潮如果留下一两个未解答的问题和一些没被满足的情感，则被称为开放式结局。 外在冲突 VS 内在冲突 大情节强调外在冲突。尽管人物常常具有强烈的内心冲突，但重点却落在他们与人际关系、社会机构或自然界力量的斗争上。 在小情节中，主人公也许与家庭、社会和环境具有强烈的外在冲突，但其重点却集结在他与自己思想情感有意或无意的角斗里。(内在冲突即内心冲突) 单一主人公 VS 多重主人公 如果是单一主人公，则影片中所有的事件变化都围绕主角。 如果作者将影片分解成若干较小的次情节，每一个次情节都有一个单一主人公。 主动主人公 VS 被动主人公 主动主人公在欲望追求中采取行动时，与他周围的人和世界发生直接冲突。 被动主人公表面消极被动，而在内心追求欲望时，与其自身性格的方方面面发生冲突。 线性时间 VS 非线性时间 无论有无闪回，一个故事的事件如果被安排成一个观众能够跟踪的时间顺序，那么这个故事便是按照线性时间来讲述的。 如果一个故事在时间中随意跳跃，从而模糊了时间的连续性，以致观众无从判断什么发生在前什么发生在后，那么这个故事便是按照非线性时间来讲述的。 因果 VS 巧合大情节因果性强，反情节常常以巧合代替因果，强调宇宙万物的随意碰撞。 连贯现实 VS 非连管现实 连贯现实是确立人物及其世界之间互动模式的虚拟背景，在整个讲述过程中，这些互动模式一直保持着连贯性，从而创造出意义。 非连贯现实是混合了多种互动模式的背景，其中故事章节不连贯地从一个“现实”跳向另一个“现实”，以营造出一种荒诞感。 未完….]]></content>
      <categories>
        <category>reading-list</category>
      </categories>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Scrapy爬虫抓取并下载豆瓣图片]]></title>
    <url>%2Fpost%2Fcrawl-douban-image-by-scrapy.html</url>
    <content type="text"><![CDATA[上一篇笔记我直接自己写了一个Python来抓取豆瓣图片，为了让我更加熟悉Scrapy，我又用Scrapy做了一遍。 网站分析直接参考上一篇的目标和网站分析。 工具分析 需要添加一个自己的下载图片的Item Pipeline。 爬虫程序创建一个新的Scrapy项目12scrapy startproject db_img_crawlerscrapy genspider dbimg htpp://douban.com 编写items.py123class ImagesItem(scrapy.Item): image_title = scrapy.Field() # 图片的标题 image_url = scrapy.Field() # 图片的地址 编写主Spider文件，dbimg_crawler.py12345678910111213141516171819202122232425262728import scrapyimport jsonfrom doubanimg.items import ImagesItemfrom scrapy import Requestfrom requests import requestclass DbimgSpider(scrapy.Spider): name = 'dbimg' def start_requests(self): headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36',&#125; for i in range(0,300,20): url = 'https://www.douban.com/j/search_photo?q=%E7%8E%8B%E7%A5%96%E8%B4%A4&amp;limit=20&amp;start=' + str(i) yield Request(url,callback=self.parse_one) def parse_one(self, response): item = ImagesItem() images = json.loads(response.body.decode('utf-8')) images = images['images'] for i in range(0,len(images)): item['image_title'] = images[i]['title'] image_id = images[i]['id'] item['image_url'] = 'https://img3.doubanio.com/view/photo/l/public/p'+str(image_id)+'.webp' # print(item) yield item 直接在start_requeset()中开启循环抓取，方法yield Request，回调给parse_one()抓取每一次的20条数据。 图片的地址同时是由获取到的id值来组拼成的。 编辑piepelines.py123456789101112131415161718192021import scrapyfrom scrapy.pipelines.images import ImagesPipelinefrom scrapy.exceptions import DropItemclass MyImagePipeline(ImagesPipeline): def get_media_requests(self, item, info): yield scrapy.Request(item['image_url'], meta=&#123;'item':item&#125;) def file_path(self, request, response=None, info=None): # item = response.meta['item'] name = 'full/%s' % ((request.url.split('/')[-1]).split('.',1)[0]) + '.jpg' return name def item_completed(self, results, item, info): path = [x['path'] for ok,x in results if ok] if not path: raise DropItem('Item contains no images') print('Saving img...',item['image_url']) print('title',item['image_title']) return item 创建自己的Item Pipeline，继承ImagesPipeline(图片管道)，这个管道的特性有： 将所有下载的图片转换成通用的格式（JPG）和模式（RGB） 避免重新下载最近已经下载过的图片 缩略图生成 检测图像的宽/高，确保它们满足最小限制 要下载图片，需要重写get_media_requests()方法，方法内对图片URL返回一个Request。（默认返回None，表示没有图可下载）要想传递item对象可以把它写在request的meta里面。当下载完成之后，由管道接起，传递到item_completed()方法内。 如果想设置文件的名字，可以重写file_path()，可以通过item = response.meta[&#39;item&#39;]来接受item对象。 编辑Setting.py1234567891011121314151617181920212223242526272829设置HeaderDEFAULT_REQUEST_HEADERS = &#123; 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding':'gzip, deflate, sdch', 'Accept-Language':'zh-CN,zh;q=0.8', 'Cache-Control':'max-age=0', 'Connection':'keep-alive', 'User-Agent':'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36'&#125;# 图片存储路径IMAGES_STORE = 'D:\\img'# 爬虫协议ROBOTSTXT_OBEY = False# 最大Requests数CONCURRENT_REQUESTS = 16# 下载延时DOWNLOAD_DELAY = 1# 关闭CookiesCOOKIES_ENABLED = False# 开始MyImagePipelineITEM_PIPELINES = &#123; 'doubanimg.pipelines.MyImagePipeline': 1,&#125; 启动爬虫程序1scrapy crawl dbimg 参考链接： 下载项目图片-scrapy中文文档]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓取豆瓣搜索到的图片]]></title>
    <url>%2Fpost%2Fcrawl-douban-image-and-download.html</url>
    <content type="text"><![CDATA[使用Python抓取和周迅有关的图片并下载到本地。 目标豆瓣搜索“周迅”的相关图片，并且下载到本地 网站分析豆瓣图片是通过Ajax动态加载的，按F12打开Chrome浏览器的开发者工具，图片是通过GET来请求的，请求地址： 1https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;limit=20&amp;start=0 其中：【q=：关键字| limit=：一次请求的数量（修改了也没用） | start=：请求的开始位置（偏移量）】。点开Preview，看到网站给我们发送了一个20个长度的json数据包 点开第一个，这里面有几个key，我们需要的是图片的url，另外还可以存储图片的title。这里面可以看到有两个url，分别是scr和url。 把它们全部在地址栏打开，发现这个scr链接是图片的缩略图地址，这个url链接是图片post的主页地址。这两个都不是我们想要的，但是可以右键看一下图片的真实地址 复制出来图片的地址，观察到图片的命名就是上面接受的id值，这样我们就可以通过获取每张图片的id值来组拼出图片的下载地址了。 1https://img3.doubanio.com/view/photo/l/public/p637462204.webp 完整的爬取定义Header，图片的存储地址，保存抓取到的图片item 12345678910dir = './image' # 图片地址imageItemList = [] # 用列表存储所有的图片item（字典）headers = &#123; 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding':'gzip, deflate, sdch', 'Accept-Language':'zh-CN,zh;q=0.8', 'Cache-Control':'max-age=0', 'Connection':'keep-alive', 'User-Agent':'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36' &#125; 获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中1234567891011121314151617import requestsimport jsondef get_img_url(): ''' 获取图片的url下载地址 ''' for i in range(0,300,20): url = 'https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;limit=20&amp;start=0' response = requests.request('Get', url,headers=headers) images = json.loads(response.content.decode('utf-8'))['images'] for j in range(0, len(images)): imageItem = &#123;&#125; imageItem['title'] = images[j]['title'] id = images[j]['id'] imageItem['url'] = 'https://img3.doubanio.com/view/photo/l/public/p'+str(id)+'.webp' imageItemList.append(imageItem) 通过For循环获取，range(0,300,20)，表示要获取的图片数量为300张，Sep（步长）为20，因为每次获取的是20条数据。 通过response.content，获取response返回的内容，之前用response.body提示错误。这个应该是scrapy自己封装的属性。 通过json.loads()把json对象转换成Python对象，这样方便Python去解析。 图片的url是通过id值来组拼的。 从列表获取图片链接并下载图片，然后使用dwebp工具转换图片格式 1234567891011121314151617181920212223242526272829def request_download(url, path): ''' 下载文件的方法 ''' r = requests.get(url) with open(path, 'wb') as f: f.write(r.content)def download_img_from(): ''' 从数组中取出所有图片链接并下载，下载后使用dwebp转换图片格式为png，并删除dwebp源图片 ''' index = 1 # 判断是否电脑中是否有此目录，如果没有则创建一个空目录 if not os.path.exists(dir): os.mkdir(dir) for item in imageItemList: url = item['url'] fullpath = dir +'/'+ str(index) + '.webp' # 调用下载方法 request_download(url, fullpath) try: print('开始转换第'+str(index)+'张图片：') os.system('dwebp ./image/%d.webp -o ./image/%d.png' %(index,index)) print('转换第'+str(index)+'张图片完成.') os.remove('./image/'+str(index)+'.webp') #删除webp格式的图片 except Exception as err: print(err) index += 1 从上面的图片item中获取每张图片的url，调用下载方法。 注意：这里获取下载的图片是webp编码的，需要使用dwebp工具进行转换。 WebP（Google开发），是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，派生自影像编码格式VP8。在同样大小的图片文件中，能比其他格式更加清晰，能提高网页加载速度，减少网络存储。 安装webp工具直接在scoop中搜索安装（libwqbp）即可，还可以直接去google的webp地址去下载安装，安装完成之后，把安装路径里面bin文件夹路径添加到环境变量中去。 使用webp1dwebp *.webp -o *.png # 第一个是webp文件名，第二个是转换后的png文件名。 启动爬虫程序 先调用爬取路径的方法，再调用下载文件的方法。 123if __name__ == "__main__": get_img_url() download_img_from() 启动爬虫]]></content>
      <categories>
        <category>clawl</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Item Pipeline把Scrapy爬取的数据存储到MongoDB]]></title>
    <url>%2Fpost%2FScrapy-To-MongoDB-By-Pipeline.html</url>
    <content type="text"><![CDATA[使用Item Pipeline(项目管道)来保存使用Scrapy爬取的item对象 Pipeline是什么 当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。 每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。 ——Scrapy Doc item pipeline的功能： 清理HTML数据 验证爬取的数据(检查item包含某些字段) 查重(并丢弃) 将爬取结果保存到数据库中 在pipeline.py中编写MongoDBPipeline123456789101112131415161718192021222324252627from scrapy import Itemimport pymongoclass MonoDBPipeline(object): ''' 将item写入到MongoDB中 ''' @classmethod def from_crawler(cls, crawler): # 访问配置文件取mongodb的url和name，如果没有则使用默认值 cls.DB_URL = crawler.settings.get('MONGO_DB_URI', 'mongodb://localhost:27017') cls.DB_NAME = crawler.settings.get('MONGO_DB_NAME', 'scrapy_data') return cls() def open_spider(self, spider): self.client = pymongo.MongoClient(self.DB_URL) self.db = self.client[self.DB_NAME] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): collection = self.db[spider.name] # 三元表达式（调用前先对item的类型进行判断，如果item是Item对象，就将其转换为字典) post = dict(item) if isinstance(item, Item) else item collection.insert_one(post) return item from_crawler(cls, crawler) 如果存在，则调用这个类方法来从爬行器创建管道实例。它必须返回管道的新实例。爬虫对象提供对所有Scrapy核心组件的访问，如设置和信号；它是管道访问这些组件并将其功能挂钩到Scrapy的一种方式。 cls（item pipeline类）（如果创建MongoDBPipeline类就为MongoDBPipeline类对象 crawler（Crawlerobject） - 使用此管道的crawler（可以通过crawler.settings访问该配置setting.py文件） open_spider() &amp; close_spider()在Spider整个爬取过程中，数据库的连接和关闭操作只需要进行一次，应在开始处理数据之前连接数据库，并在处理完所有数据之后关闭数据库，因此实现以下两个方法(在Scrapy打开和关闭时被调用)。 process_item(self, item, spider) 每个项目管道组件是一个Python类，必须实现以下方法： process_item(self, item, spider)； 对于每个项目管道组件调用此方法。process_item() 必须：返回一个带数据的dict，返回一个Item （或任何后代类）对象，返回一个Twisted Deferred或者raise DropItemexception。 在process_item中实现MongoDB数据库的写入操作，使用self.db和spider.name获取一个集合(collection)，然后将数据插入该集合。 在配置文件中配置MongoDB的url和name打开Setting.py在任何位置写入（如果不写则默认使用MongoPipeLine.from_crwaler()中的信息）： 12MONGO_DB_URI = 'mongodb://localhost:27017'MONGO_DB_NAME = 'python_ZhuanLan' 启动MongoPipeline组件打开Setting.py，把MongoPipeline添加到ITEM_PIPELINES中，后面的数字代表它们的运算优先级（顺序），item按数字从低到高的顺序，通过pipeline（1-1000，数字越低组件的优先级越高）： 123ITEM_PIPELINES = &#123; 'zhihu_Crawl.pipelines.MonoDBPipeline':300,&#125; 参考资料： Scrapy使用Pipeline写入MongoDB Scrapy中文文档-Item Pipeline]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Crawler</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Scrapy遇到的问题汇总]]></title>
    <url>%2Fpost%2FThe-Problem-Collection-Use-Scrapy.html</url>
    <content type="text"><![CDATA[简单记录一下，自己再安装和使用Scrapy框架过程中遇到的各种问题及解决办法 安装使用环境：Win10 1803、Python 3.6.3 利用pip命令可以直接安装Scrapy，但是会出现一些安装包装不上而报错，比如Twisted。可以先去这个Pyhton Extension Packages下载Twisted到本地，然后单独安装 1pip install twisted （注意要下载Twisted‑18.9.0‑cp36‑cp36m‑win_amd64.whl不要下载错了，是cp36。否则安装的时候会提示is not a supported wheel on this platform） Scrapy输出文件编码为’utf-8’在编写爬虫中文内容输出到*.json文件后发现中文是Unicode编码，尝试了各种方法测试都不成功，后来找到一种方法终于成功了，把Scrapy项目文件夹中的Setting.py增加一行配置： 1FEED_EXPORT_ENCODING = 'utf-8' Scrapy导出csv文件乱码使用Vscode的通过编码重新保存，将文件的编码格式改为UTF-8 with BOM，再重新用Excel打开csv就正常了。 参考：https://blog.csdn.net/u011361138/article/details/79912895 Scrapy异常：http status code is not handled or allowed原因是http状态码没有被识别，需要在settings.py中添加这个状态码信息，同样在Setting.py添加一行（如果是404错误就改为404，如果是400错误，就改成400： 123HTTPERROR_ALLOWED_CODES = [状态码]HTTPERROR_ALLOWED_CODES = [404]HTTPERROR_ALLOWED_CODES = [400] 另一种方法是在Spider函数中添加 12handle_httpstatus_list = [404]handle_httpstatus_list = [400] 如果还是出现400错误问题，我观察到后面的Debug信息是：*/robots.txt。 robots.txt（爬虫协议)是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。——wiki 知乎robots地址：https://www.zhihu.com/robots.txt 淘宝robots地址：https://www.taobao.com/robots.txt 总结来说这个爬虫协议允许爬虫机器爬取的范围，不过这个协议属于君子协议，Scrapy默认是遵循robot协议，需要在Setting.py中改变ROBOTSTXT_OBEY的值为False。 在做了上面的设置之后还是400错误，可以给Reaqueset请求添加一个Headers头部，可以让爬虫伪装成浏览器 1234567headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36',&#125;def start_requests(self): url = 'http://www.hnfnu.edu.cn/index/xyxw/342.htm' # 这样就不要设置Start_urls变量了 yield Request(url, headers=self.headers) 不过在我今天在爬去知乎专栏的文章（Ajax加载），调试了很久也只能抓取到第一次加载的列表内容，检查了后面的yiled Requeset(url, callback=self.parse) 设置没有问题，然后我把Headers信息添加在Setting.py中问题就解决了： 123DEFAULT_REQUEST_HEADERS = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36',&#125; 未完待补充……]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xlua热补丁修复]]></title>
    <url>%2Fpost%2Fxlua-hotfix.html</url>
    <content type="text"><![CDATA[使用xlua热补丁修复 在使用Ulua方法进行热更新的时候，在项目的开发阶段就必要用独立的Lua脚本实现，这样才能使用Ulua来进行热更新，但是如果一个项目完成之后发现需要进行热更新，这个时候用ULua就非常不方便了。但是XLua可以解决这个问题，解决方案就是“HotFix”热补丁。（对项目进行修补）实现方式： 对要进行“修补”的C#类，在该类的头部[Hotfix]标签来标记，对于已经使用了[hotfix]标记了的类，可以通过“Lua”代码修改“类中的方法”。 使用HotFix进行热修复环境准备添加宏信息 File–&gt; Build Settings… –&gt; Player Settings… –&gt; Configuration：Scripting Define Symbols：HOTFIX_ENABLE；（对于每一个平台都需要添加这条宏信息！） 执行菜单生成命令XLua-&gt;Generate Code，该命令执行完毕后会生成一堆Wrap 文件，存放到XLua/Gen 文件夹下。 执行菜单注入命令XLua-&gt;Hotfix Inject In Editor，成功之后，会在控制台输出：“hotfix inject finish!”或者“had injected!”。 如果出现红色警告提示“please install the Tools”，就需要把Tools 文件夹拷贝到项目中，和Assets 文件夹同级别位置。 只要修改过C#中的代码，就需要重新执行注入命令！（否则会报错） HotFix热修复案例Hotfix语法 引入命名空间：using Xlua; 对要进行热修复的C#类用【hotfix】标记 编写hotfix命令：xlua.hotfix(CS.类名, &#39;方法名&#39;, lua 方法)（对于CS.类中的某个方法使用lua方法修复） 创建XLua虚拟机对象（Lua解析器），使用Dostring方法执行。 修复案例123456789101112131415161718192021222324252627282930313233343536373839using UnityEngine;using XLua;[Hotfix]public class HotFixDemo : MonoBehaviour &#123; private LuaEnv luaEnv; private string hotfixStrOne = @" xlua.hotfix(CS.HotFixDemo, 'Hello', function() print('Lua Hello~~') end) "; private string hotfixStrTwo = @" xlua.hotfix(CS.HotFixDemo, 'Add', function(self, a, b) print('Lua中的乘法:' .. a*b) end) "; void Start () &#123; luaEnv = new LuaEnv(); &#125; void Update () &#123; if(Input.GetKeyDown(KeyCode.A))&#123; Hello(); Add(5, 2); &#125; if (Input.GetKeyDown(KeyCode.Space))&#123; luaEnv.DoString(hotfixStrOne); luaEnv.DoString(hotfixStrTwo); &#125; &#125; private void Hello()&#123; Debug.Log("C# Hello~~");&#125; private void Add(int a, int b)&#123; Debug.Log("C#中的加法：" + (a + b));&#125;&#125; 有参方法修复时，需要传递当前脚本对象this，在lua 中用self 代替。 要修复无参的方法，但是那个方法内使用到了该类中的字段，如果想要在Lua代码中方法到，有两种方法： C#类中的字段公开（使用Public修饰），在lua代码中通过self.字段名的方式来方法（破坏了C#语言的“封装性”） 在lua 语言中，使用代码获取C#类中private 成员的访问权xlua.private_accessible(CS.类名)，这样就可以在Lua 脚本中访问到C#类当中的私有成员，同时不会破坏C#原有的封装性和逻辑关系。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>热更新</tag>
        <tag>xLua</tag>
        <tag>Untiy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleFrameWork框架简单介绍]]></title>
    <url>%2Fpost%2FSimpleFrameWork-Introduction.html</url>
    <content type="text"><![CDATA[SimpleFramework的框架介绍 SimpleFramework 框架SimpleFramework 框架是ULua的集成开发环境 SimpleFramework 框架官网地址： http://www.ulua.org/index.html SimpleFramework 分为两个版本：NGUI 版和UGUI 版，区别是NGUI 版本的框架资源中含有NGUI 这个插件。 SimpleFramework 和ULua和Lua的关系ULua是对原生Lua 环境进行了一次“包装”，用于满足Unity 环境下的热更新需求。为了更方便的使用，于是又对ULua进行“二次包装”，包装成了一个框架：SimpleFramework，比如它们创建Lua的解析器对象都不相同。 Lua：Lua lua = New Lua(); Ulua：LuaState Lua = new LuaState(); SimpleFramework:LuaScriptMgr lua = new LuaScriptMgr(); 它们的关系是：SimpleFramework &gt; ULua &gt; Lua SimpleFramework框架资源结构 Examples：SimpleFramework 热更新案例； Lua：SimpleFramework 框架自带的Lua 源码文件；（自己写的Lua脚本放在这个路径） NGUI：NGUI3.8.2，当你需用更高版本的NGUI 时，替换即可，不需要碰； Plugins：uLua 运行所依赖的底层库文件，不需要碰； Scripts：SimpleFramework 自带的C#脚本文件； uLua：uLua 全部代码。 和Ulua紧密相关的是：Plugins、uLua。和SimpleFramework相关的是：Examples、Lua、Scripts 使用框架框架自带的编辑器命令 Lua菜单：uLua 环境相关处理命令(必备操作) Gen Lua Wrap Files：生成LuaWrap文件 该命令用于生成“Lua 包装文件”，存放在uLua\Source\LuaWrap 目录下。该文件夹下全部是C#脚本，这些脚本文件的名称特点是：脚本名+ Wrap；该文件夹下的脚本对Unity 内常用组件脚本的二次包装，、 Lua 环境运行后，会把这些Wrap 文件加载到Lua 运行环境(Lua 虚拟机)中，最终的效果就是：Lua 调用Wrap 文件，Wrap 文件调用C#，来实现Lua 调用C#。 Clear Lua….. Wrap Files：清除LuaWrap文件，也可以自己手动删除。 Game菜单：Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]Game–&gt;Build Windows Resource 生成Windows 平台下的AB 文件。生成后的AB 会存放到StreamingAssets 文件夹下。在生成的过程中同时还会把Lua 文件夹下的所有脚本拷贝到该目录，存放到lua 文件夹下。 在\Assets\uLua\Editor\Packager.cs脚本中的HandleLuaFile方法就是将/Lua/文件复制到/StreamingAssets/文件夹中（这是本地Server设置的资源的地址，模拟服务器的资源地址） Lua 文件夹结构分析 3rd：第三方的Lua 脚本插件； Common：公共Lua 文件目录； Controller：控制器目录； Logic：管理器目录； System：cstolua 的系统目录； View：视图层目录。 ULua 文件夹结构SimpleFramework 框架项目的核心是uLua，在Unity 环境下使用uLua可以实现Lua 脚本与Unity 内C#脚本的交互，通过Lua 脚本来操作Unity3D内的各种游戏组件。 Core：uLua 核心； Docs：uLua 文档，其实就是LuaInterface 的PDF 使用文档； Editor：uLua 编辑器扩展；[备注：项目内所有的Editor 文件夹都是编辑器扩展文件夹，并不局限于根目录] Examples：uLua 自带演示案例； Source：cstolua 核心目录。 备注：参考：擅码网Lua热更新文档资料]]></content>
      <categories>
        <category>Unity</category>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>ULua</tag>
        <tag>SimpleFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleFramwork框架下Ulua与C#的交互]]></title>
    <url>%2Fpost%2FUlua-And-Charp-Communicate.html</url>
    <content type="text"><![CDATA[在SimpleFramwork框架下，Ulua与C#的交互！ uLua环境下与C#交互（基本操作）在C#与Lua进行交互需要两个DLL文件来实现分别是Luainterface.dll（C#脚本使用Lua）、luanet.dll(Lua脚本调用C#)。因此需要事先把那两个DLL文件拷贝到项目路径中去，再引用。 在uLua 环境下本质也是通过LuaInterface 来实现Lua 与C#语言交互的。但是uLua 对LuaInterface 进行了二次的封装，不需需要自己手动拷贝这个DLL文件，但是的使用的使用还是要引入命名空间：using LuaInterface; Lua 代码与Unity 内的类的交互[反射方式/ 原生方式]1234567891011121314// 定义了一个字符串变量保存Lua代码（调用C#的类和方法来创建了一个游戏物体，并给它添加了一个“BoxCollider”组件） private string str1 = @" luanet.load_assembly('UnityEngine') GameObject = luanet.import_type('UnityEngine.GameObject') BoxCollider = luanet.import_type('UnityEngine.BoxCollider') local player = GameObject('Lemmo') player:AddComponent(luanet.ctype(BoxCollider)) ";// 创建一个Lua解析器对象，并执行上面定义的Lua脚本 void Start()&#123; LuaState lua = new LuaState(); lua.DoString(str1); &#125; luanet 已经被封装到了LuaInterface 命名空间内，所以我们可以在Lua代码中直接使用luanet 这个对象； 在Lua 环境内操作C#中的类创建对象，不要写new 关键字！ 在Lua 环境内操作C#中的类创建对象，访问对象中的方法使用分号（:）； 这种“反射方式”在项目开发中并不常用，但是也有用无之地，真正大量使用的是下方的Wrap 方式。 同样需要在C#代码中引入LuaInterface； 原生的Lua 解析器对象“Lua”被二次封装成了“LuaState”； LuaState 类存在的位置是：uLua\Core\Lua.cs。 Lua 代码与Unity 内的类的交互[Wrap 方式]1234567891011121314 // 和Str1的功能类似，只不过str2使用了Wrap的方式private string str2 = @" luanet.load_assembly('UnityEngine') GameObject = UnityEngine.GameObject BoxCollider = UnityEngine.BoxCollider local player = GameObject('WrapLemmo') player:AddComponent(BoxCollider.GetClassType()) "; void Start()&#123; LuaScriptMgr lua = new LuaScriptMgr(); lua.Start(); lua.DoString(str2); &#125; 说明： 这种是在uLua 开发过程中最常用的方式，95%+情况都是使用这种方式； Wrap 方式实现Lua 调用C#，依赖的是之前生成的LuaWrap 文件； [也就是我们通过菜单自动生成到uLua\Source\LuaWrap 下的脚本文件] 当使用Wrap 方式时，运行Lua 代码需要使用LuaScriptMgr； 需要把AppConst.cs 脚本中的的DebugMode 修改为true。 包装新的Wrap 脚本当我们用Lua 的Wrap 方式访问Unity 中的组件脚本，或者自己写的脚本的使用，如果这些脚本没有自动生成“xxxxWrap”,项目运行后，就会报错。比如在用Wrap的方式给Player对象通过Lua添加Animator组件的时候，就会报错. 12Animator = UnityEngine.Animator player:AddComponent(Animator.GetClassType()) 解决办法：往框架内添加需要处理的新的类。 找到uLua\Editor\WrapFile.cs 打开该脚本，使用该格式进行添加：_GT(typeof(类名)) ； Lua–&gt;Clear LuaBinder File + Wrap File 清空原有的Wrap 文件； Lua–&gt;Gen Lua Wrap Files 重新生成Wrap 文件； 关于Lua使用“.”和“:”来调用属性和方法在Lua语言中，直接调用操作C#中的对象的方法和属性直接使用“.”来调用，如果是在Lua代码中实例化出来的对象，再调用这个对象的方法则需要用“:”]]></content>
      <categories>
        <category>Lua - Ulua</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Lua</tag>
        <tag>热更新</tag>
        <tag>SimpleFramwork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua与Charp交互]]></title>
    <url>%2Fpost%2Flua-with-csharp.html</url>
    <content type="text"><![CDATA[Lua与C#的交互 Lua与C#进行交互在项目中，C#语言是主语言，Lua 语言是辅助语言，如何才能让两门语言的代码互相访问那？这时候我们需要一座“桥梁”来连接两门语言。 LuaInterfaceLuaInterface 就是C#与Lua 语言相连的那座桥梁。LuaInterface 是一个开源的项目工程，内部有两个核心的DLL 文件： LuaInterface.dll：在C#代码中操作Lua 代码需要依赖该文件； luanet.dll：在Lua 代码中访问C#的类库脚本需要依赖该文件。 在项目中配置使用Lua环境 将两个dll 文件拷贝到项目工程中； 项目工程设置“引用”导入LuaInterface.dll； 将两个dll 的属性都设置成“如果较新则复制”（非常重要，如果不引用则会报错） 使用lua解析器对象 引入using LuaInterface;命名空间； 实例化lua解析器对象：Lua lua = new Lua()； 使用lua解析器对象的一些方法。 123456789101112131415using System;using LuaInterface;namespace LuaThree&#123; class Program &#123; static void Main(string[] args) &#123; Lua lua = new Lua(); lua.DoString("print('This is Lua program')"); // 这里执行的是Lua代码 Console.ReadKey(); &#125; &#125;&#125; C#中Lua代码空间分析 实际上，虽然C#代码和Lua代码是在一个脚本文件中，但是在程序执行的时候，lua代码（上面第11代码是放到了Lua的那块空间去的） C#调用Lua代码C#内执行lua代码语法：Lua解析器对象.DoString(&quot;Lua代码&quot;) 示例： 1234567891011121314151617181920Lua lua = new Lua();//1. 变量的声明与访问；lua.DoString("name = 'YangJie' age = 19 gender = 'Man' address = 'HuNan'");Console.WriteLine(lua["name"]);//2. for循环语句；[演示@符号的用途]lua.DoString(@"for i = 1,10,1 do print(i) end ");//3. 函数的定义与调用；lua.DoString(@"function Show() print('Show LuaFunction in Csharp.'); end Show()");//4. table 数组声明lua.DoString(@" MyArray = &#123;'AAA', 'BBB', 'CCC'&#125;"); C#中调用外部的Lua脚本在实际的时候中，大都汇直接调用外部的Lua脚本 语法：Lua解析器对象.DoFile(&quot;[path]fileName.lua&quot;)方法。 创建Lua脚本文件：添加-&gt;新建项-&gt;常规-&gt;文本文件，改名且后缀写为.lua;（注意要用其他的编辑器把编码格式从“UTF-8 BOM”改成 “UTF-8”或“GB2312”(中文编码)，否则会抛异常） 注意：在创建Lua文件之后，在VS里面将该文件的“复制到输出路径”设置为“如果较新则复制”，否则也会抛异常。（无法找到该文件） 示例：MyLua.lua脚本 1234567name = "Yangjie"address = "HuNan"age = 19function Fun() print("Lua脚本内的方法")end C#执行脚本 123456789lua.DoFile("MyLua.lua");string name = lua.GetString("name");string address = lua.GetString("address");Double age = lua.GetNumber("age");Console.WriteLine(name + ".." + address + ".." + age.ToString());LuaFunction luaFunction = lua.GetFunction("Fun");luaFunction.Call(); Lua调用Charp对于C#的项目来说，Lua脚本是作为资源存在资源路径下，我们可以对Lua脚本的进行热更新。而Lua脚本就需要访问C#脚本。在Lua中调用C#脚本需要使用luanet.dll这个类库。 使用步骤： 导入luanet.dll：require &quot;luanet&quot; 获取程序集：luanet.load_assembly(&quot;程序集名&quot;) 获取类型：变量名 = luanet.import_type(&quot;程序集名.类名&quot;) 示例Calc.cs（C#中创建一个类，省略了一些代码） 12345678910111213class Calc&#123; public static string name = "Calc计算器类"; public static int Jia(int a, int b) &#123; return a + b; &#125; public static void Show() &#123; Console.WriteLine("这是Calc内的方法"); &#125;&#125; LuaUpdate.lua脚本 123456require "luanet" -- 导入luanet.dllluanet.load_assembly("LuaThree") -- 导入程序集Calc = luanet.import_type("LuaThree.Calc") -- 导入类print(Calc.Jia(10, 20)) print(Calc.name) Program.cs（只保留了核心代码） 123456Lua lua = new Lua();lua.DoFile("LuaUpdate.lua");// 输出结果：// 30// 这是Calc内的方法 Lua内方法C#的类库导入步骤和上面的几乎类似，比如我想导入Console 12345require "luanet" luanet.load_assembly("System")Calc = luanet.import_type("System.Console")Console.WriteLine("Lua内调用C#的类库") 其他主要资料来自擅码网Lua课程。]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>lua</tag>
        <tag>Charp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪杰特斯拉算法(Dijkstra)]]></title>
    <url>%2Fpost%2FDijkstra's-algorithm-use-python.html</url>
    <content type="text"><![CDATA[迪克斯特拉算法（英语：Dijkstra’s algorithm）是采用了「广度优先搜索」解决在“加权图”中最短路径的问题 理解迪克斯特拉算法使用「广度优先搜索」算法，可以对「非加权图」查词最短路径 但是对于「加权图」的最短路径问题，则需要使用「迪克斯特拉算法」 这个图包括四个顶点（起点、A、B、终点），以及连接这些点的边，边上的数字是一点的另一点的「花销」，或者叫做权重。权重越大，花销就越大，反之，花销就越小。要找到从「起点」到「终点」的最短路径，需要在所有路径中找到「总权重」最小的一条路径。下图是我们任意寻找的一条路径，我们可以用迪克斯特拉算法在所有的路径中找出最短（优）的那条路径。 实现迪克斯特拉算法的步骤 找出“最便宜”的节点（花销最低），即可在最短时间内到达的节点。 更新该节点的邻居的开销。 重复这个过程，直到对图中的每个节点都这样做了。 计算最终路径。 代码实现迪克斯特拉算法需要实现找到图2的最短路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 创建一个散列表来模拟路径图graph = &#123;&#125;# 一条路径采用了两个散列表，例如["start"]表示自身节点、["a"]表示邻居节点， 6 表示自身节点前往邻居节点的花销graph["start"] = &#123;&#125;graph["start"]["a"] = 6graph["start"]["b"] = 2graph["a"] = &#123;&#125;graph["a"]["fin"] = 1graph["b"] = &#123;&#125;graph["b"]["a"] = 3graph["b"]["fin"] = 5graph["fin"] = &#123;&#125;# 创建节点的开销：表示从「起点」出发到该节点需要的“时间”，对于非起始节点的「子节点」我们并不知道它的花销，假设它为无穷大infinity = float("inf") # 表示无穷大costs = &#123;&#125;costs["a"] = 6costs["b"] = 2costs["fin"] = infinity# 创建父节点的散列表parents = &#123;&#125;parents["a"] = "start"parents["b"] = "start"parents["fin"] = None# 记录处理过的节点processed = []# 查找开销最低的节点def find_lowest_const_node(costs): lowest_const = float("inf") lowest_const_node = None for node in costs: cost = costs[node] if cost &lt; lowest_const and node not in processed: # 如果当前节点开销更低且为处理过 lowest_const = cost # 将其视为开销最低的节点 lowest_const_node = node return lowest_const_nodenode = find_lowest_const_node(costs) # 在未处理的节点中找出花销最小的节点while node is not None: # 这个while循环在所有节点都被处理过后结束 cost = costs[node] neighbors = graph[node] for n in neighbors.keys(): # 遍历当前节点的所有邻居 new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: # 如果当前节点前往该邻居更近 costs[n] = new_cost # 则更新该邻居的开销 parents[n] = node # 同时将该邻居的父节点设置为当前节点 processed.append(node) # 将当前节点标记为处理过 node = find_lowest_const_node(costs) # 找出接下来要处理的排名，并循环# 用于显示输出效果 for key,value in costs.items(): print(key + ":" + str(value)) print("\n-----------------\n")for key,value in parents.items(): print(key + ":" + value) 运行结果： 「终点」的父节点是「a」、「a」的父节点是「b」、「b」的父节点是「start」，这样就把这个加权图的最短路径给找出来了。 小结 广度优先搜索用于在非加权图中查找最短路径。 狄克斯特拉算法用于在加权图中查找最短路径。 仅当权重为正时狄克斯特拉算法才管用。 如果图中包含负权边，请使用贝尔曼-福德算法。 参考资料 《算法图解》第7章节]]></content>
      <categories>
        <category>Python</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[生存之战]_背包合成模块制作总结]]></title>
    <url>%2Fpost%2Fthe-inventory-module-of-war-game.html</url>
    <content type="text"><![CDATA[断断续续花了半个月的时间，把《生存之战》背包系统大概做出来了。这也相当于一个大项目的一个较为完整的模块，现在整理一下，也方便以后回顾。 成品 项目介绍 整体上这属于一个背包系统，包括1的「背包模块」和2「合成模块」 背包模块背包模块比较简单，由一个整体的背景，背包背景子层生成固定数量的背包框，背包物体动态生成，数据是从Json的数据进行解析。 合成模块合成模块相对比较复杂一点，整个上分为3个相对独立的部分（2.1和2.3在搭建UI层次的时候可以先分为一个，然后在拆分成2.1 和 2.3） 2.1是合成的类型，比如武器类可以有弓箭、长矛；而建筑类可以有窗户、门。 2.2是具体的合成物品的种类，比如上面提到的弓箭、长矛等。 2.3是某个物品的合成图谱，也就是说合成这个物品需要哪些原材料，在合成之前需要把原材料从背包模块拖拽到对应的图谱位置。 2.4是进行合成的具体区域，当某个物品的合成图谱全部被填充好之后，才可以进行合成。 搭建UI布局这里的UI布局是“死”的UI，先把整个的UI布局确定好，后面再根据这个UI布局进行灵活的“动态生成”，“逻辑控制”。搭建UI布局要注意的点： “大元素套小元素”，相对大的元素与覆盖在它表面的相对小的元素形成父子关系。这也是在Web开发中常常会使用到的「Div + CSS」布局的思路。 重复的子元素（比如合成图谱分类的Tab、各种的物品框）才表格布局的方法，先手动复制多个元素调试到适合的布局，再将这个元素制作成一个「预制体」，最后在代码中动态生成。 代码部分M.V.C架构介绍在以前的案例制作中，常常会把「数据控制」「UI控制」「逻辑控制」放到一个Manager的控制脚本中，这样做的问题时，单个脚本的代码量非常庞大，管理起来不方便。因此，我们可以把UI相关的脚本分为三块： 数据控制[Model] (对XML、Json 读取，存储，更新…) 界面控制[View] (组件查找，UI 数据更新…) 整体逻辑[Controller] (循环生成子元素，UI 的事件处理，商品购买…) 迷你版MVC迷你版MVC 主要应用在UI 功能模块的Panel 上，也就是模块的整体控制。 XxxxPanelView.cs XxxxPanelController.cs XxxxPanelModel.cs 而Panel 的子级物体还是单个脚本控制，叫做XxxxItemController.cs，因为子级物体逻辑相对简单，可以先不分层。 使用迷你版MVC的注意事项 创建好MVC的三个脚本挂载到XxxPanel之后，「Controller脚本」要分别持有「View脚本」「Model脚本的引用」。因为「Controller脚本」处于主导地位。「View脚本」与「Model脚本」不直接通信。 Model脚本把加载好的数据以字段封装成属性的方式公开，Controller脚本可以调用，View的设置UI的方法也公开，通用供Controller脚本使用。 View 和Model 脚本当中的初始化操作需要放到Awake 方法内，Controller的初始化放到Start 方法内。目的是为了Controller 控制界面和数据的时候，这两个脚本必须已经初始化完毕。 脚本分析 从上面的脚本关系图可以看出，整体上有两个「MVC框架」，因为我们之前已经把背包系统分为了两个模块，背包模块和合成模块，所以使用两个「MVC」分别对背包模块和合成模块进行控制： 背包模块 InventoryPanelController.cs InventoryPanelView.cs InventoryPanelModel.cs 合成模块 CraftingPanelController.cs CraftingPanelView.cs CraftingPanelModel.cs 背包模块背包模块比较简单： View层查找相关组件，并加载（Resources）生成UI所需的预制体供Controller层使用； Model层从Json文件中解析出生成背包物体所需要的数据，并公开相应的方法让Controller使用这些数据；注意这里还创建想背包物体的「数据实体类」InventoryItem.cs Controller层负责调用View层和Model层的数据，循环生成UI物体 合成模块合成模块相对于背包模块来说复杂一些，主要体现在Controller脚本中有几个子类物体的控制脚本。主要是因为北城模块的UI层次就很复杂，但是合成模块的MVC职责分工和背包模块的MVC的职责分工是一样的。 需要注意的是，「CraftingPanelController.cs」负责总的逻辑控制，而它的子物体的控制脚本只需要负责公开方法供它使用就可以的。 如果生成子类物体的时候想要初始化它的控制脚本的数据，可以在子类的控制脚本定义一个初始化的方法Init（），在生成子类的之后就调用它的子类控制脚本的初始化方法，并传递必要的数据。 模块间进行通信两个模块进行通信，可以先把两个MVC的「Controller脚本」封装成单例，然后通过XxxxPanelController.Instance.方法名()的方式进行通信。 需要注意的是，模块与模块之间，最好只是两个Controller层通信，比如：》 InventoryItemController.cs想要调用CarftingPanelController.cs的方法则可以先在InventoryPanelController.cs声明一个公开的方法去调用CarftingPanelContoller的方法 然后InventoryItemController.cs再去调用那个公开的方法。 这样做的目的是单一“脚本的职责”，减少脚本的耦合 工具类在上面的脚本关系图中，最右边有两个工具类，分别是ResourcesTools.cs和JsonTools.cs，这两个脚本是在脚本编写过程中抽离出来的（在实际开发过程中，这些工具类是事先已经提供好的，可以直接进行使用，一般是“主程”编写好的），它与游戏逻辑没有直接业务关系。但是游戏逻辑需要使用到这些工具类。工具类的特点： 工具类的实现有两种语法格式：密封类，结构体；最常用的还是密封类（sealed）格式； 工具类内的成员全部用static 静态关键字修饰； 工具类不需要实例对象，使用格式是：工具类名.字段名/属性名/方法名/； 工具类就是一个普通的C#类，不需要继承Mono 行为类。 其他 项目文件：链接: https://pan.baidu.com/s/1yeGrQNXHshJfAWG9N9gzhA 密码: wfnk]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>UI</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-简单的递归]]></title>
    <url>%2Fpost%2Frecursion-algorithm-with-python.html</url>
    <content type="text"><![CDATA[什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身称为递归调用。 递归什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身成为递归调用。 “庙里的老和尚”的故事可以用来理解这种模式 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’” ——维基百科 递归函数使用递归函数的关键： 找出基线条件，退出递归函数 缩小问题的规模 用递归来求和 用循环来求和 12345def sum(arr): total = 0 for x in arr: total += x return total 用递归的求和 1234567def sum(arr): if arr == []: return 0 return list[0]+sum(list[1:]) print(sum([12,4,17,9])) # 输入结果：42 用递归来计算列表的长度1234567def countElem(arr): if arr==[]: return 0 return 1+countElem(arr[1:]) print(countElem([12,4,17,9]))# 输出结果：4 用递归来找出最大元素1234567def maxElem(arr): if len(arr) == 1: return arr[0] return arr[0] if arr[0] &gt; maxElem(arr[1:]) else maxElem(arr[1:])print(maxElem([12,4,17,9]))# 输出结果：17 理解return-if-else：这是Python支持的一种语法。 1return "a" if 1&lt;2 else "b" 在这里1&lt;2是判断条件，如果条件成立则返回“a”，如果条件不成立则返回“b” 快速排序（quick）1234567891011def quicksort(array): if len(array) &lt; 2: return array else: pivot = array[0] # 递归条件 less = [i for i in array[1:] if i &lt;= pivot] greater = [i for i in array[1:] if i &gt; pivot] return quicksort(less) + [pivot] + quicksort(greater) print(quicksort([12,4,17,9])) # 输出结果：[4, 9, 12, 17] 基线条件：2行：当数组为空或者只包含一个元素，这样最后只需要原样恢复数组，不用再进行排序 pivot是基准值，用于对其他的数进行分类 less存储的是比pivot小的数组成的数组 greater存储的是比pivot大的数组成的数组 快速排序的算法复杂度O(n * Log n) 参考资料 递归算法详解]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪米特原则]]></title>
    <url>%2Fpost%2Flaw-of-demeter.html</url>
    <content type="text"><![CDATA[迪米特原则也叫最小知道原则 定义： 一个对象应该对其他对象保持最少的了解。 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另外一个类的某一个方法的话，可以通过第三者转发这个调用。 一个对象应当对其他对象有尽可能少的了解。 迪米特原则的切入点 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。 Unity 项目开发，不要使用public 公开字段，然后面板拖拽资源赋值这种方式。应该把字段全部private 修饰，然后public 属性公开调用。 迪米特原则主要是强调了类与类之间的松耦合 类与类之间的耦合度越低，越有利于代码的复用，一个处于低耦合的类被修改了，不会对有关系的类造成影响 参考资料 迪米特原则]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP六大原则</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖倒置原则]]></title>
    <url>%2Fpost%2Fdependence-inversion-principle.html</url>
    <content type="text"><![CDATA[针对抽象编程，不要针对实现编程； 官方定义 A. High-level modules should not depend on low-level modules. Both should depend on abstractions. B. Abstractions should not depend on details. Details should depend on abstractions. 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口)。 模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。 理解参考擅码网的讲解 PHP中的依赖倒置原则 代码逻辑并不是直接操控数据库，而是通过一个抽象的PDO类来进行增删改查，这样的好处是如果要更改使用的数据库类型，比如原本是使用「MySQL」，现在要改成「SQLite」，只需要对PDO类更改操作数据库的逻辑，而关键的「代码逻辑」不需要发生任何变化。 Unity引擎的依赖倒置Unity引擎的跨平台性很强 早期开发游戏 Android 平台的游戏，需要使用Eclipse 开发，只能运行于Android 平台； IOS 平台的游戏，需要使用XCode 开发，只能运行于IOS 平台； 因为编写这些游戏时，使用的代码，都是各个平台提供的针对性的API。 高层依赖于底层：开发游戏需要依赖于该平台的底层API。 Unity开发游戏 使用C#开发一个版本，稍作调整就能发布到N 个平台。在我们发布成不同平台的游戏的时候，Unity 本身就做了一个“对接”的任务，把我们的代码里面的API，对接到该平台上相应的API。 高层和底层都依赖于抽象：我们的游戏是依赖Unity 的，各个平台的API 也是Unity 完成对接任务的。]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP六大原则</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开闭原则]]></title>
    <url>%2Fpost%2Fopen-closed-princicle.html</url>
    <content type="text"><![CDATA[开闭原则 规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的” 定义：软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。 面对需求，对程序的改动应该是以增加新代码的方式解决，而不是更改旧的代码。 在实际开发过程中，开发的某个功能，可能因为需求有变化，要重新构建新的代码。但是原来的代码也不能删掉，如果之后需求再发生变化，又要换到之前的代码，则只需要简单更换一个业务逻辑即可。 开放封闭原则，其中的封闭不是绝对的封闭。]]></content>
      <categories>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>OOP六大原则</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jieba库制作统计水浒传角色的词频]]></title>
    <url>%2Fpost%2Frole-name-count-in-shuihu-use-Jieba.html</url>
    <content type="text"><![CDATA[这是学习Python一个星期依赖独立制作的一个比较小的案例脚本，计算一段文本的「词频」 案例介绍统计出某一文本中词条的词频。这个案例我是用水浒传文本来统计出每一名角色(108将)出现的次数 案例知识点 使用Jieba模块分词 使用json模块将字典导出成json文本 Python的IO操作 案例准备 Windows 10 Python 3.6 安装好JieBa库 《水浒传》.txt文本 水浒108将.txt文本 项目文件结构12345.├── namerate.json├── RoleCount.py├── role.txt└── shuihu.txt 安装JieBa库 jieba 是一个python实现的分词库，对中文有着很强大的分词能力。 Git链接：https://github.com/fxsjy/jieba 1py -3 -m pip install Jieba 处理素材文本“水浒传.txt”不需要额外处理，但是“108将”需要使用「正则表达式」进行处理，处理结果最后应该是，每一行文本只有一个将领的名字。 实验脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-import jiebaimport json# 108将字典roles = &#123;&#125;# 存储水浒所有的文本shuihu_str = ''# 导入文件的名字filename = 'namerate.json'# 把108将添加到jieba词库中去def AddWords(): for name in roles: jieba.add_word(name)# 打开role文本，创建字典with open("role.txt", 'r', encoding='UTF-8') as file_Object: for name in file_Object: roles[name.strip()] = 0AddWords()# 打开shuihu文本，存储到shuihu_str变量中去with open("shuihu.txt", 'r', encoding='UTF-8') as file_Object: lines = file_Object.readlines() for line in lines: shuihu_str += line.strip()# 分词匹配seg_list = jieba.cut(shuihu_str, cut_all=False)for word in seg_list: for role in roles: if(role == word): roles[role] += 1 breakprint("匹配完毕")with open(filename, 'w') as f_obj: f_obj.write(json.dumps(roles, ensure_ascii=False))# 在Cmd窗口输出字典for key, value in roles.items(): print(key) 案例制作总结这个项目遇到的最大的问题是“中文字符”的编码问题，比如在30行open的文本无法与str相加，可能是字符编码不相同，存储字典到.json的中文字符也是乱码的。]]></content>
      <categories>
        <category>Python</category>
        <category>Module</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>案例</tag>
        <tag>Module</tag>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用bat脚本一键部署Hexo文章]]></title>
    <url>%2Fpost%2Fcreate-new-article-with-bat.html</url>
    <content type="text"><![CDATA[使用「Alt Run」和「Bat」脚本实现写Hexo文档的一键部署 每次用Hexo写文章，都需要先打开Cmd窗口转到D盘的Hexo的路径下，然后运行hexo new **，再定位到_post路径用「Typor」打开，最后还要使用hexo g hexo s等命令去部署，写一篇文档之前要浪费这样时间，尤其是复杂的操作降低了写作的积极性。为了减少操作，想到可以用脚本来代替自己的手动操作。最后使用alt run来打开脚本，更加快捷。 配置准备 Win10 操作系统 Hexo 博客 ALT Run：快速启动软件 编写的Bat脚本 编写脚本 一键创建文章 创建Hexo文章.bat 123456@echo offset /p name=input pages name:echo name:%name%echo please waithexo new %name% &amp;&amp; call 1.bat %name%pause 2行：从cmd窗口获取文章的名字 5行：创建从窗口获取的名字，同时调用1.bat这个脚本 1.bat脚本 12345start /min /w mshta vbscript:setTimeout("window.close()",1000)echo The InputValue is %1set name=%1echo %name%start /d "D:\Program Files\Typora\Typora.exe" Typora.exe "D:\Hexo\blog\source\_posts\%name%.md" 1行：延迟1秒执行 3行：「继承 创建hexo文章.bat」的变量 5行：使用D盘的「Typora.exe」MarkDown编辑器打开刚才创建好的文章 发布到本地服务器 发布到本地服务器.bat 123start hexo_g.batstart /min /w mshta vbscript:setTimeout("window.close()",3000)start hexo_s.bat hexo_g.bat 1hexo g hexo_s.bat 1hexo s 发布GitHub Page 发布到github.bat 123start clean.batstart /min /w mshta vbscript:setTimeout("window.close()",1200)start hexo_d.bat clean.bat 12345@echo offecho cleanecho Please waithexo cleanexit hexo_d.bat 1234@echo offecho postting.....hexo g -dpause 搭配AltRun快速启动什么，AltRun都不知道是什么，那还不快去了解一下，当然也可以使用其他的快速启动软件，或者把这些脚本的快捷键放到系统环境中，使用Win + Q启动。 在AltRun用到的热键： new：创建文章，并使用Typora打开 start：生成静态网页，并打开本地hexo服务器 post：用hexo clean清除public文件夹，并且发布到「github page」中去 参考资料： 使用bat批处理脚本优化hexo的使用体验 AltRun快速启动工具]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Pillow对图片转为字符画]]></title>
    <url>%2Fpost%2Fpython-learning-use-pillow.html</url>
    <content type="text"><![CDATA[这个案例来自实验楼的学习案例 实验知识点 pillow 库的使用 argparse 库的使用 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#-*- coding:utf-8 -*-from PIL import Imageimport argparse# 创建一个解析对象parser = argparse.ArgumentParser()# 向对象中添加要关注的命令行参数和选项parser.add_argument('file') #输入文件parser.add_argument('-o', '--output') #输出文件parser.add_argument('--width', type = int, default = 80) #输出字符画宽parser.add_argument('--height', type = int, default = 73) #输出字符画高#获取参数args = parser.parse_args()# 定义变量存储parser对象获取到的参数IMG = args.fileWIDTH = args.widthHEIGHT = args.heightOUTPUT = args.outputascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. ")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]# 下面一行代码表示模拟程序的入口if __name__ == '__main__': im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = "" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) # 实参前面使用*号表示传递元组 txt += '\n' print txt #字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open("output.txt",'w') as f: f.write(txt) 参考资料： Python 图片转字符画 用Python处理图像——PIL]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块之命令行解析工具-argparse]]></title>
    <url>%2Fpost%2Fpythone-argparse-tools.html</url>
    <content type="text"><![CDATA[如果设计的软件需要命令行参数（比如需要调用程序时附加一些参数，文件、字符或数字）就需要argparse模块，该模块是Python的标准库中的模块。 使用方法12345678import argparse # 首先导入该模块；parser = argparse.ArgumentParser() # 然后创建一个解析对象# 然后向该对象中添加你要关注的命令行参数和选项，每一个add_argument方法对应一个你要关注的参数或选项；parser.add_argument() # 最后调用parse_args()方法进行解析；解析成功之后即可使用 args = parser.parse_args() 案例1234567891011import sysimport argparseif __name__ == "__main__": parser = argparse.ArgumentParser() parser.add_argument("-m", type = int) parser.add_argument("-n", type = int) args = parser.parse_args() print "%d ^ %d = %d" % (args.m, args.n, args.m ** args.n) 分析： 在两条parser.add.argument方法中，接受运行的参数设置 -m后面的参数赋值给args.m -n后面的参数赋值给args.n 运行结果： 参考资料 https://blog.csdn.net/gatieme/article/details/45917173]]></content>
      <categories>
        <category>Python</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python环境搭建]]></title>
    <url>%2Fpost%2Fpyton-env-build.html</url>
    <content type="text"><![CDATA[最近的在学Python，在搭建Python环境的时候遇到了很多困惑，这里整理总结一下留做以后参考，这篇文档是在Windows的环境下进行的 一台电脑可以安装多个Python吗答案是肯定的，我在电脑同时安装了两个版本的Python，分别是 Python 3.6.4 Python 2.7.14 先在python.org下载两个版本的安装包 安装在硬盘的不同路径中，比如我把Python 3.6安装在默认位置 把Python 2.7安装在D盘的路径下，并且在安装的时候勾选「Add to Path」添加路径到系统环境变量中去。​同时安装Python 3和Python 2如何快捷切换打开cmd窗口直接运行Python默认打开的Python 2但是我如果想使用Python 3怎么办？ Windows 上的 Python 自带启动器 py.exe，默认安装到系统盘的Windows文件夹里。如果你同时安装了 Python 2 和 Python 3，用的时候直接在终端里输入： 1py -3 就是打开的Python 3 的 REPL(控制台)同理如果你运行1py -3 #打开的是Python 3 而如果直接运行Py，默认打开的是Python 3，就是系统盘Windows文件下那个py.exe. 如果运行Python，则打开的Python 2,可能是因为后来安装了Python 2把Python 3给覆盖了。为了避免每次运行都需要通过py -2或py -3的方式启动，在编写Python程序的时候，可以在代码的前面加入声明说明该文件是由Python 2启动还是Python 3启动：12#! python2 #用Python2启动#! python3 #用Python3启动 其他方法： 改名：把Python 2版本中的文件名改成Python2，则默认运行的Python 3的版本 这样修改了名字的那个python对应的pip将无法使用。 在同一台电脑下如何进行 Python 2 与 3 的切换？——知乎Python和pip的关系什么刚开始，安装好Python 3之后，要导入第三方的库，别人的教程里面有很多pip命令，只是依葫芦画瓢，不懂是什么意思。后来要导入如一个turlte， 这是一个绘制图像的库。1pip install turtle #使用的Python 3 的pip工具 但是，提示错误Command &quot;python setup.py egg_info&quot;应该是安装脚本中脚本错误的啥的，具体也不清楚，想着再用Python 2试一下，这时候就完全懵逼不知道怎么来操作了。随后在网上了解了一下：pip就是Python的一个包管理工具 pip是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包。当然，Python也有其他的包管理工具，比如还有easy_install，这是Python 2.7中的默认包管理工具，现在pip已经基本取代了easy_install，如果要需要pip在老版本的Python 2.7 中则需要手动安装，在Scripts文件夹内运行cmd命令1easy_install pip 安装好pip后如何使用每个版本的Python都有自己的pip工具，如果电脑上只有一个存在一个版本的「Python」时，可以直接使用pip1pip install &lt;包名&gt; 但如果同时存在多个版本的Python，使用pip命令时就需要指明Python的版本，比如要给Python 3下载导入模块则需要「Python 3」的pip：1py -3 -m pip install &lt;包名&gt; pip的常用命令 列出已经安装的包，列出所有的包是pip list 1pip freeze 在线安装包： 1pip install &lt;包名&gt; 本地安装包 1pip install &lt;目录&gt;/&lt;文件名&gt; 卸载包 1pip uninstall &lt;包名&gt; 升级包 1pip install -U &lt;包名&gt; pip常用命令 更换pypi镜像国内pypi镜像 豆瓣：https://pypi.douban.com/simple 中国科学技术大学：https://mirrors.ustc.edu.cn/pypi/web/simple/ 清华大学TUNA： https://pypi.tuna.tsinghua.edu.cn/simple https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/指定单次安装源12# pip install &lt;包名&gt; -i &lt;pypi源地址&gt;pip install &lt;包名&gt; https://pypi.tuna.tsinghua.edu.cn/simple/ 指定全局安装源 在unix和macos，配置文件为：$HOME/.pip/pip.conf 在windows上，配置文件为：%APPDATA%\pip\pip.ini 打开CMD，输入 echo %APPDATA% 的路径为C:\Users\Lemmo\AppData\Roaming 先打开%APPDATA%文件夹后，打开pip文件夹，如果没有则新建一个命名为pip的文件夹，然后创建文件pip.ini，打开文件输入下面的内容后保存 1234[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cn 使用pip安装的module的路径我的Python 2.7是安装在D盘的，这些module路径就是：1D:\Program Files\Python 2.7\Lib\site-packages Python 包管理工具解惑]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pyhton</tag>
        <tag>package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2Fpost%2FSingleton-Pattern-With-Csharp.html</url>
    <content type="text"><![CDATA[一、单例模式介绍“单例”字面意思上理解为——一个类只有一个实例，所以单例模式也就是保证一个类只有一个实例的一种实现方法罢了 [test][1] (设计模式其实就是帮助我们解决实际开发过程中的方法, 该方法是为了降低对象之间的耦合度,然而解决方法有很多种,所以前人就总结了一些常用的解决方法为书籍,从而把这本书就称为设计模式) 官方定义：确保一个类只有一个实例,并提供一个全局访问点。 二、为什么会有单例模式为什么要有单例模式的？它在什么情况下使用的？从单例模式的定义中我们可以看出——单例模式的使用自然是当我们的系统中某个对象只需要一个实例的情况， 例如:操作系统中只能有一个任务管理器,操作文件时,同一时间内只允许一个实例对其操作等,既然现实生活中有这样的应用场景,自然在软件设计领域必须有这样的解决方案了(因为软件设计也是现实生活中的抽象)，所以也就有了单例模式了。 三、Mono子类C#脚本单例 定义一个当前类的公开，静态，当前类类型返回值的一个字段； 1public static Master Instance; //一个名为Master的类 在Awake 事件方法中完成该字段的赋值。 1234void Awake()&#123; Instance = this;&#125; 在其他类中使用单例 1Master.Instance.字段/方法; 四、非Mono 子类C#脚本单例 定义一个当前类的私有，静态，当前类类型返回值的字段； 1private static ClassNmae instance; 创建一个无参私有构造方法 1private ClassNmae() &#123; &#125; 创建一个公开，静态，用于封装字段的属性；在该属性内实现单例，（或者可以创建公开的、静态的方法） 1234567891011public static ClassNmae Instance &#123; get &#123; if (instance == null) &#123; instance = new ClassNmae(); &#125; return instance; &#125; &#125; 在其他类中使用单例]]></content>
      <tags>
        <tag>Csharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2Fpost%2Flambda-expression.html</url>
    <content type="text"><![CDATA[1. Lambda表达式概念官方概念 Lambda 表达式是一种可用于创建 委托 或 表达式目录树 类型的 匿名函数 。 通过使用 lambda 表达式，可以写入可作为参数传递或作为函数调用值返回的本地函数。 Lambda 表达式，是一种代码的语法格式； Lambda 表达式是对匿名方法语法格式的进一步简化； Lambda 表达式可以理解成是匿名方法的升级版。 【方法的三种表现形式】普通方法–&gt; 匿名方法–&gt; Lambda 表达式越往后越抽象，越往后理解成本也就越高。 2. Lambda表达式的语法 语法格式 委托类型变量= （[参数列表]）=&gt; { 方法体; }; 语法格式分析 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public delegate void ShowDelegate(); //无参.public delegate void NameDelegate(string name); //有参.public class LambdaTest : MonoBehaviour &#123; public ShowDelegate showDel; public NameDelegate nameDel; void Start () &#123; showDel = Hello; showDel += delegate() &#123; Debug.Log("MKCODE"); &#125;; showDel += () =&gt; &#123; Debug.Log("擅码网"); &#125;; //语法分析1 showDel(); //-----------------Lambda语法分析----------------------- nameDel = (string name) =&gt; &#123; Debug.Log("我的名字是:" + name); &#125;; nameDel += (string name) =&gt; &#123; Debug.Log("My Name Is" + name); &#125;; nameDel += name =&gt; &#123; Debug.Log("你是:" + name); &#125;; //语法分析2 nameDel += info =&gt; Debug.Log("Hello:" + info); //语法分析3 nameDel("LKK"); &#125; private void Hello()&#123; Debug.Log("Monkey"); &#125;&#125; =&gt; 是Lambda 表达式特有符号，读音是：goes to 如果没有参数列表，（）也不能省略，如：（）=&gt; 如果参数列表中只有一个参数，（）可以省略 如果方法体内只有一句代码，可以省略代码块符号，也就是不用写{ }]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda表达式]]></title>
    <url>%2Fpost%2Flambda-expression.html</url>
    <content type="text"><![CDATA[1. Lambda表达式概念官方概念 Lambda 表达式是一种可用于创建 委托 或 表达式目录树 类型的 匿名函数 。 通过使用 lambda 表达式，可以写入可作为参数传递或作为函数调用值返回的本地函数。 Lambda 表达式，是一种代码的语法格式； Lambda 表达式是对匿名方法语法格式的进一步简化； Lambda 表达式可以理解成是匿名方法的升级版。 【方法的三种表现形式】普通方法–&gt; 匿名方法–&gt; Lambda 表达式越往后越抽象，越往后理解成本也就越高。 2. Lambda表达式的语法 语法格式 委托类型变量= （[参数列表]）=&gt; { 方法体; }; 语法格式分析 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.Collections.Generic;using UnityEngine;public delegate void ShowDelegate(); //无参.public delegate void NameDelegate(string name); //有参.public class LambdaTest : MonoBehaviour &#123; public ShowDelegate showDel; public NameDelegate nameDel; void Start () &#123; showDel = Hello; showDel += delegate() &#123; Debug.Log("MKCODE"); &#125;; showDel += () =&gt; &#123; Debug.Log("擅码网"); &#125;; //语法分析1 showDel(); //-----------------Lambda语法分析----------------------- nameDel = (string name) =&gt; &#123; Debug.Log("我的名字是:" + name); &#125;; nameDel += (string name) =&gt; &#123; Debug.Log("My Name Is" + name); &#125;; nameDel += name =&gt; &#123; Debug.Log("你是:" + name); &#125;; //语法分析2 nameDel += info =&gt; Debug.Log("Hello:" + info); //语法分析3 nameDel("LKK"); &#125; private void Hello()&#123; Debug.Log("Monkey"); &#125;&#125; =&gt; 是Lambda 表达式特有符号，读音是：goes to 如果没有参数列表，（）也不能省略，如：（）=&gt; 如果参数列表中只有一个参数，（）可以省略 如果方法体内只有一句代码，可以省略代码块符号，也就是不用写{ }]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题显示摘要]]></title>
    <url>%2Fpost%2Fhexo-next-show-summary.html</url>
    <content type="text"><![CDATA[刚创建好的网站，把几篇以前写的MarkDown文件放在_Post文件夹中，但是打开网站一下，发现在页面中每篇文章都全部显示了，翻看起来不方便。如何解决这个问题. 官方提供了三个解决办法! 在文章中使用手动截断的方法，截断的语句是&lt;!-- more --&gt; 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在主题配置文件中添加，默认截取的长度为 150字符，可以根据需要自行设定：123auto_excerpt: enable: true length: 150 文章模版1234567891011---title: git的基本使用date: 2017-01-24categories:- cate1tags: - tag1---&lt;img src="/img/git.png" width = "900" height = "600" alt="git" align=center /&gt;摘要内容......&lt;!-- more --&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插件记录]]></title>
    <url>%2Fpost%2Fhexo-plug-in-collection.html</url>
    <content type="text"><![CDATA[记录一些常用的Hexo插件 NexT官方集成插件介绍：https://theme-next.iissnan.com/third-party-services.html 本地搜索：Local Search 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 采坑注意：：在Next的主题配置文件中已经存在了local_search的语句了，不要重复添加，否则会报错。只需要搜索到相关位置，将false更改为true即可。搜索效果如下： 图片预览插件：FancyBoxHexo-Next主题中已经有图片预览的功能了，如果要使用，在主题的配置中文件中把FancyBox:False改为true。但是不知道什么原因，我开启之后无法打开网站。考虑到可能是没有下载FancyBox这个插件的原因。FancyBox有两个版本，FancyBox2和FancyBox3，一般来说v2版本就够用了。 下面是安装插件的步骤（参考fancybox的github地址）） 转到Next主题的目录 1$ cd themes/next 安装FancyBox到Source/lib路径 1git clone https://github.com/theme-next/theme-next-fancybox source/lib/fancybox 在NexT的_config.yml中开启 1fancybox: true 更新 12$ cd themes/next/source/lib/fancybox$ git pull 添加评论插件：Valine实现过程： 使用 Valine 给 Hexo 博客添加评论系统 Hexo博客常用插件及用法!]]></content>
      <categories>
        <category>默认</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文件目录]]></title>
    <url>%2Fpost%2Fhexo-basic.html</url>
    <content type="text"><![CDATA[刚接触到Hexo，已经被Hexo的简洁性和部署网站的便捷性所惊叹到了，但是Hexo的一些概念在大脑中还不是很清晰，在网上也没有找到一篇特别好的文章来介绍总结。因此本文作为个人使用Hexo认识的比较重要概念的的一些总结。 创建好Hexo后的路径树12345678910111213.├── _config.yml├── package.json|── public├── scaffolds├── source| ├── _drafts| └── _posts| ├── categories| └── tags└── themes |_ next(主题的名字) |_config.yml config.yml配置文件，采用yml的格式 root目录下的_config.yml:站点配置文件 应用的某个主题（如NexT）下的_config.yml:主题配置文件 public文件夹这个文件夹存放的是当我们使用命令hexo g命令后，自动生成的一些html文件, 这些文件都是要上传到远程服务器中。 source文件夹 _posts：保存markdown的源文件 _categories：使用命令hexo new page categories创建分类分页自动生成的文件夹； _tags：同上，这里创建标签分页； 如何创建分页!]]></content>
      <categories>
        <category>Computer skills</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo本地建站]]></title>
    <url>%2Fpost%2Fbuild-hexo-blog.html</url>
    <content type="text"><![CDATA[整理总结一下如何在本地安装Hexo，因为本人的电脑是Windows系统，所以以下都是在Windows环境下进行的。 安装前提 GIt Node.Js 1. 安装Git 下载Git：Git官网 安装Git 2. 安装Node.js 直接下载Node.Js的安装包 安装并Add 到Path（自动选择了） 安装Hexo 打开Node.js Command Prompt 运行命令1$ cd d:/hexo #要安装的Hexo的路径 安装hexo的命令 1$ npm install hexo-cli -g 在Blog的目录下初始化 hexo博客，名字可以是任意取 1$ hexo init blog #安装landscape的速度的比较慢 进入博客根目录，并且安装相关插件依赖等 12$ cd blog$ npm install 运行hexo的几个名字，查看效果 12hexo g #生成静态文件，汇总当前目录下生成一个新的叫做public的文件夹hexo s #启动本地的Web服务，启动完成后，可以在地址栏输入「http://127.0.0.1:4000/」查看 运行之后的效果 hexo的官方文档 如何安装主题Hexo中很有很多不同类型的主题： 一些参考 NexT.Mist：示例网站 Next官方使用文档! pure：示例网站 下载主题1git clone https://github.com/iissnan/hexo-theme-next.git themes/next themes/next为下载主题的路径 启动主题修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为next(网站应该会启动themes下的next主题) 更新12git g #生成git s #启动本地服务器]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
