<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lemmo&#39;s Blog</title>
  
  <subtitle>一个人的碎碎念</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lemmo.xyz/"/>
  <updated>2019-07-21T14:51:20.000Z</updated>
  <id>http://lemmo.xyz/</id>
  
  <author>
    <name>lemmo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「薛兆丰经济学讲义」读书笔记</title>
    <link href="http://lemmo.xyz/post/Economics-Lecture-Notes.html"/>
    <id>http://lemmo.xyz/post/Economics-Lecture-Notes.html</id>
    <published>2019-07-14T17:36:20.000Z</published>
    <updated>2019-07-21T14:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">Title</td><td style="text-align:left">薛兆丰经济学讲义</td></tr><tr><td style="text-align:left">Author</td><td style="text-align:left">薛兆丰</td></tr><tr><td style="text-align:left">Edition</td><td style="text-align:left">中信出版社</td></tr><tr><td style="text-align:left">Release Date</td><td style="text-align:left">2018-07</td></tr><tr><td style="text-align:left">ISBN</td><td style="text-align:left">9787508689586</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/Economics-Lecture-Notes.jpg" alt="">经济学与我们每一个个体都是息息相关的，即使你不去了解它，只要你生活在现代社会之中，它就会深深地影响着你，因为经济学是以研究陌生人的互动规律为己任。学习经济学知识可以帮助我们理解当下的一系列的经济社会运作的逻辑和规律。它是一种思维方式，让我们可以理性、客观地看待一些社会经济现象。</p><p>经济学是一门科学，它是可证伪，可以被验证的，它包含了很多社会运转的规律。经济学又数学是紧密联系中，经济学理论中有大量的数学、模型和方程式。经济学也是一门研究人的行为规律的学科。由于要经济学中包含了人性的因果规律的探索，人性是一个灵活多变的变量，所以经济学的问题往往是复杂的。</p><p>经济学关心的是「事与愿违」的现象，而不是「事与愿符」的现象。不是“好人做好事，坏人做坏事”的问题，而是为什么有时好心会办坏事？比如最常见的例子。</p><ul><li>最低工资制度，本来是要保护穷人的，但最后穷人的境遇反而更糟了；</li><li>同工同酬制度，本来是要保护弱势群体的利益，但最后却损害了他们的利益；</li><li>福利制度，本来是让那些没有依靠的人能够找到依靠，但最后这些人的境遇却变得更惨了；</li></ul><h1 id="稀缺：经济学的基础"><a href="#稀缺：经济学的基础" class="headerlink" title="稀缺：经济学的基础"></a><strong>稀缺</strong>：经济学的基础</h1><p>产生「稀缺」的两个原因：</p><ol><li>我要的东西别人也想要；</li><li>人的需求在不断变化、升级。</li></ol><p>第一个原因，因为资源总是有限的，而大家都想要（需求），这形成了稀缺。第二个原因，人的欲望总是无法被满足了，人总是追求好的东西（需求），而好的东西（供给）是有限的。稀缺必定导致歧视，因为有稀缺的存在，必定意味着要有所选择，做选择就会区别对待（歧视）。</p><h1 id="成本：成本是放弃了的最大代价"><a href="#成本：成本是放弃了的最大代价" class="headerlink" title="成本：成本是放弃了的最大代价"></a>成本：成本是放弃了的最大代价</h1><p>比如，现在我手上有一项资源，可以是一块地，也可以是一笔资金。我可以把这项资源用于A、B、C、D等若干选择，被选中的那个选项的成本就是“所有放弃了的选项中价值最高的那个”。当你把手中的资源用作某个选项时，也就放弃了其他选项的可能性，所以这个选项的成本是所有选项中能产生的最大收益的那项的收益。</p><p>成本是放弃了的最大代价，放弃的东西越多，代价就越高；放弃的东西越少，代价就越少；如果没有放弃，就没有成本。「沉没成本」是已经发生的不可回收的支出，无法回收也就是没办法再放弃了，所以「沉没成本」不是成本。</p><h2 id="盈利与亏损"><a href="#盈利与亏损" class="headerlink" title="盈利与亏损"></a>盈利与亏损</h2><p>从成本的角度来看盈利与亏损，它们都是意外发生的。每当发生意外，我们就重新调整资源的未来估值，而资源使用的成本，就要按照这个新的估值来计算。所以，一旦出现盈利，资源的使用成本就会提高；一旦出现亏损，资源的使用成本就会下降。</p><h2 id="产品的价格"><a href="#产品的价格" class="headerlink" title="产品的价格"></a>产品的价格</h2><ol><li><p>成本决定论（与直觉相符，逻辑错误）</p><blockquote><p>产生的价格等于原材料的成本的综合，乘以合理的利润率；</p></blockquote></li><li><p>需求决定论（反直觉，与事实相符）</p><blockquote><p>产品的供需关系决定产品的价格，产品的价格又来原材料的价格。</p></blockquote></li></ol><h2 id="科斯定律"><a href="#科斯定律" class="headerlink" title="科斯定律"></a>科斯定律</h2><p>在社会利益冲突中（伤害是相互的），哪一方执行解决方案的总成本最小，社会规则倾向于让他成为责任方。——科斯在《社会成本问题》</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><h2 id="个人估值"><a href="#个人估值" class="headerlink" title="个人估值"></a>个人估值</h2><blockquote><p>阿尔钦的定义，“一个人对一件商品的个人估值，是他为了得到这件商品所愿意支付的其他商品的最高数量”</p></blockquote><ul><li>个人估值是个人的估值，不是集体的估值</li><li>是绝对主观的，没有所谓的客观的估值</li><li>是以个人的愿望为基础的</li></ul><h2 id="价值论"><a href="#价值论" class="headerlink" title="价值论"></a>价值论</h2><ol><li>客观价值论<strong>能</strong>够解释的现象，主观价值论（个人估值）也能解释。</li><li>客观价值论<strong>不</strong>能够解释的现象，主观价值论（个人估值）也能解释。</li><li>主观价值论呢更好地指导生产。</li></ol><h2 id="边际"><a href="#边际" class="headerlink" title="边际"></a>边际</h2><ol><li><p>边际的概念：边际是由“新增”带来的“新增“。</p><ul><li><strong>边际成本</strong>：每新增一个单位产品所需要付出的新增成本；    </li><li><strong>边际收入</strong>：每多卖一个产品能够带来的新增收入；</li><li><strong>边际产量</strong>：每新增一份投入所带来的新增产量；</li><li><strong>边际效用</strong>：每消耗一个单位的商品所能带来的新增享受。</li></ul></li><li><p>边际效用递减定律</p></li></ol><blockquote><p>在单位时间内随着人们消耗的某种商品的数量不断增加，消耗这种商品所能带来的新增享受迟早都会下降。</p></blockquote><ol start="3"><li>边际效用和边际成本是一对成对概念，通过追求它们之间的平衡，就能够使总收益最大化。</li></ol><h2 id="需求三大定律"><a href="#需求三大定律" class="headerlink" title="需求三大定律"></a>需求三大定律</h2><h3 id="需求第一定律"><a href="#需求第一定律" class="headerlink" title="需求第一定律"></a>需求第一定律</h3><blockquote><p>当其他情况不变时，只要价格提高，商品的需求量就会减少；价格降到一定程度，需求量就会增加。</p></blockquote><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/2019-07-15%2001.58.54.387.jpg" alt=""></p><ul><li>需求曲线使永远向下倾斜的，产品的价格很低时，需求量高；价格逐渐上涨，需求量就逐渐减少，当价格上升到一定程度，需求量就萎缩为零。</li><li>当价格持续上涨时，需求变为负（虚线），需求也就变成了供给。需求和供给没有黑白之分，取决于市场价格。</li></ul><h3 id="需求第二定律"><a href="#需求第二定律" class="headerlink" title="需求第二定律"></a>需求第二定律</h3><blockquote><p>需求对价格的弹性，和价格变化之后流逝的时间长度成正比。也就是说，随着时间的推移，需求对价格的弹性会增加。</p></blockquote><p>需求的价格弹性是指：在经济学中需求的数量随商品价格的变动而变化的弹性。弹性大于1时，指得是奢侈品；弹性小于1时，指的是必需品。它的公式是：<br>$$<br>需求的价格弹性=\frac{需求量的变化比例}{价格的变化比例}=\frac{\Delta Q/Q}{\Delta P/P}<br>$$<br>影响需求弹性的因素有：</p><ul><li>替代品得多寡：替代品越多，商品得需求弹性越大。</li><li>时间得长短：随着时间的长度增加，商品会愈来愈有弹性。</li><li>必需品还是奢侈品：必需品得需求弹性小，奢侈品得需求弹性大。</li></ul><h3 id="需求第三定理"><a href="#需求第三定理" class="headerlink" title="需求第三定理"></a>需求第三定理</h3><ul><li>每当消费者必须支付一笔附加费的时候，高品质的产品就相对低品质的产品变得便宜了，这笔附加费越高，高品质的产品就变得越便宜。这个定律也叫“好东西运到远方去定律”。</li><li>附加成本使精选产品相对价格变低。</li><li>附加成本对于交易得双方都是坏事。</li></ul><h1 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h1><h2 id="资源配置"><a href="#资源配置" class="headerlink" title="资源配置"></a>资源配置</h2><ol><li><p>计划经济不可预测</p><ul><li>人际效用不可比较，因为每个人对物品有不同的偏好，同步的估值。</li><li>数据不可得，在人类社会，很难获取精准的数据（人的能动性）</li><li>奖惩很难恰如其分，不能解决奖惩问题，人们就不能即使修正他们对未来的预期，并作出调整。</li></ul></li><li><p>“人类社会要解决的问题不是怎么让边际平衡的问题，而是发生了新的变化以后，我们应该如何应对的问题。”——哈耶克</p><blockquote><p>与变化相关的知识，是关于谁在什么地方、愿意以什么样的代价、购买什么商品的局部信息。哈耶克把这些局部信息称作“知识”。由于这些知识永远分散在不同人的大脑里，不可能集中，所以如何把这些分散的知识利用起来，从而对时刻不停的变化做出反应，才是人类社会要完成的艰巨任务。</p></blockquote></li><li><p>价格的作用</p><ol><li>解决「人际效用不可比较」的问题，价格可作为一把共同的尺子。</li><li>解决了「数据不可得」的问题，传递了稀缺的信息和数据</li><li>价格能指导生产</li><li>价值体系能解决奖惩的问题</li></ol></li></ol><h2 id="竞争的逻辑"><a href="#竞争的逻辑" class="headerlink" title="竞争的逻辑"></a>竞争的逻辑</h2><ol><li>人面临的一个最基本的约束就是「稀缺」，东西不够，拿该如何分配呢？有很多种竞争规则，如：<ul><li>暴力（最古老也是最常见的竞争方式）</li><li>拼智力（考试）</li><li>论资排辈界定产权（中国传统的“长幼尊卑”）</li><li>按社会身份分配财产</li><li>按劳动时间；随机分配；先到先得分配</li><li>按需分配。</li><li>价高者得</li></ul></li></ol><p>每一个竞争规则对于不同的人来说都有各自的优势和劣势，而每一种竞争规则都会带来成本。但是按照「价高者得」会引导不同的人从事自己最擅长的工作，积累资金相对容易，造成的无谓损失也是最少的。</p><ol start="2"><li><p>「短缺」</p><blockquote><p>短缺不是供应的减少，而是指在商品的<strong>价格受到抑制的情况</strong>下人们不仅要通过出价的方式去竞争，还需要依靠其他非价格的方式去竞争的一种特殊现象。</p></blockquote></li><li><p>「过剩」</p><blockquote><p>同样，过剩不是供给过多，而是<strong>商品的价格被人为地抬高</strong>，以至卖家必须搭配其他的竞争手段或服务，才能把商品卖出去的现象。过剩是价格被人为拔高的结果。</p></blockquote></li></ol><p>要解决「过剩」问题，就要限制产量。比如我们常听的”腐朽的资本主义把牛奶倒掉“、还有”巴西烧毁咖啡豆“。</p><ol start="4"><li>「稀缺」是永恒的，而「短缺」和「过剩」都是价格收到认为干预的解决。价格低（展开价格以外的竞争）出现短缺，价格高（采用价格以外的方式）出现过剩。</li></ol><h2 id="价格管制"><a href="#价格管制" class="headerlink" title="价格管制"></a>价格管制</h2><p>张五常先生，他的重要论文《一种价格管制理论》（1974）首先解释了什么叫价格管制。价格管制跟收税不一样。比方说一间公寓它的市价是100块钱，政府说这100元中，要征收40元的税。那么，其实政府就变成了二房东，房子的主人得60%的房租，40%就柜二房东，我们的政府所有。那这就是收税。</p><p>但价格管制不是收税，政府并没有要你的钱。政府说，你这房子的市价是100元，但是还是太高了，这房价不能超过60，那房东就少拿了40元，而这40元政府也并没有拿。政府只是颁布法令，说房租不能超过60元。</p><p>价格管制会产生两个重要的后果：</p><ol><li><p>价格管制必然导致价值耗散<br>只要有价格管制，房东得不到那40块钱，这时候他就不能够把房子用到价值最高的用途上去，也就是价值会耗散掉。就是说资源没有被用在刀刃上的时候，它举不那么值钱了。</p></li><li><p>人是追求损失最小化的动物<br>追求利润的最大化与损失最小化都是人性的特点，因此只要存在资源的损耗，人就会想办法选择能够尽可能挽回最大利益的竞争方式。</p></li></ol><h1 id="权力"><a href="#权力" class="headerlink" title="权力"></a>权力</h1><ol><li><p>权力的定义</p><blockquote><p>产权是一种通过社会强制而实现的、对某种经济物品的多种用途进行选择的权利。（ property right is socially enforced right to select uses of an economic good socially enforced）—— 阿尔钦</p><ul><li>权力通过社会强制而实现；</li><li>权力是别人授予我们的；</li><li>别人愿意来保护我们行使的自由才叫权力。</li></ul></blockquote></li><li><p>「能力」和「权力」</p></li></ol><p>能力（might）取决于自己能够占有多少，而权力（right）取决于社会上其他人愿意给你多少。（<em>拓展《你的权力从哪来？》</em>）</p><h2 id="产权"><a href="#产权" class="headerlink" title="产权"></a>产权</h2><p>产权的明确、产权的行使和保护都需要消耗成本。当权力的安排带来的好处够时，就会考虑界定产权。</p><h3 id="产权的兴起动力"><a href="#产权的兴起动力" class="headerlink" title="产权的兴起动力"></a>产权的兴起动力</h3><ol><li><p>外部性<br>由于资源有限，一个占有资源时，其他人就没有了。比如大航海时，猎人打猎人数很少。大航海后，动物的皮毛变得更加珍贵了，打猎人变多了，动物的数量越来越少，就产生了「外部性」。</p></li><li><p>人口聚集<br>交通运输成本持续大幅下降，使得人和货物远距离的旅行和运输成为可能，而这导致的直接后果，就是人和货物的高度集聚。<br>人可以密集地居住在一起，这时人与人之间的各种冲突也就越来越多，于是便产生了对产权，也就是对“排他性权利安排”的需求。</p></li></ol><h3 id="使用权、收益权和转让权"><a href="#使用权、收益权和转让权" class="headerlink" title="使用权、收益权和转让权"></a>使用权、收益权和转让权</h3><ul><li><strong>使用权：</strong>我们能决定资源怎样使用。「使用权」与「所有权」看似冲突，它们支付指的时在不同条件下的使用权。很多国家，地主持有土地的所有权，而农民有土地的使用权。</li><li><strong>收益分配权：</strong>一份资产会不断地提供服务，提供服务就会有报酬，无论是产权的暂时拥有者，还是它的永久拥有者，都有权去分配资产得到的收益，这是资产的收益权。</li><li><strong>转让权：</strong>转让权意味着把一份资产未来永久的、全部的使用权和收益权，一下子批发转让了。一个人，只有当他完全拥有一份资产时，他才能一次性地把一份资产未来每一个时刻的使用权和收益权都转让出去。</li></ul><h3 id="产权保护的三大原则"><a href="#产权保护的三大原则" class="headerlink" title="产权保护的三大原则"></a>产权保护的三大原则</h3><ol><li><p>财产原则</p><blockquote><p>一个人想要剥夺别人的产权，只有一个办法，就是向这个人付费，付到他愿意放弃为止。（政府对产权干预一次）</p></blockquote></li><li><p>责任原则</p><blockquote><p>当一个人侵害了别人的产权以后，侵害者就要向产权所有者赔偿，但是赔偿的金额不是由所有者确定，而是由第三方确定（政府干预两次，一次确权，二次在发生侵权时，政府来决定赔偿的金额）</p></blockquote><p>采用责任原则的一个核心理由是，采用财产原则来保护产权的成本太高，而伤害已经造成，这时只能由第三方对伤害做一个赔偿定价。</p></li><li><p>不可转让原则</p><blockquote><p>政府禁止所有权人把他所拥有的资产卖给别人。（政府干预三次，……第三次政府禁止原来的产权所有者出让他的产权）<br>政府采取不可转让原则的原因有：</p><ul><li>避免麻烦（涉及到国家安全，污染的企业；威胁现有的道德观：禁止买卖器官、卖淫等。）</li><li>父爱主义（政府觉得自己比个人更了解他们的利益，想像替儿子做决定一样）</li><li>自我执行的父爱主义（自己对自己信不过）</li></ul></blockquote></li></ol><h2 id="公共服务"><a href="#公共服务" class="headerlink" title="公共服务"></a>公共服务</h2><ol><li><p>公用品和私用品的区别</p><ul><li>私用品（private goods）的含义是一个人用了之后，别人就不能用。比如一个鸡蛋，一支铅笔。</li><li>公用品（public goods）的含义是一个人用的同时不影响别人使用的商品。比如一首歌，一个物理定律。</li></ul></li><li><p>「竞争性」和「排他性」是公用品和私用品判别维度<br>一个物品，一个人用了之后，别人就不能用了，把这称作“有竞争性”。<br>排他性，是指一件商品在实际使用时，物主能不能很方便地把其他的使用者排除在外。如果能比较方便地做到，就说它有排他性；不方便做到，就说它不具有排他性。</p></li><li><p>道路是公用品还是私用品，该不该对车辆收道路拥堵费<br>道路是私用品，因为某条道路上有一辆车在行驶（使用）就意味着会少一辆车能够上路。具有竞争性。道路作为典型的商品，征收道路拥堵费有意义：</p><ul><li>征收拥堵费会让道路产生排他性的使用权。</li><li>征收拥堵费可以刺激道路供给，收取拥堵费后，使用需求低的人就不会来参与竞争，自然就增加了供给。</li><li>征收拥堵费可以调节需求。</li></ul></li></ol><h1 id="耐心"><a href="#耐心" class="headerlink" title="耐心"></a>耐心</h1><h2 id="易耗品和耐用品"><a href="#易耗品和耐用品" class="headerlink" title="易耗品和耐用品"></a>易耗品和耐用品</h2><p>利息是人类社会最古老的现象之一，它起源于时间，起源于人的耐心。只要与时间有关的现象，都涉及利息。而根据时间的维度，世界上所有的产品、商品、资源，都可以简单地划分为两种：一种叫「易耗品」，一种叫「耐用品」。——费雪《利息理论》</p><ol><li><p>易耗品</p><blockquote><p>一次性能消费完毕的物品叫易耗品，比如一个苹果，一杯牛奶。</p></blockquote></li><li><p>耐用品</p><blockquote><p>必须在一个时间段内慢慢发散出来，只有在时间的维度才能体现它的价值。比如人力资源，艺术品。</p></blockquote></li></ol><h2 id="利率"><a href="#利率" class="headerlink" title="利率"></a>利率</h2><p>不耐（impatience）是指，因为未来具有不确定性（自然灾害、人为因素），人们总喜欢早一点消费，而不喜欢晚一点消费。</p><p>由于人与人之间的不耐程度是不同的，对自己手上的物品的估值不一样，有些人偏好现货，有些人偏好期货（未来），由「不耐」而产生的交易就叫不耐产生交易，现货和期货的比价，就是利率。不耐是利率的基础，未来越是不确定，接受期货的人所要索取的补偿就越大，这时候利率就越高。</p><ul><li><p><strong>利率管制会产生的影响</strong></p><ol><li>人们不愿意借钱给别人。</li><li>黑社会会应运而生，暗规则保证让人还钱。</li><li>人会选用迂回的方法支付利息。</li></ol></li><li><p>贴现率的概念</p><blockquote><p>贴现率就是未来价值（期值）转换为当前价值（现值）的打折程度。</p></blockquote></li></ul><h2 id="市场是否有规律"><a href="#市场是否有规律" class="headerlink" title="市场是否有规律"></a>市场是否有规律</h2><ol><li>有效市场假说——尤金·珐玛<blockquote><p>资产的价格已经反映了关于资产的内在价值的所有可得信息。</p></blockquote></li></ol><p>「有效市场假说」说的是市场没有泡沫，资产价格的波动非常有效，已经准确反映了所有可得的信息。</p><ol start="2"><li>市场泡沐沦——罗伯特·希勒<br>人是非理性的，人们的反应有时不足，有时又过激，而导致出现了一次次的股市泡沫。</li></ol><h2 id="保险与期货"><a href="#保险与期货" class="headerlink" title="保险与期货"></a>保险与期货</h2><ol><li>人的3个风险偏好，风险厌恶、风险偏好与风险中性，举个例子，我愿意给你10元钱，但有不同的给法。<ul><li>第一种给法，直接给你10元，没有任何风险；（属于风险厌恶）</li><li>第二种给法，给你10％的机会拿到100元，当然也有90％的可能一分钱都拿不到。（属于风险偏好）</li><li>第三种是哪一种都无所谓</li></ul></li></ol><h3 id="保险的原理"><a href="#保险的原理" class="headerlink" title="保险的原理"></a>保险的原理</h3><p>买保险的人是风险厌恶型的人，不喜欢变化。他们想要一种服务，无论未来如何，自己的收入是一样的。</p><ol><li><p>保险成立的三个前提</p><ul><li>事件的概率性：不能是确定的，有一定的发生几率。</li><li>概率的不相关性：投保的风险不能是全局性的，不能涉及到所有人。</li><li>概率的独立性：投保人自己不能控制风险的概率。</li></ul></li><li><p>保险运作的原理</p><ul><li>细分：将投保人细分可以把不同的人的风险做精确的划分，可以降低细分组里成员“占便宜”的现象，从而降低保费。</li><li>加总：在一个细分组里增加成员的数量，根据「大数定律」的原理，同样风险的人越多，他们之间产生风险的数学期望就月准确，离差越小，也能降低保费。</li></ul></li><li><p>失业保险和养老保险都不是保险<br>失业保险不是随机的事件，也不是独立的事件。而养老保险是一种社会补贴，它知识一个财产转移，把年轻人交的钱给老年人。</p></li></ol><h3 id="期货"><a href="#期货" class="headerlink" title="期货"></a>期货</h3><p>期货的全称是<strong>期货合约</strong></p><blockquote><p>其中一方被称为期货合约的买方，他答应在未来规定的时间内，按照规定的价格向期货合约的卖方购买规定数量的某种产品。</p></blockquote><p>期货的本质是分配风险，风险是不可能彻底避免了，有的人喜欢风险，让他们承担风险（可能更高的收益），有的人不喜欢风险， 让他们少承担风险（付出一定的代价），这种重新分配风险让两方都各的其所。</p><p>期货市场鼓励人们对未来做更准确的预测，对期货市场的预测越准确，又有更多的机会赚钱。</p><h1 id="供应"><a href="#供应" class="headerlink" title="供应"></a>供应</h1><h2 id="比较优势"><a href="#比较优势" class="headerlink" title="比较优势"></a>比较优势</h2><p>大卫·李嘉图在《政治经济学及赋税原理》</p><blockquote><p>在一个社会里，每个个体如果把有限的资源，包括时间和精力，只用来生产对他们来说机会成本比较低的那些产品，然后跟别人进行交换，这样整个社会产品的总价值就能达到最大，而且每一个个体的境遇都能得到改善，而不论他们的绝对生产能力是高还是低。</p><ul><li>可以是个人，可以是家庭，地区和国家。</li><li>每个个体的 时间和资源都是有限的。</li><li>比较优势可以自己和自己做比较。</li><li>每个个体都生产自己具有比较优势的产品，这样的成本最小，整个社会总产量会达到最大。</li></ul></blockquote><h2 id="受价者和觅价者"><a href="#受价者和觅价者" class="headerlink" title="受价者和觅价者"></a>受价者和觅价者</h2><ol><li><p>完全竞争状态与受价者<br>完全竞争状态：市场里有数不清的买家和卖家，交易的都是同一种商品，任何一位买家或者卖家都不能通过控制买卖量来影响价格，因为他个人的买卖量跟整个市场的买卖量相比是微不足道的。与此同时，任何一位买家或者卖家都可以随时进出市场，整个市场的交易费用很低。在这种状态下，所有卖家只能被动得接受市场得价格。</p></li><li><p>不完全竞争状态与觅价者<br>与完全竞争状态相对的一种状态，卖家对价格和产量具有一定的操控权。当价格提高时，需求量会降低，当价格过低时，收益和利润也会受影响，为了追求利润的最大化，卖家就寻求一个价格，并调整产量，这种卖家就是“觅价者”。</p></li></ol><h2 id="价格歧视"><a href="#价格歧视" class="headerlink" title="价格歧视"></a>价格歧视</h2><p>价格歧视可以消除无所谓损失，可以减少浪费，增加消费者满足感。</p><ul><li>价格歧视的三种方法（越是难以阻止消费者转售的产品，就越难实施价格歧视）<ol><li>完美的价格歧视：卖家对消费者所消费的每一个单位产品，都分别收取最高价格，但这只是一种理想状态。</li><li>二级价格歧视：对不同的购买量收取不同的价格，多买就便宜。</li><li>三级价格歧视：对不同人群或不同地区收取不同的价格。</li></ol></li></ul><h1 id="信息不对称"><a href="#信息不对称" class="headerlink" title="信息不对称"></a>信息不对称</h1><ul><li>信息不对称的表现：欺骗、偷懒、逆向选择、道德风险、敲竹杠</li><li>人际互信并不是天然存在的，如何通过制度来建立互信：<ol><li>重复交易，尤其在熟人市场的交易是基于重逢的重复交易</li><li>第三方背书，通过中间人担保，买家和卖家可以克服信息不对称的障碍。</li><li>增加产品的附加成本，好的产品才配得上更高的附加值。</li><li>品质三包服务</li><li>付出沉没成本、给出人质或抵押。</li></ol></li></ul><h2 id="汉德公式"><a href="#汉德公式" class="headerlink" title="汉德公式"></a>汉德公式</h2><p><strong>汉德公式是被广泛接受的判定各方责任的方法和标准之一</strong>，汉德公式的来源是1947年“美国诉卡罗尔拖船公司案”。</p><blockquote><p>拖般公司在一次拖船作业时的错误操作而未固定好一艘驳船，这艘载有美国政府面粉的驳船就在港口附近漂泊。这期间因与一艘油船相撞而损坏，并在漂泊了21个小时之后沉没。<br>这原本是一件普通的因操作失误引起的沉船事故。只是因为起事故中沉没的驳船上载有大量美国政府的面粉，而产生了巨大的经济损失。</p></blockquote><p>汉德公式的三个变量：避免意外的成本记作B，产生意外的概率记作P，意外产生的损失记作L</p><p>$$<br>B &lt; P × L<br>$$</p><table><thead><tr><th style="text-align:center">涉案方</th><th style="text-align:center">B</th><th style="text-align:center">L</th><th style="text-align:center">B&lt;P×L</th><th style="text-align:center">责任权重</th></tr></thead><tbody><tr><td style="text-align:center">美国政府</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">成立</td><td style="text-align:center">主要责任</td></tr><tr><td style="text-align:center">驳船公司</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">成立</td><td style="text-align:center">主要责任</td></tr><tr><td style="text-align:center">拖船公司</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">不成立</td><td style="text-align:center">非主要责任</td></tr><tr><td style="text-align:center">油船公司</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">不成立</td><td style="text-align:center">非主要责任</td></tr></tbody></table><p><em>来源：<a href="https://www.jianshu.com/p/301f2d2e5409" target="_blank" rel="noopener">https://www.jianshu.com/p/301f2d2e5409</a></em></p><p>汉德公式告诉我们：在众多选项中，成本最小的选项才是最优解。</p><h1 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h1><ol><li>企业的本质，企业能够无中生有的带来恶来收益的一种经济组织，每一个成员的收入取决于他对团队的边际贡献。<ul><li>企业的存在是因为有个人单干会有交易成本，企业内部的交易费用很低。</li><li>交易费用会限制企业的规模，随着企业规模的扩大，企业内部会有管理成本。</li><li>企业存在是因为有团队效用</li></ul></li></ol><h2 id="资本与劳动力"><a href="#资本与劳动力" class="headerlink" title="资本与劳动力"></a>资本与劳动力</h2><p>资本是弱者，劳动力是强者。因为资本投入的资金一旦投出就很难收回，而对于劳动者来说，他们投出的是劳动力，可以随时付出，也可以随时收回。</p><h2 id="专用资源与通用资源"><a href="#专用资源与通用资源" class="headerlink" title="专用资源与通用资源"></a>专用资源与通用资源</h2><ul><li>专用资源：经济学家把那些高度依赖于所在企业平台的资源，称为企业的专用资源；</li><li>通用资源：那些无论放到哪个企业平台都能发挥差不多的功能、获得差不多收益的资源。</li></ul><p>企业的专用资源必须是在特定的平台上才能发挥作用，所以让他们作为管理者会更在乎企业的成败。</p><h2 id="固定收入与剩余索取"><a href="#固定收入与剩余索取" class="headerlink" title="固定收入与剩余索取"></a>固定收入与剩余索取</h2><p>剩余索取者的收入不根据他们的投入来计算，而根据企业产出—剩余的利润—来计算。企业剩下多少他们拿多少，他们越努力企业剩下的就越多，他们得到的就越多。因此不需要再有人监督他们的工作，监督他们到底卖不卖力。他们自己监督自己，企业管理者往往是「剩余索取者」。</p><h1 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h1><h2 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h2><p>货币的作用在于，人人都觉得它有用，人人都觉得别人应该接受它，货币是一种「自发秩序」，货币的作用有：</p><ol><li><p>避免交易中双重偶然性的要求</p><p>如果采取 物-物 交易，就要求交易的双方对彼此交换的物品有需求，比如我有一头羊，想换一头猪，我恰好遇到有一个卖猪的人，这是第一种偶然性，而卖猪的也想要我手上的羊，这是第二重偶然性。</p></li><li>降低质量的检验成本</li><li>增加市场的交易量<br>没有了双重偶然性和较低的检验成本，市场的交易量将大大增加。</li></ol><h2 id="商业银行是如何创造货币的"><a href="#商业银行是如何创造货币的" class="headerlink" title="商业银行是如何创造货币的"></a>商业银行是如何创造货币的</h2><p>当一个人有1000块钱的时候，第一天把这1000一千块钱存到银行里。银行就会急于把这1000块贷出去，银行会收取利息。第二天，口袋里面有钱的人又把钱存到银行里面去，这时银行账户上又多了1000块钱。看似银行只要不断贷款，人们不断往银行里面存钱，银行上的钱会无止境地增加，但实际原来市场上的货币只有1000块钱。</p><p>但政府对于银行会有一个规定，收到储户存到银行账户上的钱必须要留下一部分钱当作“法定准备金”，如果规定的准备金是20%，银行在收到这1000块钱后只能贷出800块钱，这样1000块钱最多有5000块钱的货币流通。</p><p>因此，当银行的储户都要求把自己存的钱从银行里面取出来时，银行就会倒闭。</p><h2 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h2><p>通货膨胀是指物价的持续增长，这里的物质是指社会总的物价水平。可以通过货币数量论来理解理解通货膨胀<br>$$<br>MV=PY<br>$$<br>货币数量论：M是货币的流通量，V是货币流通的速度，P是平均物价，Y是社会的货物总量。经过简单的移项：<br>$$<br>P = \frac{MV}{Y}<br>$$<br>通过这个公式我们可以知道：</p><ul><li>货物总量越大，产生通货膨胀的机会越小。</li><li>货币的流通量和货币的流通速度越大，产生通货膨胀的机会越大。</li></ul><p>当货币发行量过大时，M就会无限增大。</p><h2 id="经济周期"><a href="#经济周期" class="headerlink" title="经济周期"></a>经济周期</h2><h3 id="奥地利学派"><a href="#奥地利学派" class="headerlink" title="奥地利学派"></a>奥地利学派</h3><p>奥地利学派并不是在学者的国籍，而是一种特有的研究方法和思路。</p><ol><li>奥地利学派的主张<ul><li>只有个人能做出选择</li><li>研究交易所在的市场是研究经济学的焦点所在，是在具体的市场环境中的。</li><li>研究经济现象要研究人的动机，要了解相应的人文背景。</li></ul></li><li>奥地利学派对经济周期的基本观点<ul><li>货币不是中性的，货币长期来看，对经济体中人与人的相对关系不会有什么影响。</li><li>资本是异质的，不是同质的，资本有其独特的使用方式，经济决策一旦做出，就很难撤回。</li><li>各种社会机构和安排是人们共同行为的结果，而不是计划的结果。</li></ul></li><li>奥地利学派看经济周期的起源<br>经济周期的起源是政府过度印钞，他们提出两点建议。<ul><li>金本位，以黄金的数量为发钞的依据。</li><li>实施自由发钞，现在的数字货币就是一种自由发钞制度。</li></ul></li></ol><h3 id="凯恩斯主义学派"><a href="#凯恩斯主义学派" class="headerlink" title="凯恩斯主义学派"></a>凯恩斯主义学派</h3><ol><li><p>凯恩斯主义看经济周期<br>凯恩斯主义认为社会总需求的降低，对就业、产量和价格的影响不是对等的。由于每当出现一需求不足的冲击时，价格的调整总是迟钝和缓慢的，因此真正受到冲击的是就业和产量，这是经济周期产生的原因。</p></li><li><p>凯恩斯主义的主张：加大政府开支<br>价格反应迟缓，市场没有办法自行调整，当社会总需求量不足时，政府代替人们形成需求，产生费用。那么政府的钱从哪来，靠货币政策（发钞）和财政政策（收税或借债）。</p></li></ol><h3 id="货币主义学派和理性预期学派"><a href="#货币主义学派和理性预期学派" class="headerlink" title="货币主义学派和理性预期学派"></a>货币主义学派和理性预期学派</h3><ol><li>货币主义学派<ul><li>坚持货币数量论，认为通货膨胀时因为货币超发。</li><li>货币长期来看是中性的。</li><li>制造通货膨胀不能降低失业率。</li><li>永久收入假说（人们拿到钱之后并不会马上取消费，而是存起来慢慢消费，追求长期幸福）</li></ul></li><li>理性预期学派<br>基本认可货币主义学派，但他们进一步提出，人们在决定自己的消费水平时会有预期，会盯住自己的长期收入。</li></ol><h3 id="真实的经济周期理论"><a href="#真实的经济周期理论" class="headerlink" title="真实的经济周期理论"></a>真实的经济周期理论</h3><p>这个理论认为经济周期时很自然的事，生活中到处都是冲击，要应付这些冲击，人们的反应不是即时的，而是滞后的，不是全面的，而是渐进的。这本身就是合理的。额外的干预不会解决问题，而只会产生新的问题。<br>这就是真实经济周期理论的核心思想。</p><h2 id="宏观经济经济学争论的原因"><a href="#宏观经济经济学争论的原因" class="headerlink" title="宏观经济经济学争论的原因"></a>宏观经济经济学争论的原因</h2><ol><li>第一，宏观经济现象涉及的变量太多，而我们研究的宏观经济现象本身，数量又是有限的。</li><li>第二，宏观变量本身是一些加总的变量，这些变量之间未必具有必然的因果关系。</li><li>第三，是人会形成预期，会产生对策。<br>知识和信息不仅会影响人的行为，更重要的是，知识和信息本身就存在一个增长的过程，它们本身就是不可预测的。</li><li>人类无法用科学的方法应对不确定性。<br>不确定性，指的是我们都不知道我们不知道的事情。当人们面对不确定性的冲击，当他们发现用精准的数学根本无力招架、无法应对的时候，他们就只能诉诸直觉、比喻、经验、自信以及勇气。这是宏观经济学真正深不可测的原因。</li></ol><p><strong>好的经济学家有什么样的特征：</strong></p><p>一个很重要的特征，就是他们能够看见看不见的。好的经济学思维不追求某种单一维度上的最大化，它追求的永远是在各种选项当中边际成本和边际收益的平衡。我们要从各种可能的选项入手，去看见那些看不见的。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>断断续续，通过做笔记的方式摘录、梳理章节内容，相当于又把这本书读了一遍，甚至比读一遍花了更多的时间，所以在读第一遍时没看懂的地方也看通了，最后谢谢薛老师带给我们这么好的作品。</p>]]></content>
    
    <summary type="html">
    
      薛老师的经济学课堂
    
    </summary>
    
      <category term="reading-list" scheme="http://lemmo.xyz/categories/reading-list/"/>
    
    
      <category term="经济学" scheme="http://lemmo.xyz/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Win10 家庭版启动组策略组件</title>
    <link href="http://lemmo.xyz/post/win10-home-gpedit.html"/>
    <id>http://lemmo.xyz/post/win10-home-gpedit.html</id>
    <published>2019-06-29T04:58:06.000Z</published>
    <updated>2019-06-29T04:58:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我之前用的系统一直是WIn10专业版，但是我手上这台笔记本是自带的家庭版，刚好今天需要在组策略中配置一些设置，通过Win+R 运行 <code>gpedit.msc</code>时却无法打开组策略，才知道家庭版是没有组策略这一功能的。本来都想着更换专业版的密钥，再用ksm来激活。</p><p>但通过搜索后发现，专业版和家庭版的镜像文件其实时一样的，想起来之前装系统的时有一个选择系统版本的选项，既然镜像文件时一样的，那么家庭版系统中肯定也有「组策略」这个功能，只是系统限制了这一功能，我们只要手动让它启动起来即可。</p><h1 id="启动组策略功能"><a href="#启动组策略功能" class="headerlink" title="启动组策略功能"></a>启动组策略功能</h1><ol><li><p>新建一个txt文件，比如<code>a.txt</code></p></li><li><p>在文本文件中，粘贴进几行代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">pushd</span> <span class="string">"%~dp0"</span></span><br><span class="line">dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt</span><br><span class="line">dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt</span><br><span class="line"><span class="keyword">for</span> /f %%i <span class="keyword">in</span> (<span class="string">'findstr /i . List.txt 2^&gt;nul'</span>) <span class="keyword">do</span> dism /online /norestart /add-package:<span class="string">"C:\Windows\servicing\Packages\%%i"</span></span><br><span class="line">pause</span><br></pre></td></tr></table></figure></li><li><p>把该文本文件的后缀改成可执行文件，如<code>a.cmd</code></p></li><li><p>右键单机a.cmd，并以管理员身份运行</p></li><li><p>等待执行完毕</p></li></ol><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/2019062934.png" alt=""></p><ol start="6"><li>Win+Q或Win+R搜索运行<code>gpedit.msc</code>，即可打开组策略</li></ol>]]></content>
    
    <summary type="html">
    
      给Win10 家庭版自动组策略组件
    
    </summary>
    
      <category term="Computer skills" scheme="http://lemmo.xyz/categories/Computer-skills/"/>
    
    
      <category term="gpedit" scheme="http://lemmo.xyz/tags/gpedit/"/>
    
      <category term="system" scheme="http://lemmo.xyz/tags/system/"/>
    
  </entry>
  
  <entry>
    <title>快速迁移系统</title>
    <link href="http://lemmo.xyz/post/Move-System.html"/>
    <id>http://lemmo.xyz/post/Move-System.html</id>
    <published>2019-06-28T08:32:05.000Z</published>
    <updated>2019-06-28T08:32:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的笔记本内置的固态是三星的一款M.2的SSD，但是是SATA协议的，因此只有500M/S的速率，但是另外空出来的一个插槽支持NVME协议。618的时候在京东上买了<code>Intel 760P</code>，装上之后才发现，这个插槽虽然支持NVME协议，但是只有2个通道，所以应该是PCIE * 2，速度只能达到正常速度的一半（读写都在1700M/S左右），后来想想买都买了懒得换了，至少比SATA的快。</p><h1 id="装上固态，迁移系统"><a href="#装上固态，迁移系统" class="headerlink" title="装上固态，迁移系统"></a>装上固态，迁移系统</h1><p>装固态没啥好写的，这里说一下装固态期间发生的一个小插曲。话说去取快递那天中午是刚参加完毕业典礼回来，下午还要去修改论文。因此想趁着中午的时候，就把固态装上测试一下，用买固态附送的小螺丝刀三五下就把外壳取下来，但取固态插槽那颗螺丝的时候给我整懵逼了，刚扭了一下螺丝就滑丝了。当时就在吐槽，机械革命你踏马为什么多此一举在这放一颗螺丝，放的话为什么不放一颗质量好一点的螺丝，吐槽归吐槽，还是要想办法把螺丝取下来，然后我就用小刀一点点给这颗螺丝刻凹槽，然后用一字起把这颗螺丝刀取出来了，最后换上买固态附送的螺丝。</p><p>Fine，装上固态之后，测了一下速便感觉一切索然无味。</p><p>直到今天，才想着把系统迁移到这块NVME的固态上，那么究竟用什么工具来迁移呢？其实很简单，大部分的磁盘工具都支持「磁盘克隆」，比如傲梅分区助手、DiskGenius。而我使用的是<code>因特尔数据迁移软件（Intel Data Migration Software）</code>，软件界面如下图所示：</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/2019062817.png" alt=""></p><p>这里有很多工具可以使用，但目前只需要使用第一个工具——「复制磁盘」，该工具的介绍为:</p><blockquote><p>该实用程序可帮助您将操作系统、应用程序和数据复制到新磁盘。新磁盘将与旧磁盘完全相同，而且会保留系统可启动性。</p></blockquote><p>进入工具后，在向导窗口根据步骤一步一步来操作就可以了，第一步是选择源磁盘，第二步选择目标磁盘，大概10分钟左右就可以全部完成（取决去你的两块硬盘的速度）</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190628175801.png" alt=""></p><p>克隆完成后，在资源管理器看不到<code>目标磁盘</code>，为了等会开机后区分新旧磁盘，可以在当前系统桌面上随便创建一个问题，比如创建一个txt文件。一些准备就绪之后，关机，再直接开机，发现桌面上没有刚才创建的那个txt文件，说明当前的系统已经是克隆后的系统，另外新硬盘的盘符也会与旧硬盘的盘符交换了，也不用自己取手动变更盘符了。</p>]]></content>
    
    <summary type="html">
    
      使用「因特尔数据迁移软件」的克隆磁盘的功能快速迁移系统
    
    </summary>
    
      <category term="Hardware" scheme="http://lemmo.xyz/categories/Hardware/"/>
    
    
      <category term="SSD" scheme="http://lemmo.xyz/tags/SSD/"/>
    
  </entry>
  
  <entry>
    <title>「我不知道该说什么，关于死亡还是爱情」书评</title>
    <link href="http://lemmo.xyz/post/Voices-from-Chernobyl.html"/>
    <id>http://lemmo.xyz/post/Voices-from-Chernobyl.html</id>
    <published>2019-05-29T16:36:20.000Z</published>
    <updated>2019-05-29T16:36:20.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">Title</td><td style="text-align:left">我不知道该说什么，关于死亡还是爱情</td></tr><tr><td style="text-align:left">Author</td><td style="text-align:left">[白俄罗斯]S.A.阿列克谢耶维奇</td></tr><tr><td style="text-align:left">Edition</td><td style="text-align:left">花城出版社</td></tr><tr><td style="text-align:left">Release Date</td><td style="text-align:left">2014-06</td></tr><tr><td style="text-align:left">ISBN</td><td style="text-align:left">9787536071377</td></tr></tbody></table><p>近期HBO的美剧《Chernobyl》的播出再次引起了我们对发生了三十多年前的那场悲剧的关注，由于前几年读也阅读了一本记录了切尔诺贝利的书，因此旧文重发，注意这本书还有另一个翻译版本——《切尔诺贝利的悲鸣》。<strong>以下部分为原文：</strong></p><p>我从未读过如此悲伤的文字，切尔诺贝利——这里所遇到在灾难是我从未看到的或者知道的，我只能用然人间地狱来称呼这里。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h1><p>切尔诺贝利是前苏联的一部分，属于白俄罗斯的领土。在1986年切尔诺贝利核电站四号反应堆发生大爆炸，这次灾难所释放出的辐射线剂量是投在广岛的原子弹的400倍以上。因这次事件死亡的人物不计其数，现在在这个只有一千多万人的小国中每五个人就有一个住在辐射区，总数为二百一十万，其中七十万是儿童。在受灾最重的地区死亡率比出生率高了20%！</p><p>这里的一切都是真实发生的，书中的每一段文字都是作者 <strong>S.A.阿列克谢列维奇</strong>走访受灾群众口述而成的。</p><h1 id="国家的英雄"><a href="#国家的英雄" class="headerlink" title="国家的英雄"></a><strong>国家的英雄</strong></h1><p>消防员瓦西里是最先进入爆炸核电站的人员之一，几个小时后他便被救护车送回来了，14天后由于大量辐射死于器官衰竭。“他是被自己的内脏呛到的，稍微咳嗽一下，他的肺和肝都可能随时从嘴巴里跑出来。”，讲述这个故事的人是他的妻子，那个时候她正怀有4个月的身孕，对于一般的人来说，原本这个时候正是她人生中最幸福的时刻，但却不得不面对这样的现实。对于吸收了1600伦琴辐射的丈夫（400伦琴就可致死），她选择的不是逃避，她骗了所有人，甚至不顾肚子里面的孩子偷偷跑到隔离间去照顾他，他全身溃烂，衣服沾到身上，妻子一点一点的帮他清理，给他喂药，陪着他说话。</p><p>什么是爱情，我没有经历过。但我想为了心中的挚爱就算是冒着生命危险也在所不惜，如果面对如此情形，我会如何选择呢？是转身离开把他和他的记忆留在记忆深处，开始一段新的生活。还是默默陪伴在她的身边，就算是死亡也在所不惜。</p><p>在这里，和瓦西里一样的年轻人不断从各地赶来。他们被叫做是国家的英雄，而国家给他们的任务却是用“铲子对抗原子”，多么荒谬的事情，他们在几百伦琴辐射工作，没有任何有效的保护装备。在年轻人中流传着一个笑话，一个美国机器人上屋顶作业五分钟，然后就发生故障了。日本机器人也上去作业了五分钟，然后也发生故障了。俄罗斯机器人来了，一上去就是两个小时！这时扩音器里传来了命令：“二等兵伊凡诺夫！再过两个小时，你就可以下来休息，抽根烟了。”</p><p>他们是国家的绿色机器人，在他们死亡时留给家人的只有刻有马克思、列宁头像的奖章。而国家给他们承诺的房子、车子消失了。</p><h1 id="无处不在的污染"><a href="#无处不在的污染" class="headerlink" title="无处不在的污染"></a><strong>无处不在的污染</strong></h1><p>切尔诺贝利是最可怕的战争，你无处可逃，地下、水里，空中都躲不了。牛奶，事物，土地中都含有大量的辐射。母亲在家门口哺乳，就像是切尔诺贝利的圣母，但她的母乳里却含有大量的铯元素，相当于是另一种凶猛的毒药，但是母亲是不自知的。</p><p>切尔诺贝利的人民，他们都不知道发生了什么。政府给他们的回复是“情势稳定”，一切还是和爆炸以前的一样。他们依然坚守在自己的土地上，对于他们来说，少了政府的管制倒也自由些了。而正是由于政府的愚弄和科学家的沉默让更多的切尔诺贝利的居民生活在辐射之中。</p><h1 id="切尔诺贝利的人"><a href="#切尔诺贝利的人" class="headerlink" title="切尔诺贝利的人"></a><strong>切尔诺贝利的人</strong></h1><p>突然有一天，你变成了切尔诺贝利人，变成了某种特殊的物种，大家对你感兴趣，却没有人真正愿意了解你。</p><p>如果仅仅只是这样，那也并不糟糕，让人感到痛心的是，切尔诺贝利的人们不仅要背负辐射的污染，更要背负人心的疏离。 </p><p>他们坐火车的时候，当得知他们是从切尔诺贝利来的，乘务员不愿意供给他们餐具和被子，周围的人也一下子保持沉默和疏离。上学的孩子一旦被得知是切尔诺贝利人，所有的小孩都排斥他，疏远他，不愿意更他交朋友，更不愿意亲近他。</p><p>而更让人感到荒诞的是，从切尔诺贝利事件中的幸存者，在面对爱情和婚姻时，遭到拒绝的理由却是：<strong>“你不能生孩子，生小孩对你来说是罪恶的。爱一个人对你来说都是一种罪恶”</strong>。亲历的讲述者说，你知道生小孩可能是一种罪吗？我以前从来没听过这种事。</p><p>受到核污染之后的好几年里，很多人并不愿意离开切尔诺贝利，他们知道自己无时无刻不遭受着污染，但是他们不愿离开，而这其中的原因是，因为在切尔诺贝利没有人会以怪异的眼光来看待你，也不会遭到他人的疏离、冷遇和提防。<strong>“至少当我拿自家的苹果给对方吃时，他会很高兴坦然的接受，而不是在转身就把这苹果处理掉。”</strong></p><p>让人感到痛心的是，切尔诺贝利的核污染现在仍然在继续，战争的伤痛总有停止的那一天，但是核辐射带来的污染却是无止境，也无从消灭。当我们在享受科技带来的便捷的同时，也不应忘却科技曾带给我们的灾难！</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/2019060434.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      人间地狱——来自切尔诺贝利的声音
    
    </summary>
    
      <category term="reading-list" scheme="http://lemmo.xyz/categories/reading-list/"/>
    
    
      <category term="纪实" scheme="http://lemmo.xyz/tags/%E7%BA%AA%E5%AE%9E/"/>
    
  </entry>
  
  <entry>
    <title>「中国国家治理的制度逻辑」读书笔记</title>
    <link href="http://lemmo.xyz/post/The-Institutional-Logic-of-Governance-In-China.html"/>
    <id>http://lemmo.xyz/post/The-Institutional-Logic-of-Governance-In-China.html</id>
    <published>2019-05-29T09:57:27.000Z</published>
    <updated>2019-05-29T09:57:27.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">Title</td><td style="text-align:left">中国国家治理的制度逻辑</td></tr><tr><td style="text-align:left">Author</td><td style="text-align:left">周雪光</td></tr><tr><td style="text-align:left">Edition</td><td style="text-align:left">三联书店</td></tr><tr><td style="text-align:left">Release Date</td><td style="text-align:left">2017-02</td></tr><tr><td style="text-align:left">ISBN</td><td style="text-align:left">9787559626295</td></tr></tbody></table><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>中国国家治理的一个深刻矛盾是一统体制与有效治理之间的矛盾。</li><li>国家治理模式决定了其政治运行特定的优势、负荷、困难和挑战。国家治理模式不是任意选择的，常常与个国家的历史演变过程有着深刻关系，有明显的途径依赖性。</li><li>一统体制的集中程度越高、越刚性，必然以相应程度上削弱地方治理权为代价，其有效治理的能力就会相应减弱；反之，有效治理能力的增强意味看地方政府治理权的扩张，常常表现在或被解读为各自为政，又会对一统体制产生巨大威胁。</li></ul>]]></content>
    
    <summary type="html">
    
      「中国国家治理的制度逻辑」读书笔记
    
    </summary>
    
      <category term="reading-list" scheme="http://lemmo.xyz/categories/reading-list/"/>
    
    
      <category term="政治" scheme="http://lemmo.xyz/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>「民主的逻辑」读书笔记</title>
    <link href="http://lemmo.xyz/post/Democracy-Logic.html"/>
    <id>http://lemmo.xyz/post/Democracy-Logic.html</id>
    <published>2019-05-25T12:02:07.000Z</published>
    <updated>2019-05-25T15:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">Title</td><td style="text-align:left">民主的逻辑</td></tr><tr><td style="text-align:left">Author</td><td style="text-align:left">包刚升</td></tr><tr><td style="text-align:left">Edition</td><td style="text-align:left">社会科学文献出版社</td></tr><tr><td style="text-align:left">Release Date</td><td style="text-align:left">2018-06</td></tr><tr><td style="text-align:left">ISBN</td><td style="text-align:left">9787520125819</td></tr></tbody></table><h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><ul><li>一个自由社会的良好公民需要同时做到两点，一是主张和捍卫自己应用的权力，二是遵守经合法程序指定的法律及服从合法的权威。</li><li>人是生而自由的，但却无往不在枷锁之中。自以为是其他一切的主人的人，反而比其他一切更是奴隶。——《社会契约论》</li><li>没有人假装民主是完美的和全智的（all wise），民主其实是最坏的政府形式，但要除了所有过去已经被尝试过的政府形式以外。——丘吉尔</li><li>经验告诉我们，民主转型更可能是一个结果不确定、充满各种挑战、历时漫长的政治过程。</li><li>自由是“一个人不受其他某人或某些人武断意志的强制”，或者说自由就是免于强制。——弗里德里希·哈耶克</li><li>现代民主是一种复合型政体，包含了古希腊贡献的民主因素古罗马贡献的共和主义传统、英格兰贡献的成熟代议制以及欧洲北美所贡献的政治平等逻辑。——罗伯特·达尔</li><li>欧洲历史意义上的封建主义体制是封君与封臣之间基于土地、融合了财产权利与政治权利的契约关系。这种契约关系的核心是:封君或领主应提供保护和尊重习惯，而封臣或附庸应提供兵役和表示效忠。</li><li>《独立宣言》开篇语是对英国哲学家约翰·洛克《政府论》下篇的模仿洛克认为，人类组成政治社会的目的，是为了保护每一个社会成员的生命权、自由权与财产权。《独立宣言》还认为，政府需要经过被治者的同意。</li><li>美国的土地制度和自耕农模式的结合还强化了美国的个人主义文化。</li><li>自耕农模式下的美国人更崇尚个人奋斗与自力更生，崇尚依靠自己而不是依靠国家、相信通过自己的努力来改善命运而不是依赖政府供给与社会福利。</li><li>在一个尚未充分工业化的农业社会土地分配的不平等就是最大的不平等。</li><li>资产阶级最想要的制度安排应该是立宪政治、法治国家、有限政府、分权制衡以及自由市场体制。</li><li>一个稳定的和有效率的民主政府，不光是依靠政府结构和政治结构；它依靠人民所具有的对政治过程的取向<br>，即政治文化。——里埃尔·阿尔蒙德</li><li>一旦政治竞争是完全意义上的赢家通吃，政治斗争就容易走向不择手段和丧失底线。</li><li>多数决定制更容易导致两党制比例代表制更容易导致多党制。——迪韦尔热</li><li>对一个国家来说，有什么样的政治精英就有什么样的政治；对一个国家的民主转型来说，有什么样的政治精英就有什么样的民主转型。</li><li>政府——无论是民主的还是威权的一—本身无法创造财富，它能做的就是转移财富。</li><li>民主选举往往是政治动员的重要驱动力，而在那些族群、宗教多样化程度很高的国家，精英们容易选择将这种族群、宗教分歧政治化，并以此为基础进行政治动员，结果就容易导致政治暴力。——《从投票到暴力》</li><li>在人类历史的长河中，文明的此起彼伏乃是一种常态。</li><li>当特定族群、宗教和语言的人口到达一定规模后，就容易产生聚居效应。</li><li>今天全球威权政体或多或少都面临着一个基本问题，那就是合法性的困境。</li><li>从20世纪以来的人类政治史来看，很多愚蠢的乃至灾难性的重大决策都是威权体制下少数领导人刚愎自用、一意孤行的产物。</li><li>与民主政体相比，威权政体往往需要维持更为庞大的内务部门（警察与安全部门），需要花费更高的成本来压制潜在的反对力量，这种成本最终都需要整个社会来承担。</li><li>威权体制通常还会禁止某些外部思想或信息的输入，甚至需要建立一个更封闭的经济、政治与信息体系这种做法有时看起来不过是维护体制稳定的权宜之计，但其长期后果可能非常严重，有可能阻碍一个国家的经济增长、科学进步、产业升级与整体创新能力。</li><li>通往奴役的道路，往往是由善良的愿望铺成的。——哈耶克《通往奴役之路》</li><li>政治生活的另一面是，即便人类无法实现完美的政治乌托邦，但现实政治通常都有着巨大的可改善空间，而且我们也不应该放弃这种改善现实政治的希望。</li></ul><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><h2 id="民主的概念"><a href="#民主的概念" class="headerlink" title="民主的概念"></a>民主的概念</h2><h3 id="1-0版本：人民的统治"><a href="#1-0版本：人民的统治" class="headerlink" title="1.0版本：人民的统治"></a>1.0版本：人民的统治</h3><ul><li>谁是“人民”<ul><li>公民</li><li>政治共同体的大多数人</li><li>政治共同体中政治正确的那部分人</li></ul></li><li>怎么统治<ul><li>直接统治</li><li>间接统治</li><li>采取某种程序和方式来制定国家制度</li></ul></li><li>问题<ul><li>无法辨别“民主”的真伪</li></ul></li></ul><h3 id="2-0版本：竞争性的选举制度"><a href="#2-0版本：竞争性的选举制度" class="headerlink" title="2.0版本：竞争性的选举制度"></a>2.0版本：竞争性的选举制度</h3><ul><li>要素<ul><li>政治竞争：政治精英展开政治竞争</li><li>政治参与：普通公民具有投票权</li></ul></li><li>问题<ul><li>无法确保选举的公正性</li></ul></li></ul><h3 id="3-0版本：选举民主-法治"><a href="#3-0版本：选举民主-法治" class="headerlink" title="3.0版本：选举民主+法治"></a>3.0版本：选举民主+法治</h3><ul><li>法治的作用<ul><li>保护了公民的基本权利</li><li>确保法治的自由与公正</li><li>约束执政者守法、恪守民主规则</li><li>解决政治争端</li></ul></li><li>问题<ul><li>不是存粹讨论民主，而是民主和其他的混合物</li></ul></li></ul><h2 id="民主的起源"><a href="#民主的起源" class="headerlink" title="民主的起源"></a>民主的起源</h2><h3 id="雅典城邦民主"><a href="#雅典城邦民主" class="headerlink" title="雅典城邦民主"></a>雅典城邦民主</h3><ul><li>形成的原因<ul><li>地理因素<br>古希腊海岸曲折、岛屿众多、陆地多山</li><li>阶级斗争假说</li><li>军事技术假说</li></ul></li><li><p>三次改革</p><ul><li><p>卢梭改革</p><ul><li>BC594</li><li>经济改革<ul><li>取消平民债务</li><li>取消土地抵押</li></ul></li><li>政治改革<ul><li>将雅典公民划分为四个财产登记</li><li>设立四百人制度</li><li>司法审判制度（陪审团）</li></ul></li></ul></li><li><p>克里斯提尼改革</p><ul><li>卢梭改革80年之后</li><li>设立以德谟（村）为基础的治理单位</li><li>选举产生十将军制度</li></ul></li><li><p>伯里克利改革</p><ul><li>公元前五世纪</li><li>设立支薪制度<br>给出席五百人会议、陪审团和行政长官提供日薪</li><li>确定“公民权”<br>父母双方皆为雅典公民，子女自动成为雅典公民</li></ul></li></ul></li><li><p>如何运作</p><ul><li>公民大会（最高权力单位）</li><li>五百人议事会</li><li>行政官员（抽签+选举 产生）</li><li>陪审法庭（至少200人，且为单数）</li><li>陶片放逐<br>对可能的“危险分子”实施放逐，放逐时间为10年，但放逐者的财产和地位不受影响。每个公民持有陶片并写上放逐人的姓名，在指定的时间放到投票箱，如果有效票数超过6000，则出现姓名最多的人将被放逐。</li></ul></li></ul><h3 id="古罗马共和制"><a href="#古罗马共和制" class="headerlink" title="古罗马共和制"></a>古罗马共和制</h3><ul><li>混合政体&amp;制衡政制<ul><li>君主因素（执政官）<ul><li>由两名执政官和多名副执政官构成</li><li>由平民大会选举构成</li><li>职责是领导国家和指挥战争</li></ul></li><li>贵族因素（元老院）<ul><li>最初由贵族组成，后期人数慢慢扩大</li><li>职责<ul><li>控制共和国政府的预算和资金</li><li>管理日常公共事务</li><li>任命行省官员</li></ul></li></ul></li><li>民主因素（平民大会、保民会）<ul><li>选举产生执政官</li><li>颁布法律</li></ul></li></ul></li><li>问题与挑战<ul><li><ol><li>国家规模和行省统治</li></ol></li><li><ol start="2"><li>无休止的战争导致军事化倾向</li></ol></li><li><ol start="3"><li>财富结构和阶级结构的变化</li></ol></li></ul></li><li>影响<ul><li>共和制政体持续了五个世纪</li><li>对欧洲和世界产生了近千年的影响</li></ul></li></ul><h3 id="英国议会制度"><a href="#英国议会制度" class="headerlink" title="英国议会制度"></a>英国议会制度</h3><ul><li><ol><li>约束国王权利</li></ol><ul><li>1215年《大宪章》<ol><li>国王的权利应该受到原则性的约束（“国王不应受限于任何人，但应该首先于上帝和法律”）。</li><li>纠正国王过去的错误。</li></ol></li><li>1258年《牛津条约》<ol><li>重新确立的《大宪章》的有效性。</li><li>规定了国王违法《大宪章》后，贵族和公民反抗的合法性。</li><li>国王处理国家公共事务需要遵从贵族会议。</li></ol></li></ul></li><li><ol start="2"><li>议会主权形成</li></ol><ul><li>1688年“光荣革命”<br>国王成为一个符号，统而不治</li></ul></li><li><ol start="3"><li>责任政府形成</li></ol><ul><li>1720年起组建内阁</li></ul></li><li><ol start="4"><li>落实普选权</li></ol><ul><li>1832年—1928年</li><li>原因<ul><li>社会因素<br>工业革命、城市化以及大规模工厂组织的出现。普通人的公民意识和政治参与意识开始觉醒。</li><li>政治因素</li></ul></li></ul></li></ul><h3 id="三波民主化浪潮"><a href="#三波民主化浪潮" class="headerlink" title="三波民主化浪潮"></a>三波民主化浪潮</h3><ul><li><p>民主政体的最低标准<br>亨廷顿《第三波》</p><ul><li><ol><li>50%成年男子有普选权</li></ol></li><li><ol start="2"><li>政府首脑依靠民选议会的多数支持或定期普选产生</li></ol></li></ul></li><li><p>第一波：始于欧美</p><ul><li>主要时间：1828—1926</li><li>两个重大事件<ul><li>美国革命<ul><li>重要文件<ul><li>1776年《独立宣言》</li><li>1783年《美国宪法》</li><li>1965年《投票权利法案》</li></ul></li><li>民主化进程的因素<ul><li>共和制宪法为国家指明了道路</li><li>政治家、立法者和大法官的努力</li><li>英国的政治制度对美国的影响</li><li>美国的土地制度</li></ul></li><li>影响<ul><li>美国经济、科学和学术的成为成为全球发展的典范</li><li>直接影响了全球民主政体发展（德国、日本等）</li><li>美国确立的“民主化外交，推动全球意识形态的重塑</li></ul></li></ul></li><li>法国革命<ul><li>重要文件<ul><li>《人权与公民权宣言》</li><li>《拿破仑法典》</li></ul></li><li>历程<ul><li>1789年“法国大革命”：第一共和国</li><li>1799年-1815年：拿破仑第一帝国</li><li>持续30多年：波旁王朝和六月王朝</li><li>1848年-欧洲革命：第二共和国</li><li>1875年-1940：第三共和国</li></ul></li></ul></li></ul></li><li>特征<ul><li>现代世界民主化的第一次尝试</li><li>逐步民主化，普选权扩大</li><li>民主国家作为工业化和全球化影响了全球民主化</li><li>西方重大事件对世界民主化进程产生了影响</li><li>民主化主要集中在西方少部分地区</li></ul></li></ul></li><li><p>第二波：走出西方</p><ul><li>主要时间：1943—1963</li><li><p>两个大事件</p><ul><li>第一次世界大战的结束</li><li>亚洲和非洲去殖民化浪潮</li></ul></li><li><p>典型国家</p><ul><li>德国<ul><li>1918年之前：德意志第二帝国<br>有宪法、议会、定期选举和政党政治。但德国首相和议会对皇帝负责而非对议会负责</li><li>1918—1933：魏玛共和国</li><li>1933—1945：法西斯极权体制</li><li>1945后：联邦德国（西德）启动民主化进程</li></ul></li><li>印度</li><li>尼日利亚</li></ul></li><li><p>特征</p><ul><li>驱动力：二战的结束、去殖民化运动</li><li>民主已经成为全球支配性的意识形态</li><li>大规模进入欧洲，亚非也开始兴起</li><li>收到了全球化深入发展的影响</li></ul></li></ul></li><li><p>第三波：全球时代</p><ul><li>主要时间：1974—</li><li><p>西班牙</p><ul><li>西班牙竞争性政体的传统</li><li>佛朗哥时期的经济发展</li><li>处于西南欧（周围有英法德意）</li></ul></li><li><p>俄罗斯</p><ul><li>20世纪80年代—1911苏联解体：戈尔巴乔夫</li><li>1911—1999：叶利钦改革</li><li>2000—至今：普京时代</li></ul></li><li><p>韩国</p></li><li>智利</li><li><p>阿拉伯之春（冬）</p><ul><li><p>代表</p><ul><li>突尼斯</li><li>利比亚</li><li>埃及</li><li>土耳其</li></ul></li><li><p>影响中东北非政治改革的因素</p><ul><li>威权政体类型（君主制/非君主制）</li><li>是否拥有丰裕的石油资源<br>政府有石油资源有利于维护本国政体的稳定</li><li>伊斯兰世界极端恐怖注意势力</li></ul></li></ul></li><li>特征<ul><li>1.规模最大的民主化运动</li><li>2.民主国家的数量超过非民主国家</li><li>3.受到冷战结束、欧盟的影响</li><li>4.处于完全工业化和充分全球化环境</li></ul></li></ul></li></ul><h2 id="民主治理绩效"><a href="#民主治理绩效" class="headerlink" title="民主治理绩效"></a>民主治理绩效</h2><h3 id="民主能否带来经济增长？"><a href="#民主能否带来经济增长？" class="headerlink" title="民主能否带来经济增长？"></a>民主能否带来经济增长？</h3><ul><li>能<ul><li>1.政府权利受到了限制，立宪和法治的政府能促进经济增长</li><li>2.公共政策能得到更好的回应，能体现公共利益</li><li>3.公共教育文化和人力资本的提升速度更快</li><li>4.民主的国家具有更好的创新能力，因为自由的环境下更利于创新</li></ul></li><li>否<ul><li>1.民主不一定能形成有效的政府、形成有效的决策和解决问题的能力</li><li>2.基于民意和多数决定不一定能形成明明智的决策</li><li>3.民主更容易导致较低的投资率</li><li>4.民主政体下的政策更导致民粹化</li></ul></li></ul><h3 id="民主能否带来好的公共治理？"><a href="#民主能否带来好的公共治理？" class="headerlink" title="民主能否带来好的公共治理？"></a>民主能否带来好的公共治理？</h3><ul><li>“全球治理指数”标准<ul><li>公共表达和问责制</li><li>政治稳定和控制暴力</li><li>政府效能</li><li>管制质量</li><li>法治</li><li>控制腐败度</li></ul></li><li>能<ul><li>1.政府权利受到约束</li><li>2.公共政策更有回应性</li><li>3.民主的治理是基于公共利益的</li></ul></li><li>否<ul><li>1.低民主国家处于无法治理的状态</li><li>2.政治精英能力和品质不行</li><li>3.不能形成良好的公共政策</li></ul></li></ul><h3 id="民主能否促进平等？"><a href="#民主能否促进平等？" class="headerlink" title="民主能否促进平等？"></a>民主能否促进平等？</h3><ul><li>政治平等<ul><li>形式：每个公民有同等的政治权利</li><li>实质：每个公民的政治影响力均等化</li></ul></li><li>经济平等<ul><li>形式：每个具有同等基本经济权利</li><li>实质：每个人的财富均等化</li></ul></li><li>民主和非民主相比，实现了更大程度上的形式或程序平等</li></ul><h3 id="民主能否减少政治冲突？"><a href="#民主能否减少政治冲突？" class="headerlink" title="民主能否减少政治冲突？"></a>民主能否减少政治冲突？</h3><ul><li>政治冲突的来源<ul><li>阶级政治的挑战</li><li>身份认同的危机（宗教和种族）</li><li>意识形态的分歧</li></ul></li><li>民主程度低<ul><li>政治暴力概率低</li><li>导致冲突的诱因被威权政体控制住了</li></ul></li><li>民主程度提高<ul><li>政治暴力发生概率提高</li><li>政治斗争和政治动员被强化了</li></ul></li><li>民主程度高<ul><li>政治暴力的概率下降</li><li>民主机制和平、有效解决政治分歧</li></ul></li></ul><h2 id="民主的兴衰成因"><a href="#民主的兴衰成因" class="headerlink" title="民主的兴衰成因"></a>民主的兴衰成因</h2><h3 id="经济社会条件论"><a href="#经济社会条件论" class="headerlink" title="经济社会条件论"></a>经济社会条件论</h3><ul><li>经济发展</li><li>富裕的国家更容易维持民主，而在贫穷的国家更容易崩溃。</li><li>阶级结构<ul><li>资产阶级有利于民主</li><li>对于威权政体和民主政体，资产阶级面对的是“两害相权取其轻”而采取的政治抉择。</li><li>民主政体：一人一票的普通民众会对自己的资产造成威胁。</li><li>威权政府：威权政府的胡作非为，政府的权利不受限制。可能会面临政府通过各种方式剥夺有产阶级的财产。</li><li>无产阶级推动落实普选权推动民主</li><li>中产阶级更少的阶级斗争有利于民主</li></ul></li><li>群组宗教结构</li><li>族群或宗教的分化结构与民主转型挫败的可能性是一个倒U曲线的关系：</li><li><ol><li>族群较少，由族群分歧或宗教分歧导致的政治冲突可能性较少</li></ol></li><li><ol start="2"><li>族群较多，可能导致的严重政治冲突会增大</li></ol></li><li><ol start="3"><li>族群宗教分化继续增大时，基于族群-宗教的政治认同感降低了。</li></ol></li><li>政治文化</li><li>国际因素</li><li>国家因素</li></ul><h3 id="政治制度论"><a href="#政治制度论" class="headerlink" title="政治制度论"></a>政治制度论</h3><ul><li>民主政治制度<ul><li>总统制</li><li>半总统制</li><li>议会制</li></ul></li><li>选取的制度</li><li>议会的规模：</li><li>规模大：好处是代表性很充分，坏处是议事效率和效能受到影响</li><li>规模小：好处是议事简便，坏处是代表性不足，容易被少数政治家操控<ul><li>多数决定制</li><li>比例决定制</li><li>混合制</li></ul></li></ul><h3 id="政治精英论"><a href="#政治精英论" class="headerlink" title="政治精英论"></a>政治精英论</h3><ul><li>政治精英影响国家政治</li><li>政治精英影响民主转型</li></ul><h2 id="民主的现状及未来"><a href="#民主的现状及未来" class="headerlink" title="民主的现状及未来"></a>民主的现状及未来</h2><h3 id="民主政体国家的治理挑战"><a href="#民主政体国家的治理挑战" class="headerlink" title="民主政体国家的治理挑战"></a>民主政体国家的治理挑战</h3><ul><li>大政府的兴起<ul><li>原因<ul><li>工业化、城市化对公共服务的需求</li><li>民主化时代选民的需求</li><li>现代国家官僚体制的扩张</li></ul></li><li>后果<ul><li>政府责任和权利范围的扩张</li><li>高福利倾向和在分配倾向</li><li>社会税负会越来越重</li><li>小政府模式的终结和个人精神衰退</li></ul></li></ul></li><li>市场经济、贫富分化和民主治理</li><li>群组宗教的多样化</li></ul><h3 id="新兴民主国家的转型难题"><a href="#新兴民主国家的转型难题" class="headerlink" title="新兴民主国家的转型难题"></a>新兴民主国家的转型难题</h3><ul><li>民主运行起来<ul><li>没有重要政治力量反对民主</li><li>政治力量的竞争能达到均衡</li></ul></li><li>民主产生绩效<ul><li>有效的国家治理和治理绩效</li></ul></li><li>民主得到巩固<ul><li>民主的制度化、管理话和稳固化</li><li>政治文化的转型</li></ul></li></ul><h3 id="威权政体的困境、复兴与前景"><a href="#威权政体的困境、复兴与前景" class="headerlink" title="威权政体的困境、复兴与前景"></a>威权政体的困境、复兴与前景</h3><ul><li>威权政体的价值取向<ul><li>发展导向</li><li>掠夺导向</li></ul></li><li>多层委托代理关系的困境<ul><li>大型威权政体面临代理链长而导致的治理难度更大</li><li>威权国家的官方腐败问题严重影响着治理的效能问题</li></ul></li><li>政治决定和公共政策的风险<ul><li>威权政体下，决策失误可能性更高。纠错成本也更高</li></ul></li><li>更高的维护稳定的成本<ul><li>庞大的内务（国安、警察）系统</li><li>需要封闭的经济、政治和信息体系（阻碍经济增长、产业和创新能力）</li></ul></li><li>独权的领导人风险<ul><li>威权政体下领导人的选择透明度低</li><li>没有有效对领导人权利的限制制度</li></ul></li></ul><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>MindNode笔记： <a href="https://my.mindnode.com/NxH7GR6a6krujfBLqu2B5EJ43DQ21DCmx7nVznLx" target="_blank" rel="noopener">https://my.mindnode.com/NxH7GR6a6krujfBLqu2B5EJ43DQ21DCmx7nVznLx</a></p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/%E6%B0%91%E4%B8%BB%E7%9A%84%E9%80%BB%E8%BE%91.png" alt=""></p><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>花了几天时间阅读包老师《民主的逻辑》，首先在这本书作为一个可读性很高，阅读起来没有想象中的难。整本书的逻辑框架非常清晰，很有条理性。内容上来说，介绍民主的起源，民主的内涵，分析了高民主国家、民主转型中国家、威权政体国家发展的现状及其优势和问题。书中有非常多的引述，包括常见的政治哲学类、社科类的专著。比较遗憾的是大部分内容只是作者对目前上学术界观点的总结概括，而自己的观点相对比较少。总的来说，通过这本能帮助我们理清民主的各个方面，全面地理性地看待“民主”这一政体。比刘瑜的《民主的细节》更加系统全面，也更加严谨。</p>]]></content>
    
    <summary type="html">
    
      「民主的逻辑」读书笔记
    
    </summary>
    
      <category term="reading-list" scheme="http://lemmo.xyz/categories/reading-list/"/>
    
    
      <category term="政治" scheme="http://lemmo.xyz/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="包刚升" scheme="http://lemmo.xyz/tags/%E5%8C%85%E5%88%9A%E5%8D%87/"/>
    
      <category term="民主" scheme="http://lemmo.xyz/tags/%E6%B0%91%E4%B8%BB/"/>
    
  </entry>
  
  <entry>
    <title>在NAS上搭建FTP服务</title>
    <link href="http://lemmo.xyz/post/Build-Ftp-Server-On-NAS.html"/>
    <id>http://lemmo.xyz/post/Build-Ftp-Server-On-NAS.html</id>
    <published>2019-04-06T15:02:51.000Z</published>
    <updated>2019-04-06T15:02:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在家的时候，多设备之间共享文件是直接访问NAS，很方便。但目前在学校的校园网环境下，虽说可以远程登陆NAS来传输文件，但是两端的设备都需要先登陆NAS，再找到指定路径，再上传/下载。所以一般我要多设备同步文件，一般是通过QQ、微信和Telegram来发送。</p><p>今天突然想起来可以使用「FTP服务」来同步文件，首先想到的是在「VPS」上搭「FTP服务」，但是有几个问题：一是连接速度和流量限制的问题，毕竟VPS在海外，而且也会浪费VPS的流量；二是VPS的存储容量有限；还有就是资料安全性的问题，如果要更换VPS了，这些资料还要下载下来。</p><p>记起来QNAP是支持搭建FTP服务的，本来NAS上存放的就是一些文件，安全性和速度都比VPS上好一些。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul><li>网络环境为公网IP（<em>如果没有需要需要「内网穿透」服务</em>）</li><li>路由器支持DDNS和端口转发（<em>一般的路由器都支持</em>）</li><li>支持搭建FTP服务的NAS</li></ul><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="QNAP中打开「FTP服务」"><a href="#QNAP中打开「FTP服务」" class="headerlink" title="QNAP中打开「FTP服务」"></a>QNAP中打开「FTP服务」</h2><p>登陆NAS后，操作流程：点击【控制台】-&gt;【网络&amp;文件服务】-&gt;【FTP】</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/2019040609.png" alt=""></p><ul><li>把「启动FTP服务器功能」勾选上</li><li>协议类型：FTP</li><li>端口：默认是21</li><li>Unicode支持：默认是关闭的，使用的 FTP 软件不支持 Unicode 的话，请将 Unicode 支持设成”否”</li><li>允许匿名：如果不允许匿名，则需要NAS用户名和密码来登陆</li><li>连接：按字面意思设置即可，一般为默认</li><li>高级设置-设置根目录：FTP连接的路径地址</li></ul><h2 id="路由器设置"><a href="#路由器设置" class="headerlink" title="路由器设置"></a>路由器设置</h2><ol><li><p>设置DDNS<br>设置路由器的远程管理的时候，我已经设置过DDNS了，如图：<br><img src="https://raw.githubusercontent.com/yslemmo/Images/master/2019040628.png" alt=""></p></li><li><p>添加端口转发<br>注意：服务器IP是指NAS的内部IP地址，我已经在「DHCP」中将NAS的ip地址固定了<br><img src="https://raw.githubusercontent.com/yslemmo/Images/master/2019040631.png" alt=""></p></li></ol><h1 id="连接FTP服务"><a href="#连接FTP服务" class="headerlink" title="连接FTP服务"></a>连接FTP服务</h1><h2 id="Windows连接FTP服务"><a href="#Windows连接FTP服务" class="headerlink" title="Windows连接FTP服务"></a>Windows连接FTP服务</h2><ol><li>Windows可以直接在「资源管理器-此电脑」右键中「添加一个网络位置」，网络地址填：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://ip地址或动态域名地址/子路径</span><br></pre></td></tr></table></figure><p>再填用户名和密码，通过这种方式可以像使用自己的磁盘一样使用，但是不用直接双击直接打开文件，需要先复制到本地路径，它的速度取决于两端的上传和下载速度。</p><ol start="2"><li>使用FTP连接软件<br>如Total Command、FlashFXP等等</li></ol><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><p>连接方式和Windos类似，都需要FTP服务器地址、用户名和密码。</p><ol><li>Android可以使用「Solid Explorer」。</li><li>IOS可以使用「Documents（Readdle公司）」</li></ol>]]></content>
    
    <summary type="html">
    
      更快捷地实现多设备传输文件的问题
    
    </summary>
    
      <category term="computer skills" scheme="http://lemmo.xyz/categories/computer-skills/"/>
    
    
      <category term="文件管理" scheme="http://lemmo.xyz/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
      <category term="ftp" scheme="http://lemmo.xyz/tags/ftp/"/>
    
  </entry>
  
  <entry>
    <title>「风中有朵雨做的云」观后</title>
    <link href="http://lemmo.xyz/post/Cloud-in-the-Wind.html"/>
    <id>http://lemmo.xyz/post/Cloud-in-the-Wind.html</id>
    <published>2019-04-04T11:46:43.000Z</published>
    <updated>2019-04-04T11:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情节概述"><a href="#情节概述" class="headerlink" title="情节概述"></a>情节概述</h1><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190404201359.png" alt=""></p><p>这是一部在改革开放背景下，由城市建设拆迁而引发的利益、官商勾结的故事。因为「风雨云」并不是宏大叙事，所以上面的只是故事的背景而已，通过这一切口去展示其中“腐烂的现实”。</p><p>电影是以一场拆迁地坠楼案展开的，坠楼的是人正是开发区的领导—— 唐奕杰。因为当地抗拆居民和开发商发生了骚乱，唐奕杰为了维稳而赶到拆迁现场，去勘察楼层情况时突然坠楼身亡。唐的死亡原因就成了电影的最大疑点和情节发展的主要驱动力，是失足跌落、自杀还是ta杀，考虑了唐的性格和当前的现场环境，最大的可能是“ta杀”，围绕着这一事件，角色一个个登场了：</p><ul><li>杨家栋：当地年轻的警官，负责唐的坠楼案，揭露真相唐死亡的真相，也是为了揭露他父亲车祸的真相。</li><li>林慧：唐奕杰的妻子，和姜紫成是朋友兼情人。</li><li>小诺：唐奕杰的“女儿”。</li><li>姜紫成：地产商人，紫金置业的老板。小诺的亲生父亲。</li><li>连阿云：影片刚开始的无名女尸，台湾坐台小姐，姜紫成的情人，后被包装姜的商业伙伴。</li></ul><p>因为剧情比较复杂，这里就不再详细梳理了。接下来的故事是以“杨家栋”开始调查唐坠楼案而展开，因为唐坠楼案后的利益关系，姜紫成对杨家栋调查这一案件而不断阻挠，最后找出了片头出现的「无名女尸案」和「唐坠楼案」。</p><p>从类型的角度的看，这是一部典型的「悬疑片」，故事情节一开始就设立了 导致唐奕杰坠楼案凶手的身份的「悬念」，叙事剪辑方式很多样，主要是过去（2006）之前，现在（2012）的不同时空间的碎片化的交错闪回，这样的好处是使整个影片的节奏非常快，能方便地铺悬疑点。叙事效率非常高，几乎没有多余的画面和情节。「过去」和「现在」两个时空去采取「时间-地点」的字幕信息去交代，这样使时故事的清晰度不高，对观众的要求也比较高。</p><h1 id="摄影和剪辑"><a href="#摄影和剪辑" class="headerlink" title="摄影和剪辑"></a>摄影和剪辑</h1><p>「风雨云」摄影和剪辑也让我很享受。娄烨导演一贯的手持摄影的方式，一方面在生理上让人感觉不舒服，另一方却大大增强的真实感。尤其是一开始的城关村的骚乱场面太精彩了，由一系列俯拍、跟随、交叉、穿越的镜头组成，这个看起来像是长镜头的拼切镜头带领我们去感觉广州城中村拆迁的环境现状，各处的残楼瓦砾，瓦砾上居民晾晒的衣服，骚乱中拥挤的人群，挖掘机推到墙壁和电线杆的轰隆声，给人一种强烈的压抑感，而这一种压抑感、压迫感和整个影片所要展现的基调是一致的。</p><p>让我印象非常深刻的还有几个场景，杨家栋在城中村被陷害杀人的逃跑镜头，这组镜头充分展现了城中村特有的潮湿、逼仄的环境，之前我也在广州城中村住过一段时间，这组镜头完全勾起了我在楼房与楼房之间行走那种压抑的感觉。另外两场车内争斗戏也非常出彩，就不再具体叙述了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>在「风雨云」中，娄烨试图将商业片和艺术片进行融合，从这点上说，他做的很不错。片中塑造的悬疑元素、出彩的动作设计能牢牢吸引观众。整个影片的布景、光影、声音的处理都体现出娄烨的专业性的艺术追求，电影外的事情无须多言。</p><blockquote><p>电影会帮我们记住，我们和我们的时代。</p></blockquote>]]></content>
    
    <summary type="html">
    
      「风中有朵雨做的云」影评
    
    </summary>
    
      <category term="Movie" scheme="http://lemmo.xyz/categories/Movie/"/>
    
    
      <category term="movie" scheme="http://lemmo.xyz/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>「如何聊电影」读书笔记</title>
    <link href="http://lemmo.xyz/post/How-to-watch-movies.html"/>
    <id>http://lemmo.xyz/post/How-to-watch-movies.html</id>
    <published>2019-03-31T08:04:50.000Z</published>
    <updated>2019-03-31T08:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">Title</td><td style="text-align:left">如何聊电影</td></tr><tr><td style="text-align:left">Author</td><td style="text-align:left">[美]安·霍纳迪</td></tr><tr><td style="text-align:left">Edition</td><td style="text-align:left">未读-艺术家</td></tr><tr><td style="text-align:left">Release Date</td><td style="text-align:left">2018-10</td></tr><tr><td style="text-align:left">ISBN</td><td style="text-align:left">9787559626295</td></tr></tbody></table><h1 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h1><ul><li>三幕式电影结构：<br>第一幕（铺垫）、第二幕（冲突）、第三幕（解决）</li><li>通常来说，一个好的剧本应该对环境和角色有精准细致的描绘。</li><li>剧本决定了我们在这两小时内进入的是一个怎样的世界，而编剧的水平和他的文字功底决定了这个世界是否真实、有活力，能否让我们迅速入戏。</li><li>剧情只是说事（机械复述），故事是在讲意（表达情感）。</li><li>这种给角色脸上贴金的做法有一个专门的术语叫“（加）风险”（stakes），也就是编剧将故事写得更紧张激烈，并通过赋予角色行为更戏剧化、更能获得观众同情的动机，让角色更具“共鸣感”。</li><li>可信度人类的缺点的存在或缺失瑕疵以及合反映出编剧理和不合理的人性的理解程行为的了解。</li></ul><h1 id="表演"><a href="#表演" class="headerlink" title="表演"></a>表演</h1><ul><li>表演还是取决于演员在塑造一个角色时所做的一系列决定—把握角色内在和外在的各种细节，打造出有深度、有真实感、有吸引力的角色。</li><li>最好的银幕表演应该能在“表现”与“克制”之间达到超常的平衡，也就是说，既要透明到能让观众瞬间了解角色，又要内敛到让观众好奇角色下一步会怎么做。</li><li>最忌讳被观众发现表演痕迹的类型片，可能是喜剧片。</li><li>伟大的演员能不断勾起我们的好奇心，让我们在对他们的一知半解中获得满足。</li><li>选角的艺术离不开经验、品味、直觉、风险、讨价还价，还有纯粹的运气。</li><li>相比选择家喻户晓的大明星，选用生面孔可以更有效地奠定一部影片的基调。</li><li>在电影诞生伊始，也就是在默片时代，夸张的戏剧动作不仅为观众所熟悉（当时的舞台剧和歌舞秀都是这种表演风格），更是在没有台词的情况下传达影片讯息的必要手段。进入三四十年代的“黄金时代”，即便有声电影已经普及，风格化、戏剧化的表演依然占主导地位，但浮夸、直白的动作正在逐渐消失。</li><li>衡量一个演员表演的好坏，应该看观众是否获得情感共鸣:演员的表演是帮助了我们进入银幕中的世界，还是让我们觉得出戏？</li><li>拿一部电影的原真性（perceived authenticity）作为卖点已经成了一种廉价的营销手段。</li><li>作为观众，我们不需要知道演员为了准备一个角色进行了怎样的自我思考、即兴创作，或者热身运动，我们也不需要知道演员为了在银幕上打造一个他栖身的世界做了多少研究，我们只需要跟随他们一起进入这个世界即可。</li><li>戏中演员最重要的就是把正确的外部表演和正确的内心表演结合。</li><li>在评价一个你不喜欢的演员的表演时，观众必须把这个演员可控的地方和不可控的地方区分开来。演员没法让自己的个子忽高忽矮，也不可能随意增重或减重，但他们可以据故事需要，让自己的角色形象或优雅尊贵，或粗野，或谦逊。</li></ul><h1 id="艺术设计"><a href="#艺术设计" class="headerlink" title="艺术设计"></a>艺术设计</h1><ul><li>在评价一部电影的艺术设计时，可信度、吸引力、细节度、原创性都应该列入考虑范围。</li><li>和剪辑一样丫奥斯卡最佳艺术指导奖通常都是颁给在艺术指导方面做得最张扬、最气派的电影）比如服装华丽的历史剧情片，或者在视觉上极富创新的电影。</li><li>最好的艺术设计是难以察觉、不着痕迹的。</li><li>最好的艺术设计是通过<strong>无形与有形、逼真和矫饰之间的内在张力实现的</strong>，优秀的艺术指导能为观众打造出愉悦的、富有质感的视觉体验，并提供细节丰富的布景，让表演者尽可能真实、自然地表演。</li><li>母题：指电影中有意义且重复出现的元素。母题可以是物品、颜色、地点、人物、声音等。</li><li>但电影的艺术设计一直在帮助我们感知和理解电影，并在视觉、精神乃至潜意识上影响我们。</li><li>艺术设计不仅能让观众了解角色，还能够传递主角不能传递的价值观、需求和欲望。</li><li>电影一定要尽量多给观众一点儿信息，用画面和信息淹没他们。如此一来，一部电影便可以重复欣赏，影迷每次重看都会有新的发现。</li></ul><h1 id="摄影"><a href="#摄影" class="headerlink" title="摄影"></a>摄影</h1><blockquote><p>德国表现主义（Expressionism）：用极简、强烈的光影对比。</p></blockquote><ul><li>摄影机是我们进入银幕世界的通道，问题是电影制作者究竟是在用摄影机把我们拉进去，或是让我们与之保持距离，还是将我们拒之门外。</li></ul><h1 id="剪辑"><a href="#剪辑" class="headerlink" title="剪辑"></a>剪辑</h1><ul><li>最好的剪辑并不会引起观众的注意，而是消失在电影中。成功的剪辑能让观众获得满意的观影体验，感觉整部电影浑然天成，从头至尾没有一点儿磕绊，没有别扭的转场，没有不合逻辑的剧情，也不会让人感到厌烦或者疑惑。</li><li>我们说一部电影太长，指的是它重复、无聊，或是纯粹为了堆砌银幕奇观而加入一场又一场爆炸戏和破坏戏。</li><li>一百多年来，电影的基本语法并没有太多改变。电影依然是由场景构成，而场景由镜头构成，镜头则是叙事的基本元素。</li></ul><h1 id="声音和音乐"><a href="#声音和音乐" class="headerlink" title="声音和音乐"></a>声音和音乐</h1><ul><li>好电影不只是精彩的故事、高超的表演、迷人的画面结合的产物，它还能提供富有深度的体验，将对话、音效、音乐融合在一起，打造一个音响环境，让观众听到的声音和看到的画面一样充满了层次感和细节度。</li><li>声音对我们在电影中能看到什么有强烈的影响，这种影响通常都是潜移默化的。</li><li><p>奥斯卡中共设了两个声音奖项：</p><blockquote><p><strong>最佳声音剪辑奖：</strong>声音剪辑师（sound editor）负责汇集、制作、整理观众在银幕上听到的一切声音，其中包括角色对白（包括拍摄现场录制的对白和后期配音）和音效；</p></blockquote><blockquote><p><strong>最佳混音奖：</strong>混音师（ sound mixer）负责决定这些声音如何相互共存，以及如何与配乐共存。混音师可以通过调整不同声音的比例，来增强真实感和情感冲击力，提升观众对影片故事的理解。</p></blockquote></li><li>声音在打造连贯性上的另一个作用，是让场景之间的转换更加自然流畅。在声音设计的帮助下，观众可以自行在脑中将看似没有关系或者衔接比较生硬的两个场景连到一起。</li><li>一部电影的声音有多写实，完全取决于这部电影想要讲述一个怎样的故事，以及导演是想将观众的注意力引到角色身上，还是引到他们抽象的情感体验上。</li><li>音乐不应该只是重复或强调已经通过视觉画面或者角色对白传达出来的故事元素和情感。它应该有所添加，不是模仿或者强调已经发生的动作，而是在不知不觉中，赋予它更多的意义，让故事更有深度。</li><li>从本质上讲给一部电影过度配乐其实是对观众的不信任，同时也反映了电影制作者自己的不自信一只会反复告诉观众如何去感受，而不是让故事和演员去完成情感传递的任务。这种配音被叫成「米老鼠配乐」（mickey-mousing)<h1 id="导演"><a href="#导演" class="headerlink" title="导演"></a>导演</h1></li></ul><p>导演需要从头到尾对整个作品内容进行负责，不管是影像风格、剪辑、音乐的选择、甚至是演员的表现上。</p><p>​                                                                                                                                          </p>]]></content>
    
    <summary type="html">
    
      「如何聊电影」读书笔记
    
    </summary>
    
      <category term="reading-list" scheme="http://lemmo.xyz/categories/reading-list/"/>
    
    
      <category term="movie" scheme="http://lemmo.xyz/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D音频管理器「生存之战」</title>
    <link href="http://lemmo.xyz/post/Unity3D-AudioManager.html"/>
    <id>http://lemmo.xyz/post/Unity3D-AudioManager.html</id>
    <published>2019-03-23T08:10:37.000Z</published>
    <updated>2019-03-23T08:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unity3D的音频系统介绍</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想象一下如果电影没有了声音，我们的观影体验会大打折扣，声音也对于游戏有非常重要。游戏中的声音主要是指游戏交互过程中的各种音效，如走路会产生脚步声，射击时会有枪声，这些音效就是为了产生更沉浸的世界（环境），游戏中另一个声音是背景音乐，起到烘托游戏气氛的作用。</p><h2 id="Unity3D中的声音"><a href="#Unity3D中的声音" class="headerlink" title="Unity3D中的声音"></a>Unity3D中的声音</h2><h2 id="音频管理器"><a href="#音频管理器" class="headerlink" title="音频管理器"></a>音频管理器</h2><blockquote><p><strong>Edit–&gt;ProjectSetting–&gt; Audio</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190323172804.png" alt=""></p><h2 id="AudioClip（音频文件）"><a href="#AudioClip（音频文件）" class="headerlink" title="AudioClip（音频文件）"></a>AudioClip（音频文件）</h2><p>Unity3D中支持各种格式的音频文件，可以导入的音频格式有<code>.wav</code> <code>.mp3</code> <code>.ogg</code>，可以直接将音频文件拖拽到Unity3D的「Assets」中里。在Unity3D里面，这些音频文件叫做<code>Audio Clip</code>。</p><h2 id="AudioListener-（音频监听器组件）"><a href="#AudioListener-（音频监听器组件）" class="headerlink" title="AudioListener （音频监听器组件）"></a>AudioListener （音频监听器组件）</h2><p>一个<code>Scence</code>中有一个<code>AudioListener</code>，它可以接受游戏中的所有音乐和音效，相当于人的“耳朵”，创建场景中它会自动挂载在<code>Main Camera</code>物体上。</p><h2 id="AudioSource（声音源组件）"><a href="#AudioSource（声音源组件）" class="headerlink" title="AudioSource（声音源组件）"></a>AudioSource（声音源组件）</h2><p>在Unity3D中是通过<code>Audio Source</code>这个声音组件来播放声音的，在任何一个物体（gameobject）上都可以直接挂在这个<code>Audio Source</code>组件。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190323165557.png" alt=""></p><ul><li>AudioClip：拖入音频AudioClip文件</li><li>Output：音频剪辑通过音频混合器输出;</li><li>Mute：是否静音；</li><li>Play On Awake：是否自动播放（<em>如果这个组件时通过代码添加上的，而不是一开始就有的，不会自动播放，需要使用<code>AudioSource.Play()</code>来播放</em>）</li><li>Loop：是否循环播放</li><li>Priority：当场景中有多个音频共存时，设定的优先级播放</li><li>Volume：音量大小</li></ul><h2 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h2><p>使用代码设置音频和对音频的控制需要先获取<code>AudioSource</code>组件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取AudioSouce组件</span></span><br><span class="line">AudioSource audioSource = transform.GetComponent&lt;AudioSource&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制音频</span></span><br><span class="line">audioSource.clip = clip;    <span class="comment">// 设置clip</span></span><br><span class="line">audioSource.volume = <span class="number">0.5f</span>;  <span class="comment">// 设置音量大小</span></span><br><span class="line">audioSource.loop = <span class="literal">true</span>;    <span class="comment">// 设置循环播放 </span></span><br><span class="line">audioSource.Play();         <span class="comment">// 开始播放</span></span><br><span class="line">audioSource.Stop();         <span class="comment">// 停止播放</span></span><br><span class="line">audioSource.Pause();        <span class="comment">// 暂停播放</span></span><br><span class="line">audioSource.UnPause();      <span class="comment">// 继续播放</span></span><br></pre></td></tr></table></figure><h1 id="独立的音频管理器（生存之战音频管理器为例）"><a href="#独立的音频管理器（生存之战音频管理器为例）" class="headerlink" title="独立的音频管理器（生存之战音频管理器为例）"></a>独立的音频管理器（生存之战音频管理器为例）</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需要控制的音频比较少时可以直接在物体自身的脚本中获取<code>AudioSource</code>组件进行控制，但如果需要控制的音频比较多时，或想后期修改音频逻辑时，需要重新打开对应的脚本比较复杂。将和音频控制相关的代码封装了独立的脚本会方便很多。需求点：</p><ul><li>管理器必须是单例模式，方便在项目中随处使用该类的功能；</li><li>直接持有和管理几十个甚至几百个音频资源；</li><li>可以实现传递音频资源名，然后在某个位置播放音频；</li><li>可以实现动态的给某个游戏物体添加音频组件，配置音频组件相关属性；</li><li>还要提高音频管理器的“易用性”，规范音频资源命名，方便快速找到需要的资源。</li></ul><h2 id="导入音频"><a href="#导入音频" class="headerlink" title="导入音频"></a>导入音频</h2><p>将所有音频资源导入「Resources」文件夹中</p><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><h3 id="创建音频资源枚举"><a href="#创建音频资源枚举" class="headerlink" title="创建音频资源枚举"></a>创建音频资源枚举</h3><p>使用资源名称枚举可以方便我们使用对应的音频时快速找到需要的音频资源，枚举值和音频资源名要一一对应</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ClipName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 野猪攻击音效.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    BoarAttack,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 野猪死亡音效.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    BoarDeath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建AudiosManager-cs，加载音频资源"><a href="#创建AudiosManager-cs，加载音频资源" class="headerlink" title="创建AudiosManager.cs，加载音频资源"></a>创建<code>AudiosManager.cs</code>，加载音频资源</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AudiosManager Instance;<span class="comment">// 单例</span></span><br><span class="line"><span class="keyword">private</span> AudioClip[] audioClip;</span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="keyword">string</span>, AudioClip&gt; audioClipDic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Instance = <span class="keyword">this</span>;</span><br><span class="line">    audioClipDic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, AudioClip&gt;();</span><br><span class="line">    audioClip = Resources.LoadAll&lt;AudioClip&gt;(<span class="string">"Audios/All/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把所有音频添加到字典中去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; audioClip.Length; i++)&#123;</span><br><span class="line">        audioClipDic.Add(audioClip[i].name, audioClip[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将该类定义为单例模式</li><li>使用<code>Resources.LoadAll&lt;&gt;()</code>加载所有AudioClip，得到一个AudioClip数组</li><li>将资源数组遍历存储到一个字典结构中</li></ul><h3 id="音频播放方法"><a href="#音频播放方法" class="headerlink" title="音频播放方法"></a>音频播放方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过名字获取音频资源</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AudioClip <span class="title">GetAudioClipByName</span>(<span class="params">ClipName clipName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AudioClip tempClip;</span><br><span class="line">    audioClipDic.TryGetValue(clipName.ToString(), <span class="keyword">out</span> tempClip);</span><br><span class="line">    <span class="keyword">return</span> tempClip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 在指定位置播放音频</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayAudioClipByName</span>(<span class="params">ClipName clipName, Vector3 pos</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AudioSource.PlayClipAtPoint(GetAudioClipByName(clipName), pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 给游戏物体添加音频组件来播放音频</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AudioSource <span class="title">AddAudioSourceComponent</span>(<span class="params">ClipName clipName, GameObject go, <span class="keyword">bool</span> playOnAwake = <span class="literal">true</span>, <span class="keyword">bool</span> loop = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AudioSource audioSource = go.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">    audioSource.clip = GetAudioClipByName(clipName);</span><br><span class="line">    <span class="keyword">if</span> (playOnAwake)    audioSource.Play();</span><br><span class="line">    audioSource.loop = loop;</span><br><span class="line">    <span class="keyword">return</span> audioSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在其他脚本中使用AudioManger-cs"><a href="#在其他脚本中使用AudioManger-cs" class="headerlink" title="在其他脚本中使用AudioManger.cs"></a>在其他脚本中使用<code>AudioManger.cs</code></h3><p>需要先查找持有这个脚本的引用，调用该管理器内的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AudiosManager.Instance.</span><br><span class="line">    PlayAudioClipByName(ClipName.BoarInjured, transform.position);</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ul><li><a href="http://gad.qq.com/article/detail/288828" target="_blank" rel="noopener">关于Unity中3D声音的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unity3D的音频系统介绍&lt;/p&gt;
    
    </summary>
    
      <category term="Unity3D" scheme="http://lemmo.xyz/categories/Unity3D/"/>
    
    
      <category term="Unity3D" scheme="http://lemmo.xyz/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>降噪耳机Bose-QC-30使用体验</title>
    <link href="http://lemmo.xyz/post/Bose-QC-30.html"/>
    <id>http://lemmo.xyz/post/Bose-QC-30.html</id>
    <published>2019-03-14T22:53:46.000Z</published>
    <updated>2019-03-18T10:49:12.625Z</updated>
    
    <content type="html"><![CDATA[<p>这是我买的第一款“主动降噪”耳机，本文谈谈对 QC-30 这款产品的使用体验。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在买一款耳机之前，买过至少10条以上还不错的耳机。目前还在使用的有，1条小米平头耳机、2条“入耳式耳机”（分别是AKG和小米活塞耳机）、一个不知名的运动耳机、一个头戴式耳机（Sony 1AbT）。我并不是一个耳机发烧友，有HIFI音质没有很大的追求，但喜欢在不同的使用场景下使用合适的耳机。</p><p>18年底到19年初这段期间听了比较多的播客，就一直想买一款「分体式耳机」，也就是商家标称的「真·无线耳机」，以AirPorts为参考，考虑过<a href="http://item.mi.com/product/9016.html" target="_blank" rel="noopener">小米AirDots</a>、<a href="http://item.mi.com/product/9209.html" target="_blank" rel="noopener">小米蓝牙耳机Air</a>，另外还有 QCY T1，漫步者 W2等小众品牌，但考虑到颜值问题，还是优先考虑小米的两款。（值得一提的时候，小米AirDots就是Qcy T1的贴牌产品，只是换了外观设计）。但小米的这两款蓝牙耳机一直买不到，无论是线上还是在小米之家，后来想着就入手一款降噪耳机。</p><p>目前，主流的降噪耳机分3种，一种是「分体式耳机」，一种是「项圈式耳机」，一种是头戴式耳机（Sony WH-1000XM3、Bose Qc35）。考虑到自己已经有一款头戴式耳机，就只有「项圈式降噪耳机」了，千元以后的有「Sony Wi-1000x」、「Bose QC-30」，百元以内的有「DyPlay ANC30（￥279）」。前几天的晚上，逛闲鱼的时候发现有人在卖全新未拆封的 QC-30 ，直接砍了50元后，以1200元的价格买了。</p><h1 id="外观与佩戴"><a href="#外观与佩戴" class="headerlink" title="外观与佩戴"></a>外观与佩戴</h1><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190315074148.png" alt=""></p><p>Bose QC-30 的简单一点描述就是一个「项圈」，采用半圈形的结构，让耳机直接挂在脖子上，能在一定程度上提升耳机的佩戴舒适度。项圈部分采用”类肤质“的材料、耳塞外部是金属材料、按键控制是硬塑料，鲨鱼鳍耳塞是软硅胶材质的。整体来看，产品在设计风格、材料选择方面都比较协调，统一。再说一说细节部分，仔细看耳机，我都不敢相信这做工是2000价位的耳机，与Sony的做工（细节把控）有点差距，如项圈有些部分的胶并没有粘好，使用一段时间或出汗可能会导致脱胶、鼓包等问题。</p><p>因为耳式项圈部分采用了类肤质的材料，所以直接把耳机与皮肤接触并没有什么不适，长时间佩戴甚至会忽视它的存在。当穿上有领的衣服时，项圈还可以直接放在领子的外面。佩戴上另一个非常难受的问题，项圈戴久之后，项圈的位置会变歪，对强迫症来说非常难受呀！不得不过几十分钟就要把它手动放正。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/photo_2019-03-15_08-00-40.jpg" alt=""></p><p>另外一个关键的问题时耳塞的的舒适度。得益于Bose 独家的<code>鲨鱼鳍耳塞</code>，半入耳式的设计能让做到长时间佩戴都很舒适，而且怎么甩耳机都不会从耳朵里溜出来。解决了平头耳机容易掉，耳塞式耳机的堵耳，头戴式耳机夹眼镜夹耳等问题。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190315080958.png" alt=""></p><h1 id="连接耳机"><a href="#连接耳机" class="headerlink" title="连接耳机"></a>连接耳机</h1><p>QC-30支持蓝牙4.2连接，不支持LDAC以及aptX。蓝牙连接设备没什么好说的，QC-30还支持NFC连接的，但经过我多次测验，无论是通过手机NFC还是 Sony-A30 的 NFC 都无法正常连接，只能通过手动点击蓝牙连接。当然，耳机开机时如果手机的蓝牙时打开的，耳机会自动连接手机，连接的速度还是挺快的。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190315093655.png" alt=""></p><p>连接好APP后，可以拖动中间的滑动条调节降噪的等级，支持11级调节。左下角的连接蓝牙标志可以进行蓝牙连接，往右边的是Bose 音乐分享功能，介绍说时能在两台Bose设备之间无线传输音频，可惜我只有一台 Bose设备，最右边的时蓝牙当前的剩余电量。最下面的播放播放控制，这个控制可以接管连接上设备的音频控制权。比如 网易云音乐 或是 Spotify 播放音乐，或是连接上的其他播放器（Sony-A30）也可以控制。</p><p>Bose-QC-30 可以同时连接两台设备，但是使用体验并不是很好。</p><ul><li>同时连接 Sony-A30 和手机，并使用 Sony-A30 播放音乐时，如果手机上要播放音频，需要先暂停 Sony-A30上的播放，否则手机播放没有声音。</li><li><del>同时连接 PC 和手机，使用 PC 播放音乐，如果手机接到任何通知或要播放声音，会中断当前音乐的播放，过一会又继续播放。</del></li></ul><p>注意：在使用 Win10 连接耳机时，需要先连接手机，打开 Bose Connect ，点击蓝牙-连接新设备，再使用 Win10 搜索蓝牙设备连接 Bose QuietControl 30。</p><h1 id="降噪表现"><a href="#降噪表现" class="headerlink" title="降噪表现"></a>降噪表现</h1><p>降噪是这款耳机最主要的功能，降噪分为两种。一种是被动降噪，一种是主动降噪。对于第一种，更恰当地说是隔音，戴海绵耳塞、头戴耳机式。</p><blockquote><p>被动式降噪耳机利用物理特性将外部噪声与耳朵隔绝开，主要通过隔声材料阻挡噪声，对高频率声音非常有效，一般可使噪声降低大约为15-20dB。</p></blockquote><p>而主动降噪不只是简单地物理材料隔音</p><blockquote><p> 主动降噪的原理在于首先要收集噪音的波型特点，然后<strong>通过内置的处理芯片运算出反相的波，再通过高还原度扬声器相抵消。</strong>所以主动降噪系统必备的设备有拾音器、处理芯片、扬声器，每一个部分都要保证高质量才能达到最终的效果，故成本上就要比传统非降噪设备高。</p></blockquote><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/ce0BPVeFZzz5g.jpg" alt=""></p><p>Bose QC-30 一个特色式支持11档地「可控降噪」，可以满足在不同场景地使用需求。在嘈杂的食堂、公交、地铁上可以将降噪全开。而在需要与人交谈的时候，可以把通过线控的方式将降噪级别降低，当前我还是建议把耳机取下来再与人交谈，一是方便，二是对别人的尊重。</p><p>将降噪开到最高时，即使播放音乐，也会感觉少了很多嘈杂的声音，这些声音在没有戴降噪耳机之前不会有明显的感觉，当我把降噪耳机取下来之后，各种中频、低频的噪音「扑耳而来」，用了降噪耳机之后怕是再也回不去不用降噪耳机的时候了。</p><p>对人声的降噪情况，如果有人在你身边讲话时，还是可以清楚听清说话的声音，但是人声会有明显的变化。</p><p>Bose QC 30 并没有明显的底噪（电流声），如果旁边有手机或其他设备在充电可以听到明显的电流声。如果衣服摩擦耳机的线，会有一点点的听诊器效应。</p><p>如果使用场景有风，QC-30会有很大的风噪音，可能是拾音器又加大风声。</p><p>总的来说，QC30的降噪表现还是延续了Bose家族一如既往的高水准，比市面上很多同类型的降噪耳机效果要更优秀一些。对近距离的高频噪音和人声不能屏蔽掉，但开启降噪再用小音量放一些音乐就可以做好普通耳机需要很大音量才能隔绝噪音的效果。</p><h1 id="音乐表现"><a href="#音乐表现" class="headerlink" title="音乐表现"></a>音乐表现</h1><p>到了玄学的音效的环境，对于音质不是特别敏感的耳朵来说，Bose QC30 的音效还是能过的去的。网上的评测大都说不如 Sony WI-1000x 听感好，我没有自己听过 Sony Wi-1000x ，所以不好下判断。更何况音质这东西见仁见智，耳朵适应一段时间一般都会适应。</p><p>（各频段音乐表现待一段时间的使用之后再补充）</p><h1 id="续航"><a href="#续航" class="headerlink" title="续航"></a>续航</h1><p>官方参数：充满电可以使用10个小时，充满电需要2个小时（实际体验2h20min）</p><hr><p>参考：</p><ul><li><a href="https://www.bose.cn/zh_cn/products/headphones/earphones/quietcontrol-30.html#v=qc30_black" target="_blank" rel="noopener">Bose-QC-30_官方介绍</a></li><li><a href="https://www.bilibili.com/video/av41982410?from=search&amp;seid=13107583089083392405" target="_blank" rel="noopener">平价真无线耳机们到底好用不好用【值不值得买第307期】</a></li><li><a href="http://sound.zol.com.cn/439/4392078.html" target="_blank" rel="noopener">破解”听不见”的秘密 降噪耳机技术浅谈</a></li><li><a href="http://www.52audio.com/archives/14885.html" target="_blank" rel="noopener">BOSE QC30无线消噪耳机体验</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我买的第一款“主动降噪”耳机，本文谈谈对 QC-30 这款产品的使用体验。&lt;/p&gt;
    
    </summary>
    
      <category term="新玩具" scheme="http://lemmo.xyz/categories/%E6%96%B0%E7%8E%A9%E5%85%B7/"/>
    
    
      <category term="耳机" scheme="http://lemmo.xyz/tags/%E8%80%B3%E6%9C%BA/"/>
    
      <category term="体验" scheme="http://lemmo.xyz/tags/%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>「故事」读书笔记</title>
    <link href="http://lemmo.xyz/post/Story-Notes.html"/>
    <id>http://lemmo.xyz/post/Story-Notes.html</id>
    <published>2019-02-19T10:24:11.000Z</published>
    <updated>2019-03-18T10:49:03.919Z</updated>
    
    <content type="html"><![CDATA[<p>罗伯特·麦基的《故事》中摘录的笔记</p><a id="more"></a><h1 id="Part-1-故事"><a href="#Part-1-故事" class="headerlink" title="Part 1 故事"></a>Part 1 故事</h1><ul><li>故事是人生必需的设备。</li><li>娱乐即使沉浸于故事的仪式之中，达到一种知识上和情感上令人满足的目的。</li><li>凡是优秀的电影、小说、戏剧，都能通过其各不相同的喜剧和悲剧色彩来达到娱乐的目的，给观众一种具有感染力的生活模式。（电子游戏亦是如此）</li><li>故事并不是对现实的逃避，而是一种载体，承载着我们去追寻显示、尽最大的努力挖掘出混乱人生的真谛。</li><li>故事艺术是世界上主导的文化力量，而电影艺术则是这一辉煌事业的主导媒体。</li><li>创作者的技巧并不是什么手艺的东西，只不过是他对所遇到的每一部小说、电影或戏剧中故事要素的无意识吸收。</li><li>创造故事必须深入地挖掘生活，找到新地见解、新版本的价值和意义，然后创造出一个故事载体。</li><li>一个好故事使一部好影片成为可能，如果故事不能成立，那么影片必将成为灾难。</li><li>所有的故事，无论真诚还是虚假，明智还是愚蠢，都会忠实地映现出作者本人，暴露出其人性…..或人性地缺乏。</li><li>每一门艺术都是由其根本形式决定地。故事地普遍形式使其作品成为一个故事，而不是肖像画或艺术拼贴。</li><li>一个作家必须掌握故事形式，但形式并不是“公式”，故事是丰富多彩、纷繁复杂、神妙莫测的。</li></ul><h2 id="故事是生活的比喻"><a href="#故事是生活的比喻" class="headerlink" title="故事是生活的比喻"></a>故事是生活的比喻</h2><ul><li><p>一个讲故事的人即是一个生活诗人，一个艺术家，将日常生活事件、内在生活和外在生活、梦想和现实转化为一首诗，一首以事件而不是以语言作为韵律的诗<br>一个长达两小时的比喻，告诉观众:生活就像是这样！因此，<strong>故事必须抽象于生活，提取其精华，但又不能成为生活的抽象化，以致失却实际生活的原味。故事必须像生活，但又不能一成不变地照搬生活，以致除了市井乡民都能一目了然的生活之外便别无深度和意味。</strong></p></li><li><p>电影美学是表达故事生动内容的手段，其本身绝不能成为目的。</p></li></ul><h1 id="Part-2-：故事的要素"><a href="#Part-2-：故事的要素" class="headerlink" title="Part 2 ：故事的要素"></a>Part 2 ：故事的要素</h1><blockquote><p>​    <strong>节拍</strong>构成场景，<strong>场景</strong>构成序列，<strong>序列</strong>构成幕，<strong>幕</strong>构建成故事，最后达到<strong>高潮</strong>。</p></blockquote><p><code>节拍</code>是场景里面最小的结构成分。</p><p><code>场景</code>是再某一相对连续的时空中，通过冲突表现出来的一段动作，这个动作至少是让人生的生活负荷发生转折。<strong>理想的场景是一个故事事件。</strong></p><p><code>序列</code>是一系列场景——一般是两到五个，每一个场景的冲击力呈递增趋于，直到最后到达顶峰。</p><p><code>幕</code>是一系列序列的组合，以一个高潮场景为顶点，导致价值的重大转折。</p><p><code>高潮</code>：故事是一系列幕的组合，渐次构成一个最后的幕高潮。引发出<strong>绝对不可逆转的变化。</strong></p><p>总结：场景导致较小而有意义的变化，序列中的终结场景的变化更强劲、具有决定性的变化，而幕导致的价值转折比场景和序列中的冲击力更强。场景、序列、幕中的变化都是可以逆转的，但是最后一幕的高潮是不可逆转的。</p><h2 id="故事三角"><a href="#故事三角" class="headerlink" title="故事三角"></a>故事三角</h2><p>故事经典设计：</p><blockquote><p>经典设计是指围绕一个主动主人公构建的故事，主人公为了追求自己的欲望，与主要来自外界的对抗力量进行抗争，通过连续的时间、在一个连贯而具有因果关联的虚构现实里，到达一个表现绝对、而变化不可逆转的闭合式结局。</p></blockquote><p>我们的故事大部分都是这样的经典设计的。被麦基成为<code>大情节</code>故事，但是这种形式并不是故事讲述形态的极限。与之不同的，有<code>小情节</code>和<code>反情节</code>，如图：</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190219205455.png" alt=""></p><p><strong>最小主义</strong>是指作者从经典设计的成分开始，对它们进行削减—对大情节的突出特性进行精炼、浓缩、删节或修剪。<strong>小情节并不意味着无情节</strong>，其故事必须像大情节一样给予精美的处理。确切地说，最小主义的情节处理是要在简约、精炼的前提下保持经典的精华，使影片仍然能够满足观众。</p><p><strong>反情节</strong>是反小说（新小说）和荒诞派戏剧的电影翻版。反结构变体并没有削减经典，而是反其道而行，否认传统形式，以利用甚至嘲弄形式原理的要义。反情节的制造者对欲语还休的描写方法或暗度陈仓式的收敛几乎没有兴趣；相反，为了昭示他的“革命”雄心，他的影片倾向于过度铺陈和自我意识的大肆渲染。</p><h3 id="闭合式结局-VS-开放式结局"><a href="#闭合式结局-VS-开放式结局" class="headerlink" title="闭合式结局 VS 开放式结局"></a>闭合式结局 VS 开放式结局</h3><blockquote><p>如果一个表达绝对而不可逆转变化的故事高潮，回答了故事讲述过程中所提出的所有问题并满足了所有观众情感，则被称为<strong>闭合式结局。</strong></p></blockquote><blockquote><p>一个故事高潮如果留下一两个未解答的问题和一些没被满足的情感，则被称为<strong>开放式结局。</strong></p></blockquote><h3 id="外在冲突-VS-内在冲突"><a href="#外在冲突-VS-内在冲突" class="headerlink" title="外在冲突 VS 内在冲突"></a>外在冲突 VS 内在冲突</h3><blockquote><p>大情节强调<strong>外在冲突</strong>。尽管人物常常具有强烈的内心冲突，但重点却落在他们与人际关系、社会机构或自然界力量的斗争上。</p></blockquote><blockquote><p>在小情节中，主人公也许与家庭、社会和环境具有强烈的外在冲突，但其重点却集结在他与自己思想情感有意或无意的角斗里。(<strong>内在冲突</strong>即内心冲突)</p></blockquote><h3 id="单一主人公-VS-多重主人公"><a href="#单一主人公-VS-多重主人公" class="headerlink" title="单一主人公 VS 多重主人公"></a>单一主人公 VS 多重主人公</h3><blockquote><p>如果是单一主人公，则影片中所有的事件变化都围绕主角。</p></blockquote><blockquote><p>如果作者将影片分解成若干较小的次情节，每一个次情节都有一个单一主人公。</p></blockquote><h3 id="主动主人公-VS-被动主人公"><a href="#主动主人公-VS-被动主人公" class="headerlink" title="主动主人公 VS 被动主人公"></a>主动主人公 VS 被动主人公</h3><blockquote><p><strong>主动主人公</strong>在欲望追求中采取行动时，与他周围的人和世界发生直接冲突。</p></blockquote><blockquote><p><strong>被动主人公</strong>表面消极被动，而在内心追求欲望时，与其自身性格的方方面面发生冲突。</p></blockquote><h3 id="线性时间-VS-非线性时间"><a href="#线性时间-VS-非线性时间" class="headerlink" title="线性时间 VS 非线性时间"></a>线性时间 VS 非线性时间</h3><blockquote><p>无论有无闪回，一个故事的事件如果被安排成一个观众能够跟踪的时间顺序，那么这个故事便是按照线性时间来讲述的。</p></blockquote><blockquote><p>如果一个故事在时间中随意跳跃，从而模糊了时间的连续性，以致观众无从判断什么发生在前什么发生在后，那么这个故事便是按照非线性时间来讲述的。</p></blockquote><h3 id="因果-VS-巧合"><a href="#因果-VS-巧合" class="headerlink" title="因果 VS 巧合"></a>因果 VS 巧合</h3><p>大情节因果性强，反情节常常以巧合代替因果，强调宇宙万物的随意碰撞。</p><h3 id="连贯现实-VS-非连管现实"><a href="#连贯现实-VS-非连管现实" class="headerlink" title="连贯现实 VS 非连管现实"></a>连贯现实 VS 非连管现实</h3><blockquote><p>连贯现实是确立人物及其世界之间互动模式的虚拟背景，在整个讲述过程中，这些互动模式一直保持着连贯性，从而创造出意义。</p></blockquote><blockquote><p>非连贯现实是混合了多种互动模式的背景，其中故事章节不连贯地从一个“现实”跳向另一个“现实”，以营造出一种荒诞感。</p></blockquote><hr><p>未完….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;罗伯特·麦基的《故事》中摘录的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="reading-list" scheme="http://lemmo.xyz/categories/reading-list/"/>
    
    
      <category term="movie" scheme="http://lemmo.xyz/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>使用Scrapy爬虫抓取并下载豆瓣图片</title>
    <link href="http://lemmo.xyz/post/crawl-douban-image-by-scrapy.html"/>
    <id>http://lemmo.xyz/post/crawl-douban-image-by-scrapy.html</id>
    <published>2019-02-11T11:16:24.000Z</published>
    <updated>2019-03-18T10:49:03.928Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇笔记我直接自己写了一个Python来抓取豆瓣图片，为了让我更加熟悉<code>Scrapy</code>，我又用Scrapy做了一遍。</p><a id="more"></a><h1 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h1><p>直接参考上一篇的目标和网站分析。</p><h1 id="工具分析"><a href="#工具分析" class="headerlink" title="工具分析"></a>工具分析</h1><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211194221.png" alt=""></p><p>需要添加一个自己的下载图片的<code>Item Pipeline</code>。</p><h1 id="爬虫程序"><a href="#爬虫程序" class="headerlink" title="爬虫程序"></a>爬虫程序</h1><h2 id="创建一个新的Scrapy项目"><a href="#创建一个新的Scrapy项目" class="headerlink" title="创建一个新的Scrapy项目"></a>创建一个新的Scrapy项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject db_img_crawler</span><br><span class="line">scrapy genspider dbimg htpp://douban.com</span><br></pre></td></tr></table></figure><h2 id="编写items-py"><a href="#编写items-py" class="headerlink" title="编写items.py"></a>编写items.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImagesItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    image_title = scrapy.Field()  <span class="comment"># 图片的标题</span></span><br><span class="line">    image_url = scrapy.Field()  <span class="comment"># 图片的地址</span></span><br></pre></td></tr></table></figure><h2 id="编写主Spider文件，dbimg-crawler-py"><a href="#编写主Spider文件，dbimg-crawler-py" class="headerlink" title="编写主Spider文件，dbimg_crawler.py"></a>编写主Spider文件，<code>dbimg_crawler.py</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> doubanimg.items <span class="keyword">import</span> ImagesItem</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbimgSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'dbimg'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36'</span>,&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">300</span>,<span class="number">20</span>):</span><br><span class="line">            url = <span class="string">'https://www.douban.com/j/search_photo?q=%E7%8E%8B%E7%A5%96%E8%B4%A4&amp;limit=20&amp;start='</span> + str(i)</span><br><span class="line">            <span class="keyword">yield</span> Request(url,callback=self.parse_one)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_one</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = ImagesItem()</span><br><span class="line">        images = json.loads(response.body.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">        images = images[<span class="string">'images'</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(images)):</span><br><span class="line">            item[<span class="string">'image_title'</span>] = images[i][<span class="string">'title'</span>]</span><br><span class="line">            image_id = images[i][<span class="string">'id'</span>]</span><br><span class="line">            item[<span class="string">'image_url'</span>] = <span class="string">'https://img3.doubanio.com/view/photo/l/public/p'</span>+str(image_id)+<span class="string">'.webp'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(item)</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><ul><li>直接在<code>start_requeset()</code>中开启循环抓取，方法<code>yield Request</code>，回调给<code>parse_one()</code>抓取每一次的20条数据。</li><li>图片的地址同时是由获取到的id值来组拼成的。</li></ul><h2 id="编辑piepelines-py"><a href="#编辑piepelines-py" class="headerlink" title="编辑piepelines.py"></a>编辑<code>piepelines.py</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImagePipeline</span><span class="params">(ImagesPipeline)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span><span class="params">(self, item, info)</span>:</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(item[<span class="string">'image_url'</span>], meta=&#123;<span class="string">'item'</span>:item&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span><span class="params">(self, request, response=None, info=None)</span>:</span></span><br><span class="line">        <span class="comment"># item = response.meta['item']</span></span><br><span class="line">        name = <span class="string">'full/%s'</span> % ((request.url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]).split(<span class="string">'.'</span>,<span class="number">1</span>)[<span class="number">0</span>]) + <span class="string">'.jpg'</span></span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">item_completed</span><span class="params">(self, results, item, info)</span>:</span></span><br><span class="line">        path = [x[<span class="string">'path'</span>] <span class="keyword">for</span> ok,x <span class="keyword">in</span> results <span class="keyword">if</span> ok]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Item contains no images'</span>)</span><br><span class="line">        print(<span class="string">'Saving img...'</span>,item[<span class="string">'image_url'</span>])</span><br><span class="line">        print(<span class="string">'title'</span>,item[<span class="string">'image_title'</span>])</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>创建自己的Item Pipeline，继承<code>ImagesPipeline</code>(图片管道)，这个管道的特性有：</p><blockquote><ul><li>将所有下载的图片转换成通用的格式（JPG）和模式（RGB）</li><li>避免重新下载最近已经下载过的图片</li><li>缩略图生成</li><li>检测图像的宽/高，确保它们满足最小限制</li></ul></blockquote><p>要下载图片，需要重写<code>get_media_requests()</code>方法，方法内对图片URL返回一个Request。（<em>默认返回None，表示没有图可下载</em>）要想传递item对象可以把它写在request的<code>meta</code>里面。当下载完成之后，由管道接起，传递到<code>item_completed()</code>方法内。</p><p>如果想设置文件的名字，可以重写<code>file_path()</code>，可以通过<code>item = response.meta[&#39;item&#39;]</code>来接受item对象。</p><h2 id="编辑Setting-py"><a href="#编辑Setting-py" class="headerlink" title="编辑Setting.py"></a>编辑Setting.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">设置Header</span><br><span class="line"></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>:<span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>:<span class="string">'gzip, deflate, sdch'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>:<span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Cache-Control'</span>:<span class="string">'max-age=0'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>:<span class="string">'keep-alive'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片存储路径</span></span><br><span class="line">IMAGES_STORE = <span class="string">'D:\\img'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬虫协议</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大Requests数</span></span><br><span class="line">CONCURRENT_REQUESTS = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载延时</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Cookies</span></span><br><span class="line">COOKIES_ENABLED = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始MyImagePipeline</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'doubanimg.pipelines.MyImagePipeline'</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="启动爬虫程序"><a href="#启动爬虫程序" class="headerlink" title="启动爬虫程序"></a>启动爬虫程序</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl dbimg</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><ul><li><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/images.html" target="_blank" rel="noopener">下载项目图片-scrapy中文文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇笔记我直接自己写了一个Python来抓取豆瓣图片，为了让我更加熟悉&lt;code&gt;Scrapy&lt;/code&gt;，我又用Scrapy做了一遍。&lt;/p&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://lemmo.xyz/categories/Scrapy/"/>
    
    
      <category term="Python" scheme="http://lemmo.xyz/tags/Python/"/>
    
      <category term="Scrapy" scheme="http://lemmo.xyz/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>抓取豆瓣搜索到的图片</title>
    <link href="http://lemmo.xyz/post/crawl-douban-image-and-download.html"/>
    <id>http://lemmo.xyz/post/crawl-douban-image-and-download.html</id>
    <published>2019-02-11T04:01:02.000Z</published>
    <updated>2019-03-18T10:49:03.928Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python抓取和周迅有关的图片并下载到本地。<br><a id="more"></a></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>豆瓣搜索“周迅”的相关图片，并且下载到本地</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211120554.png" alt=""></p><h1 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h1><p>豆瓣图片是通过<code>Ajax</code>动态加载的，按F12打开Chrome浏览器的开发者工具，图片是通过GET来请求的，请求地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;<span class="built_in">limit</span>=20&amp;start=0</span><br></pre></td></tr></table></figure><p>其中：【q=：关键字| limit=：一次请求的数量（修改了也没用） | start=：请求的开始位置（偏移量）】。<br>点开Preview，看到网站给我们发送了一个20个长度的<code>json数据包</code></p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211121129.png" alt=""></p><p>点开第一个，这里面有几个key，我们需要的是图片的<code>url</code>，另外还可以存储图片的<code>title</code>。这里面可以看到有两个url，分别是<code>scr</code>和<code>url</code>。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211122017.png" alt=""></p><p>把它们全部在地址栏打开，发现这个<code>scr</code>链接是图片的缩略图地址，这个<code>url</code>链接是图片post的主页地址。这两个都不是我们想要的，但是可以右键看一下图片的真实地址</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211122906.png" alt=""></p><p>复制出来图片的地址，观察到图片的命名就是上面接受的<code>id值</code>，这样我们就可以通过获取每张图片的id值来组拼出图片的下载地址了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://img3.doubanio.com/view/photo/l/public/p637462204.webp</span><br></pre></td></tr></table></figure><h1 id="完整的爬取"><a href="#完整的爬取" class="headerlink" title="完整的爬取"></a>完整的爬取</h1><p>定义Header，图片的存储地址，保存抓取到的图片item</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="string">'./image'</span>         <span class="comment"># 图片地址</span></span><br><span class="line">imageItemList = []      <span class="comment"># 用列表存储所有的图片item（字典）</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>:<span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>:<span class="string">'gzip, deflate, sdch'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>:<span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Cache-Control'</span>:<span class="string">'max-age=0'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>:<span class="string">'keep-alive'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中"><a href="#获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中" class="headerlink" title="获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中"></a>获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_url</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取图片的url下载地址</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">300</span>,<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">'https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;limit=20&amp;start=0'</span></span><br><span class="line">        response = requests.request(<span class="string">'Get'</span>, url,headers=headers)</span><br><span class="line">        images = json.loads(response.content.decode(<span class="string">'utf-8'</span>))[<span class="string">'images'</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(images)):</span><br><span class="line">            imageItem = &#123;&#125;</span><br><span class="line">            imageItem[<span class="string">'title'</span>] = images[j][<span class="string">'title'</span>]</span><br><span class="line">            id = images[j][<span class="string">'id'</span>]</span><br><span class="line">            imageItem[<span class="string">'url'</span>] = <span class="string">'https://img3.doubanio.com/view/photo/l/public/p'</span>+str(id)+<span class="string">'.webp'</span></span><br><span class="line">            imageItemList.append(imageItem)</span><br></pre></td></tr></table></figure><ul><li>通过For循环获取，<code>range(0,300,20)</code>，表示要获取的图片数量为300张，Sep（步长）为20，因为每次获取的是20条数据。</li><li>通过<code>response.content</code>，获取<code>response</code>返回的内容，之前用<code>response.body</code>提示错误。这个应该是scrapy自己封装的属性。</li><li>通过<code>json.loads()</code>把<code>json对象</code>转换成<code>Python对象</code>，这样方便Python去解析。</li><li>图片的<code>url</code>是通过id值来组拼的。</li></ul><p>从列表获取图片链接并下载图片，然后使用<code>dwebp</code>工具转换图片格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_download</span><span class="params">(url, path)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    下载文件的方法</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_img_from</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    从数组中取出所有图片链接并下载，下载后使用dwebp转换图片格式为png，并删除dwebp源图片</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 判断是否电脑中是否有此目录，如果没有则创建一个空目录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir):</span><br><span class="line">        os.mkdir(dir)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> imageItemList:</span><br><span class="line">        url = item[<span class="string">'url'</span>]</span><br><span class="line">        fullpath = dir +<span class="string">'/'</span>+ str(index) + <span class="string">'.webp'</span></span><br><span class="line">        <span class="comment"># 调用下载方法</span></span><br><span class="line">        request_download(url, fullpath)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">'开始转换第'</span>+str(index)+<span class="string">'张图片：'</span>)</span><br><span class="line">            os.system(<span class="string">'dwebp ./image/%d.webp -o ./image/%d.png'</span> %(index,index))</span><br><span class="line">            print(<span class="string">'转换第'</span>+str(index)+<span class="string">'张图片完成.'</span>)</span><br><span class="line">            os.remove(<span class="string">'./image/'</span>+str(index)+<span class="string">'.webp'</span>) <span class="comment">#删除webp格式的图片</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            print(err)</span><br><span class="line">        index += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>从上面的图片item中获取每张图片的<code>url</code>，调用下载方法。</li><li>注意：这里获取下载的图片是<code>webp</code>编码的，需要使用<code>dwebp</code>工具进行转换。</li></ul><blockquote><p>WebP（Google开发），是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，派生自影像编码格式VP8。在同样大小的图片文件中，能比其他格式更加清晰，能提高网页加载速度，减少网络存储。</p></blockquote><h3 id="安装webp工具"><a href="#安装webp工具" class="headerlink" title="安装webp工具"></a>安装webp工具</h3><p>直接在<code>scoop</code>中搜索安装（libwqbp）即可，还可以直接去google的<a href="https://developers.google.com/speed/webp/docs/precompiled" target="_blank" rel="noopener">webp地址</a>去下载安装，安装完成之后，把安装路径里面bin文件夹路径添加到环境变量中去。</p><h3 id="使用webp"><a href="#使用webp" class="headerlink" title="使用webp"></a>使用webp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwebp *.webp -o *.png <span class="comment"># 第一个是webp文件名，第二个是转换后的png文件名。</span></span><br></pre></td></tr></table></figure><h2 id="启动爬虫程序"><a href="#启动爬虫程序" class="headerlink" title="启动爬虫程序"></a>启动爬虫程序</h2><ol><li>先调用爬取路径的方法，再调用下载文件的方法。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    get_img_url()</span><br><span class="line">    download_img_from()</span><br></pre></td></tr></table></figure><ol start="2"><li>启动爬虫</li></ol><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211190516.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python抓取和周迅有关的图片并下载到本地。&lt;br&gt;
    
    </summary>
    
      <category term="clawl" scheme="http://lemmo.xyz/categories/clawl/"/>
    
    
      <category term="python" scheme="http://lemmo.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用Item Pipeline把Scrapy爬取的数据存储到MongoDB</title>
    <link href="http://lemmo.xyz/post/Scrapy-To-MongoDB-By-Pipeline.html"/>
    <id>http://lemmo.xyz/post/Scrapy-To-MongoDB-By-Pipeline.html</id>
    <published>2019-02-08T09:45:13.000Z</published>
    <updated>2019-02-11T13:26:52.911Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>Item Pipeline(项目管道)</code>来保存使用Scrapy爬取的item对象</p><a id="more"></a><h2 id="Pipeline是什么"><a href="#Pipeline是什么" class="headerlink" title="Pipeline是什么"></a>Pipeline是什么</h2><blockquote><p>当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。</p><p>每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。 ——<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html" target="_blank" rel="noopener">Scrapy Doc</a></p></blockquote><p>item pipeline的功能：</p><ul><li>清理HTML数据</li><li>验证爬取的数据(检查item包含某些字段)</li><li>查重(并丢弃)</li><li><strong>将爬取结果保存到数据库中</strong></li></ul><h2 id="在pipeline-py中编写MongoDBPipeline"><a href="#在pipeline-py中编写MongoDBPipeline" class="headerlink" title="在pipeline.py中编写MongoDBPipeline"></a>在pipeline.py中编写MongoDBPipeline</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Item</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonoDBPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将item写入到MongoDB中</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="comment"># 访问配置文件取mongodb的url和name，如果没有则使用默认值</span></span><br><span class="line">        cls.DB_URL = crawler.settings.get(<span class="string">'MONGO_DB_URI'</span>, <span class="string">'mongodb://localhost:27017'</span>)</span><br><span class="line">        cls.DB_NAME = crawler.settings.get(<span class="string">'MONGO_DB_NAME'</span>, <span class="string">'scrapy_data'</span>)</span><br><span class="line">        <span class="keyword">return</span> cls()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client = pymongo.MongoClient(self.DB_URL)</span><br><span class="line">        self.db = self.client[self.DB_NAME]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        collection = self.db[spider.name]</span><br><span class="line">        <span class="comment"># 三元表达式（调用前先对item的类型进行判断，如果item是Item对象，就将其转换为字典)</span></span><br><span class="line">        post = dict(item) <span class="keyword">if</span> isinstance(item, Item) <span class="keyword">else</span> item </span><br><span class="line">        collection.insert_one(post)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="from-crawler-cls-crawler"><a href="#from-crawler-cls-crawler" class="headerlink" title="from_crawler(cls, crawler)"></a>from_crawler(cls, crawler)</h3><blockquote><p>如果存在，则调用这个类方法来从爬行器创建管道实例。它必须返回管道的新实例。爬虫对象提供对所有Scrapy核心组件的访问，如设置和信号；它是管道访问这些组件并将其功能挂钩到Scrapy的一种方式。</p></blockquote><ul><li><p>cls（item pipeline类）（如果创建<code>MongoDBPipeline类</code>就为<code>MongoDBPipeline类对象</code></p></li><li><p>crawler（Crawlerobject） - 使用此管道的crawler（可以通过<code>crawler.settings</code>访问该配置<code>setting.py</code>文件）</p></li></ul><h3 id="open-spider-amp-close-spider"><a href="#open-spider-amp-close-spider" class="headerlink" title="open_spider() &amp; close_spider()"></a>open_spider() &amp; close_spider()</h3><p>在Spider整个爬取过程中，数据库的连接和关闭操作只需要进行一次，应在开始处理数据之前连接数据库，并在处理完所有数据之后关闭数据库，因此实现以下两个方法(在Scrapy打开和关闭时被调用)。</p><h3 id="process-item-self-item-spider"><a href="#process-item-self-item-spider" class="headerlink" title="process_item(self, item, spider)"></a>process_item(self, item, spider)</h3><blockquote><p>每个项目管道组件是一个Python类，<strong>必须实现</strong>以下方法： <code>process_item(self, item, spider)</code>；</p><p>对于每个项目管道组件调用此方法。process_item() 必须：返回一个带数据的dict，返回一个Item （或任何后代类）对象，返回一个Twisted Deferred或者raise DropItemexception。</p></blockquote><p>在process_item中实现MongoDB数据库的写入操作，使用self.db和spider.name获取一个集合(collection)，然后将数据插入该集合。</p><h2 id="在配置文件中配置MongoDB的url和name"><a href="#在配置文件中配置MongoDB的url和name" class="headerlink" title="在配置文件中配置MongoDB的url和name"></a>在配置文件中配置MongoDB的url和name</h2><p>打开<code>Setting.py</code>在任何位置写入（<em>如果不写则默认使用MongoPipeLine.from_crwaler()中的信息</em>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MONGO_DB_URI = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">'python_ZhuanLan'</span></span><br></pre></td></tr></table></figure><h2 id="启动MongoPipeline组件"><a href="#启动MongoPipeline组件" class="headerlink" title="启动MongoPipeline组件"></a>启动MongoPipeline组件</h2><p>打开<code>Setting.py</code>，把MongoPipeline添加到<code>ITEM_PIPELINES</code>中，后面的数字代表它们的运算优先级（顺序），item按数字从低到高的顺序，通过pipeline（1-1000，数字越低组件的优先级越高）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">      <span class="string">'zhihu_Crawl.pipelines.MonoDBPipeline'</span>:<span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料：</strong></p><ul><li><a href="https://www.jianshu.com/p/3a3da0272262" target="_blank" rel="noopener">Scrapy使用Pipeline写入MongoDB</a></li><li><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html#id2" target="_blank" rel="noopener">Scrapy中文文档-Item Pipeline</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;Item Pipeline(项目管道)&lt;/code&gt;来保存使用Scrapy爬取的item对象&lt;/p&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://lemmo.xyz/categories/Scrapy/"/>
    
    
      <category term="Crawler" scheme="http://lemmo.xyz/tags/Crawler/"/>
    
      <category term="MongoDB" scheme="http://lemmo.xyz/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>使用Scrapy遇到的问题汇总</title>
    <link href="http://lemmo.xyz/post/The-Problem-Collection-Use-Scrapy.html"/>
    <id>http://lemmo.xyz/post/The-Problem-Collection-Use-Scrapy.html</id>
    <published>2019-02-07T12:31:32.000Z</published>
    <updated>2019-03-18T10:49:03.928Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下，自己再安装和使用Scrapy框架过程中遇到的各种问题及解决办法<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用环境：Win10 1803、Python 3.6.3</p><p>利用pip命令可以直接安装<code>Scrapy</code>，但是会出现一些安装包装不上而报错，比如Twisted。可以先去这个<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">Pyhton Extension Packages</a>下载<code>Twisted</code>到本地，然后单独安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install twisted</span><br></pre></td></tr></table></figure><p>（注意要下载<code>Twisted‑18.9.0‑cp36‑cp36m‑win_amd64.whl</code>不要下载错了，是cp36。否则安装的时候会提示<code>is not a supported wheel on this platform</code>）</p><h2 id="Scrapy输出文件编码为’utf-8’"><a href="#Scrapy输出文件编码为’utf-8’" class="headerlink" title="Scrapy输出文件编码为’utf-8’"></a>Scrapy输出文件编码为’utf-8’</h2><p>在编写爬虫中文内容输出到<code>*.json</code>文件后发现中文是<code>Unicode编码</code>，尝试了各种方法测试都不成功，后来找到一种方法终于成功了，把Scrapy项目文件夹中的<code>Setting.py</code>增加一行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEED_EXPORT_ENCODING = <span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure><h2 id="Scrapy导出csv文件乱码"><a href="#Scrapy导出csv文件乱码" class="headerlink" title="Scrapy导出csv文件乱码"></a>Scrapy导出csv文件乱码</h2><p>使用<code>Vscode的通过编码重新保存</code>，将文件的编码格式改为<code>UTF-8 with BOM</code>，再重新用Excel打开csv就正常了。</p><ul><li>参考：<a href="https://blog.csdn.net/u011361138/article/details/79912895" target="_blank" rel="noopener">https://blog.csdn.net/u011361138/article/details/79912895</a></li></ul><h2 id="Scrapy异常：http-status-code-is-not-handled-or-allowed"><a href="#Scrapy异常：http-status-code-is-not-handled-or-allowed" class="headerlink" title="Scrapy异常：http status code is not handled or allowed"></a>Scrapy异常：http status code is not handled or allowed</h2><p>原因是http状态码没有被识别，需要在settings.py中添加这个状态码信息，同样在<code>Setting.py</code>添加一行（如果是404错误就改为404，如果是400错误，就改成400：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTPERROR_ALLOWED_CODES = [状态码]</span><br><span class="line">HTTPERROR_ALLOWED_CODES = [404]</span><br><span class="line">HTTPERROR_ALLOWED_CODES = [400]</span><br></pre></td></tr></table></figure><p>另一种方法是在<code>Spider</code>函数中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handle_httpstatus_list = [404]</span><br><span class="line">handle_httpstatus_list = [400]</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190208160126.png" alt=""></p><p>如果还是出现<code>400错误</code>问题，我观察到后面的Debug信息是：*/robots.txt。</p><blockquote><p><strong>robots.txt（爬虫协议)</strong>是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。——<a href="https://zh.wikipedia.org/wiki/Robots.txt" target="_blank" rel="noopener">wiki</a></p><ul><li>知乎robots地址：<a href="https://www.zhihu.com/robots.txt" target="_blank" rel="noopener">https://www.zhihu.com/robots.txt</a></li><li>淘宝robots地址：<a href="https://www.taobao.com/robots.txt" target="_blank" rel="noopener">https://www.taobao.com/robots.txt</a></li></ul></blockquote><p>总结来说这个爬虫协议允许爬虫机器爬取的范围，不过这个协议属于君子协议，Scrapy默认是遵循<code>robot协议</code>，需要在<code>Setting.py</code>中改变<code>ROBOTSTXT_OBEY</code>的值为<code>False</code>。</p><p>在做了上面的设置之后还是400错误，可以给Reaqueset请求添加一个<code>Headers</code>头部，可以让爬虫伪装成浏览器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">    url = <span class="string">'http://www.hnfnu.edu.cn/index/xyxw/342.htm'</span>  <span class="comment"># 这样就不要设置Start_urls变量了</span></span><br><span class="line">    <span class="keyword">yield</span> Request(url, headers=self.headers)</span><br></pre></td></tr></table></figure><p>不过在我今天在爬去知乎专栏的文章（Ajax加载），调试了很久也只能抓取到第一次加载的列表内容，检查了后面的<code>yiled Requeset(url, callback=self.parse)</code> 设置没有问题，然后我把<code>Headers信息</code>添加在<code>Setting.py</code>中问题就解决了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>未完待补充……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录一下，自己再安装和使用Scrapy框架过程中遇到的各种问题及解决办法&lt;br&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://lemmo.xyz/categories/Scrapy/"/>
    
    
      <category term="Python" scheme="http://lemmo.xyz/tags/Python/"/>
    
      <category term="Debug" scheme="http://lemmo.xyz/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>Xlua热补丁修复</title>
    <link href="http://lemmo.xyz/post/xlua-hotfix.html"/>
    <id>http://lemmo.xyz/post/xlua-hotfix.html</id>
    <published>2018-05-10T12:51:14.000Z</published>
    <updated>2019-03-18T10:49:03.916Z</updated>
    
    <content type="html"><![CDATA[<p>使用xlua热补丁修复</p><a id="more"></a><p>在使用Ulua方法进行热更新的时候，在项目的开发阶段就必要用独立的Lua脚本实现，这样才能使用Ulua来进行热更新，但是如果一个项目完成之后发现需要进行热更新，这个时候用ULua就非常不方便了。但是XLua可以解决这个问题，解决方案就是<strong>“HotFix”热补丁</strong>。（对项目进行修补）实现方式：</p><blockquote><p>对要进行“修补”的C#类，在该类的头部[Hotfix]标签来标记，对于已经使用了<code>[hotfix]</code>标记了的类，可以通过“Lua”代码修改“类中的方法”。</p></blockquote><h1 id="使用HotFix进行热修复"><a href="#使用HotFix进行热修复" class="headerlink" title="使用HotFix进行热修复"></a>使用HotFix进行热修复</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="添加宏信息"><a href="#添加宏信息" class="headerlink" title="添加宏信息"></a>添加宏信息</h3><blockquote><p>File–&gt; Build Settings… –&gt; Player Settings… –&gt; Configuration：Scripting Define Symbols：HOTFIX_ENABLE；（对于每一个平台都需要添加这条宏信息！）</p></blockquote><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/29613175.jpg" alt=""></p><h3 id="执行菜单生成命令"><a href="#执行菜单生成命令" class="headerlink" title="执行菜单生成命令"></a>执行菜单生成命令</h3><p><strong>XLua-&gt;Generate Code</strong>，该命令执行完毕后会生成一堆Wrap 文件，存放到XLua/Gen 文件夹下。</p><h3 id="执行菜单注入命令"><a href="#执行菜单注入命令" class="headerlink" title="执行菜单注入命令"></a>执行菜单注入命令</h3><p><strong>XLua-&gt;Hotfix Inject In Editor</strong>，成功之后，会在控制台输出：“hotfix inject finish!”或者“had injected!”。</p><ul><li>如果出现红色警告提示“please install the Tools”，就需要把Tools 文件夹拷贝到项目中，和Assets 文件夹同级别位置。</li><li>只要修改过C#中的代码，就需要重新执行注入命令！（否则会报错）</li></ul><h1 id="HotFix热修复案例"><a href="#HotFix热修复案例" class="headerlink" title="HotFix热修复案例"></a>HotFix热修复案例</h1><h2 id="Hotfix语法"><a href="#Hotfix语法" class="headerlink" title="Hotfix语法"></a>Hotfix语法</h2><ul><li>引入命名空间：<code>using Xlua;</code></li><li>对要进行热修复的C#类用【hotfix】标记</li><li>编写hotfix命令：<code>xlua.hotfix(CS.类名, &#39;方法名&#39;, lua 方法)</code>（对于CS.类中的某个方法使用lua方法修复）</li><li>创建XLua虚拟机对象（Lua解析器），使用Dostring方法执行。</li></ul><h2 id="修复案例"><a href="#修复案例" class="headerlink" title="修复案例"></a>修复案例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Hotfix</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotFixDemo</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LuaEnv luaEnv;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> hotfixStrOne = <span class="string">@"</span></span><br><span class="line"><span class="string">        xlua.hotfix(CS.HotFixDemo, 'Hello', function()</span></span><br><span class="line"><span class="string">            print('Lua Hello~~')    </span></span><br><span class="line"><span class="string">        end)</span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> hotfixStrTwo = <span class="string">@"</span></span><br><span class="line"><span class="string">        xlua.hotfix(CS.HotFixDemo, 'Add', function(self, a, b)</span></span><br><span class="line"><span class="string">            print('Lua中的乘法:' .. a*b)</span></span><br><span class="line"><span class="string">        end)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        luaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.A))&#123;</span><br><span class="line">            Hello();</span><br><span class="line">            Add(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))&#123;</span><br><span class="line">            luaEnv.DoString(hotfixStrOne);</span><br><span class="line">            luaEnv.DoString(hotfixStrTwo);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"C# Hello~~"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"C#中的加法："</span> + (a + b));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参方法修复时，需要传递当前脚本对象this，在lua 中用self 代替。</li><li>要修复无参的方法，但是那个方法内使用到了该类中的字段，如果想要在Lua代码中方法到，有两种方法：<ol><li>C#类中的字段公开（使用Public修饰），在lua代码中通过<code>self.字段名</code>的方式来方法（破坏了C#语言的“封装性”）</li><li>在lua 语言中，使用代码获取C#类中private 成员的访问权<code>xlua.private_accessible(CS.类名)</code>，这样就可以在Lua 脚本中访问到C#类当中的私有成员，同时不会破坏C#原有的封装性和逻辑关系。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用xlua热补丁修复&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://lemmo.xyz/categories/Unity/"/>
    
    
      <category term="热更新" scheme="http://lemmo.xyz/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="xLua" scheme="http://lemmo.xyz/tags/xLua/"/>
    
      <category term="Untiy" scheme="http://lemmo.xyz/tags/Untiy/"/>
    
  </entry>
  
  <entry>
    <title>SimpleFrameWork框架简单介绍</title>
    <link href="http://lemmo.xyz/post/SimpleFrameWork-Introduction.html"/>
    <id>http://lemmo.xyz/post/SimpleFrameWork-Introduction.html</id>
    <published>2018-05-07T07:18:19.000Z</published>
    <updated>2019-03-18T10:49:03.919Z</updated>
    
    <content type="html"><![CDATA[<p>SimpleFramework的框架介绍<br><a id="more"></a></p><h1 id="SimpleFramework-框架"><a href="#SimpleFramework-框架" class="headerlink" title="SimpleFramework 框架"></a>SimpleFramework 框架</h1><p>SimpleFramework 框架是ULua的集成开发环境</p><ul><li>SimpleFramework     框架官网地址： <a href="http://www.ulua.org/index.html" target="_blank" rel="noopener">http://www.ulua.org/index.html</a></li><li>SimpleFramework 分为两个版本：NGUI 版和UGUI 版，区别是NGUI 版本的框架资源中含有NGUI 这个插件。</li></ul><h1 id="SimpleFramework-和ULua和Lua的关系"><a href="#SimpleFramework-和ULua和Lua的关系" class="headerlink" title="SimpleFramework 和ULua和Lua的关系"></a>SimpleFramework 和ULua和Lua的关系</h1><p>ULua是对原生Lua 环境进行了一次“包装”，用于满足Unity 环境下的热更新需求。为了更方便的使用，于是又对ULua进行“二次包装”，包装成了一个框架：SimpleFramework，比如它们创建Lua的解析器对象都不相同。</p><ul><li>Lua：<code>Lua lua = New Lua();</code></li><li>Ulua：<code>LuaState Lua = new LuaState();</code></li><li>SimpleFramework:<code>LuaScriptMgr lua = new LuaScriptMgr();</code></li></ul><p>它们的关系是：<code>SimpleFramework</code> &gt; <code>ULua</code> &gt; <code>Lua</code></p><h1 id="SimpleFramework框架资源结构"><a href="#SimpleFramework框架资源结构" class="headerlink" title="SimpleFramework框架资源结构"></a>SimpleFramework框架资源结构</h1><ul><li><code>Examples</code>：SimpleFramework 热更新案例；</li><li><code>Lua</code>：SimpleFramework 框架自带的Lua 源码文件；（自己写的Lua脚本放在这个路径）</li><li><code>NGUI</code>：NGUI3.8.2，当你需用更高版本的NGUI 时，替换即可，不需要碰；</li><li><code>Plugins</code>：uLua 运行所依赖的底层库文件，不需要碰；</li><li><code>Scripts</code>：SimpleFramework 自带的C#脚本文件；</li><li><code>uLua</code>：uLua 全部代码。</li></ul><p>和Ulua紧密相关的是：<code>Plugins</code>、<code>uLua</code>。和SimpleFramework相关的是：<code>Examples</code>、<code>Lua</code>、<code>Scripts</code></p><h1 id="使用框架"><a href="#使用框架" class="headerlink" title="使用框架"></a>使用框架</h1><h2 id="框架自带的编辑器命令"><a href="#框架自带的编辑器命令" class="headerlink" title="框架自带的编辑器命令"></a>框架自带的编辑器命令</h2><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/71191708.jpg" alt=""></p><h3 id="Lua菜单：uLua-环境相关处理命令-必备操作"><a href="#Lua菜单：uLua-环境相关处理命令-必备操作" class="headerlink" title="Lua菜单：uLua 环境相关处理命令(必备操作)"></a>Lua菜单：uLua 环境相关处理命令(必备操作)</h3><ul><li><p>Gen Lua Wrap Files：生成LuaWrap文件</p><p>该命令用于生成“Lua 包装文件”，存放在<strong>uLua\Source\LuaWrap</strong> 目录下。该文件夹下全部是C#脚本，这些脚本文件的名称特点是：脚本名+ Wrap；该文件夹下的脚本对Unity 内常用组件脚本的二次包装，、</p><p>Lua 环境运行后，会把这些Wrap 文件加载到Lua 运行环境(Lua 虚拟机)中，最终的效果就是：Lua 调用Wrap 文件，Wrap 文件调用C#，来实现Lua 调用C#。</p></li><li><p>Clear Lua….. Wrap Files：清除LuaWrap文件，也可以自己手动删除。</p></li></ul><h3 id="Game菜单：Build-xxxx-生成不同平台的AssetBundle-资源-必备操作"><a href="#Game菜单：Build-xxxx-生成不同平台的AssetBundle-资源-必备操作" class="headerlink" title="Game菜单：Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]"></a>Game菜单：Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]</h3><p>Game–&gt;Build Windows Resource 生成Windows 平台下的AB 文件。生成后的AB 会存放到StreamingAssets 文件夹下。在生成的过程中同时还会把Lua 文件夹下的所有脚本拷贝到该目录，存放到lua 文件夹下。</p><p>在<code>\Assets\uLua\Editor\Packager.cs</code>脚本中的<code>HandleLuaFile方法</code>就是将<code>/Lua/</code>文件复制到<code>/StreamingAssets/</code>文件夹中（这是本地Server设置的资源的地址，模拟服务器的资源地址）</p><h1 id="Lua-文件夹结构分析"><a href="#Lua-文件夹结构分析" class="headerlink" title="Lua 文件夹结构分析"></a>Lua 文件夹结构分析</h1><ul><li>3rd：第三方的Lua 脚本插件；</li><li>Common：公共Lua 文件目录；</li><li>Controller：控制器目录；</li><li>Logic：管理器目录；</li><li>System：cstolua 的系统目录；</li><li>View：视图层目录。</li></ul><h1 id="ULua-文件夹结构"><a href="#ULua-文件夹结构" class="headerlink" title="ULua 文件夹结构"></a>ULua 文件夹结构</h1><p>SimpleFramework 框架项目的核心是uLua，在Unity 环境下使用uLua可以实现Lua 脚本与Unity 内C#脚本的交互，通过Lua 脚本来操作Unity3D内的各种游戏组件。</p><ul><li>Core：uLua 核心；</li><li>Docs：uLua 文档，其实就是LuaInterface 的PDF 使用文档；</li><li>Editor：uLua 编辑器扩展；<br>[备注：项目内所有的Editor 文件夹都是编辑器扩展文件夹，并不局限于根目录]</li><li>Examples：uLua 自带演示案例；</li><li>Source：cstolua 核心目录。</li></ul><h1 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h1><p>参考：擅码网Lua热更新文档资料</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SimpleFramework的框架介绍&lt;br&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://lemmo.xyz/categories/Unity/"/>
    
      <category term="Lua" scheme="http://lemmo.xyz/categories/Unity/Lua/"/>
    
    
      <category term="ULua" scheme="http://lemmo.xyz/tags/ULua/"/>
    
      <category term="SimpleFramework" scheme="http://lemmo.xyz/tags/SimpleFramework/"/>
    
      <category term="Unity" scheme="http://lemmo.xyz/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>SimpleFramwork框架下Ulua与C#的交互</title>
    <link href="http://lemmo.xyz/post/Ulua-And-Charp-Communicate.html"/>
    <id>http://lemmo.xyz/post/Ulua-And-Charp-Communicate.html</id>
    <published>2018-05-07T07:09:54.000Z</published>
    <updated>2019-02-11T13:31:05.384Z</updated>
    
    <content type="html"><![CDATA[<p>在SimpleFramwork框架下，Ulua与C#的交互！</p><a id="more"></a><h1 id="uLua环境下与C-交互（基本操作）"><a href="#uLua环境下与C-交互（基本操作）" class="headerlink" title="uLua环境下与C#交互（基本操作）"></a>uLua环境下与C#交互（基本操作）</h1><p>在C#与Lua进行交互需要两个DLL文件来实现分别是<code>Luainterface.dll</code>（C#脚本使用Lua）、<code>luanet.dll</code>(Lua脚本调用C#)。因此需要事先把那两个DLL文件拷贝到项目路径中去，再引用。</p><p>在uLua 环境下本质也是通过LuaInterface 来实现Lua 与C#语言交互的。但是uLua 对LuaInterface 进行了二次的封装，不需需要自己手动拷贝这个DLL文件，但是的使用的使用还是要引入命名空间：<code>using LuaInterface;</code></p><h2 id="Lua-代码与Unity-内的类的交互-反射方式-原生方式"><a href="#Lua-代码与Unity-内的类的交互-反射方式-原生方式" class="headerlink" title="Lua 代码与Unity 内的类的交互[反射方式/ 原生方式]"></a>Lua 代码与Unity 内的类的交互[反射方式/ 原生方式]</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个字符串变量保存Lua代码（调用C#的类和方法来创建了一个游戏物体，并给它添加了一个“BoxCollider”组件）    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> str1 = <span class="string">@"</span></span><br><span class="line"><span class="string">    luanet.load_assembly('UnityEngine')</span></span><br><span class="line"><span class="string">    GameObject = luanet.import_type('UnityEngine.GameObject')</span></span><br><span class="line"><span class="string">    BoxCollider = luanet.import_type('UnityEngine.BoxCollider')</span></span><br><span class="line"><span class="string">    local player = GameObject('Lemmo')</span></span><br><span class="line"><span class="string">    player:AddComponent(luanet.ctype(BoxCollider))</span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Lua解析器对象，并执行上面定义的Lua脚本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        LuaState lua = <span class="keyword">new</span> LuaState();</span><br><span class="line">        lua.DoString(str1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>luanet 已经被封装到了LuaInterface 命名空间内，所以我们可以在Lua代码中直接使用luanet 这个对象；</li><li>在Lua 环境内操作C#中的类创建对象，不要写new 关键字！</li><li>在Lua 环境内操作C#中的类创建对象，访问对象中的方法使用分号（:）；</li><li><p>这种“反射方式”在项目开发中并不常用，但是也有用无之地，真正大量使用的是下方的Wrap 方式。</p></li><li><p>同样需要在C#代码中引入LuaInterface；</p></li><li>原生的Lua 解析器对象“Lua”被二次封装成了“LuaState”；</li><li>LuaState 类存在的位置是：uLua\Core\Lua.cs。</li></ul><h2 id="Lua-代码与Unity-内的类的交互-Wrap-方式"><a href="#Lua-代码与Unity-内的类的交互-Wrap-方式" class="headerlink" title="Lua 代码与Unity 内的类的交互[Wrap 方式]"></a>Lua 代码与Unity 内的类的交互[Wrap 方式]</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 和Str1的功能类似，只不过str2使用了Wrap的方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> str2 = <span class="string">@"</span></span><br><span class="line"><span class="string">    luanet.load_assembly('UnityEngine')</span></span><br><span class="line"><span class="string">    GameObject = UnityEngine.GameObject</span></span><br><span class="line"><span class="string">    BoxCollider = UnityEngine.BoxCollider</span></span><br><span class="line"><span class="string">    local player = GameObject('WrapLemmo')</span></span><br><span class="line"><span class="string">    player:AddComponent(BoxCollider.GetClassType())</span></span><br><span class="line"><span class="string">        "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        LuaScriptMgr lua = <span class="keyword">new</span> LuaScriptMgr();</span><br><span class="line">        lua.Start();</span><br><span class="line">        lua.DoString(str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p>这种是在uLua 开发过程中最常用的方式，95%+情况都是使用这种方式；</p></li><li><p>Wrap 方式实现Lua 调用C#，依赖的是之前生成的LuaWrap 文件；</p><p>[也就是我们通过菜单自动生成到<strong>uLua\Source\LuaWrap</strong> 下的脚本文件]</p></li><li><p>当使用Wrap 方式时，运行Lua 代码需要使用LuaScriptMgr；</p></li><li><p>需要把AppConst.cs 脚本中的的DebugMode 修改为true。</p></li></ul><h2 id="包装新的Wrap-脚本"><a href="#包装新的Wrap-脚本" class="headerlink" title="包装新的Wrap 脚本"></a>包装新的Wrap 脚本</h2><p>当我们用Lua 的Wrap 方式访问Unity 中的组件脚本，或者自己写的脚本的使用，如果这些脚本没有自动生成“xxxxWrap”,项目运行后，就会报错。比如在用Wrap的方式给Player对象通过Lua添加<code>Animator</code>组件的时候，就会报错.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animator = UnityEngine.Animator </span><br><span class="line">player:AddComponent(Animator.GetClassType())</span><br></pre></td></tr></table></figure><p>解决办法：往框架内添加需要处理的新的类。</p><ol><li>找到uLua\Editor\WrapFile.cs 打开该脚本，使用该格式进行添加：_GT(typeof(类名)) ；</li><li>Lua–&gt;Clear LuaBinder File + Wrap File 清空原有的Wrap 文件；</li><li>Lua–&gt;Gen Lua Wrap Files 重新生成Wrap 文件；</li></ol><h1 id="关于Lua使用“-”和“-”来调用属性和方法"><a href="#关于Lua使用“-”和“-”来调用属性和方法" class="headerlink" title="关于Lua使用“.”和“:”来调用属性和方法"></a>关于Lua使用“.”和“:”来调用属性和方法</h1><p>在Lua语言中，直接调用操作C#中的对象的方法和属性直接使用“.”来调用，如果是在Lua代码中实例化出来的对象，再调用这个对象的方法则需要用“:”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SimpleFramwork框架下，Ulua与C#的交互！&lt;/p&gt;
    
    </summary>
    
      <category term="Lua - Ulua" scheme="http://lemmo.xyz/categories/Lua-Ulua/"/>
    
    
      <category term="Unity" scheme="http://lemmo.xyz/tags/Unity/"/>
    
      <category term="Lua" scheme="http://lemmo.xyz/tags/Lua/"/>
    
      <category term="热更新" scheme="http://lemmo.xyz/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="SimpleFramwork" scheme="http://lemmo.xyz/tags/SimpleFramwork/"/>
    
  </entry>
  
  <entry>
    <title>Lua与Charp交互</title>
    <link href="http://lemmo.xyz/post/lua-with-csharp.html"/>
    <id>http://lemmo.xyz/post/lua-with-csharp.html</id>
    <published>2018-04-24T11:33:39.000Z</published>
    <updated>2019-03-18T10:49:03.915Z</updated>
    
    <content type="html"><![CDATA[<p>Lua与C#的交互<br><a id="more"></a></p><h1 id="Lua与C-进行交互"><a href="#Lua与C-进行交互" class="headerlink" title="Lua与C#进行交互"></a>Lua与C#进行交互</h1><p>在项目中，C#语言是主语言，Lua 语言是辅助语言，如何才能让两门语言的代码互相访问那？这时候我们需要一座“桥梁”来连接两门语言。</p><h2 id="LuaInterface"><a href="#LuaInterface" class="headerlink" title="LuaInterface"></a>LuaInterface</h2><p>LuaInterface 就是C#与Lua 语言相连的那座桥梁。LuaInterface 是一个开源的项目工程，内部有两个核心的DLL 文件：</p><ul><li><code>LuaInterface.dll</code>：在C#代码中操作Lua 代码需要依赖该文件；</li><li><code>luanet.dll</code>：在Lua 代码中访问C#的类库脚本需要依赖该文件。</li></ul><h2 id="在项目中配置使用Lua环境"><a href="#在项目中配置使用Lua环境" class="headerlink" title="在项目中配置使用Lua环境"></a>在项目中配置使用Lua环境</h2><ol><li>将两个dll 文件拷贝到项目工程中；</li><li>项目工程设置“引用”导入LuaInterface.dll；</li><li>将两个dll 的属性都设置成“如果较新则复制”（非常重要，如果不引用则会报错）</li></ol><h2 id="使用lua解析器对象"><a href="#使用lua解析器对象" class="headerlink" title="使用lua解析器对象"></a>使用lua解析器对象</h2><ol><li>引入<code>using LuaInterface;</code>命名空间；</li><li>实例化<code>lua解析器对象</code>：<code>Lua lua = new Lua()</code>；</li><li>使用lua解析器对象的一些方法。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> LuaInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LuaThree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line">            lua.DoString(<span class="string">"print('This is Lua program')"</span>); <span class="comment">// 这里执行的是Lua代码</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-中Lua代码空间分析"><a href="#C-中Lua代码空间分析" class="headerlink" title="C#中Lua代码空间分析"></a>C#中Lua代码空间分析</h3><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/96335950.jpg" alt=""></p><p>实际上，虽然C#代码和Lua代码是在一个脚本文件中，但是在程序执行的时候，lua代码（上面第11代码是放到了Lua的那块空间去的）</p><h1 id="C-调用Lua代码"><a href="#C-调用Lua代码" class="headerlink" title="C#调用Lua代码"></a>C#调用Lua代码</h1><h2 id="C-内执行lua代码"><a href="#C-内执行lua代码" class="headerlink" title="C#内执行lua代码"></a>C#内执行lua代码</h2><p>语法：<code>Lua解析器对象.DoString(&quot;Lua代码&quot;)</code></p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 变量的声明与访问；</span></span><br><span class="line">lua.DoString(<span class="string">"name = 'YangJie' age = 19 gender = 'Man' address = 'HuNan'"</span>);</span><br><span class="line">Console.WriteLine(lua[<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. for循环语句；[演示@符号的用途]</span></span><br><span class="line">lua.DoString(<span class="string">@"for i = 1,10,1 do</span></span><br><span class="line"><span class="string">                print(i) </span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 函数的定义与调用；</span></span><br><span class="line">lua.DoString(<span class="string">@"function Show()</span></span><br><span class="line"><span class="string">                print('Show LuaFunction in Csharp.');</span></span><br><span class="line"><span class="string">             end</span></span><br><span class="line"><span class="string">            Show()"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. table 数组声明</span></span><br><span class="line">lua.DoString(<span class="string">@" MyArray = &#123;'AAA', 'BBB', 'CCC'&#125;"</span>);</span><br></pre></td></tr></table></figure><h2 id="C-中调用外部的Lua脚本"><a href="#C-中调用外部的Lua脚本" class="headerlink" title="C#中调用外部的Lua脚本"></a>C#中调用外部的Lua脚本</h2><p>在实际的时候中，大都汇直接调用外部的Lua脚本</p><p><strong>语法：</strong><code>Lua解析器对象.DoFile(&quot;[path]fileName.lua&quot;)</code>方法。</p><blockquote><p><strong>创建Lua脚本文件：</strong>添加-&gt;新建项-&gt;常规-&gt;文本文件，改名且后缀写为.lua;（注意要用其他的编辑器把编码格式从“UTF-8 BOM”改成 “UTF-8”或“GB2312”(中文编码)，否则会抛异常）</p></blockquote><p>注意：在创建Lua文件之后，在VS里面将该文件的<strong>“复制到输出路径”设置为“如果较新则复制”</strong>，否则也会抛异常。（无法找到该文件）</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>MyLua.lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Yangjie"</span></span><br><span class="line">address = <span class="string">"HuNan"</span></span><br><span class="line">age = <span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Lua脚本内的方法"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>C#执行脚本</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lua.DoFile(<span class="string">"MyLua.lua"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> name = lua.GetString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">string</span> address = lua.GetString(<span class="string">"address"</span>);</span><br><span class="line">Double age = lua.GetNumber(<span class="string">"age"</span>);</span><br><span class="line">Console.WriteLine(name + <span class="string">".."</span> + address + <span class="string">".."</span> + age.ToString());</span><br><span class="line"></span><br><span class="line">LuaFunction luaFunction = lua.GetFunction(<span class="string">"Fun"</span>);</span><br><span class="line">luaFunction.Call();</span><br></pre></td></tr></table></figure><h1 id="Lua调用Charp"><a href="#Lua调用Charp" class="headerlink" title="Lua调用Charp"></a>Lua调用Charp</h1><p>对于C#的项目来说，Lua脚本是作为资源存在资源路径下，我们可以对Lua脚本的进行热更新。而Lua脚本就需要访问C#脚本。在Lua中调用C#脚本需要使用<code>luanet.dll</code>这个类库。</p><p><strong>使用步骤：</strong></p><ol><li>导入luanet.dll：<code>require &quot;luanet&quot;</code></li><li>获取程序集：<code>luanet.load_assembly(&quot;程序集名&quot;)</code></li><li>获取类型：<code>变量名 = luanet.import_type(&quot;程序集名.类名&quot;)</code></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Calc.cs（C#中创建一个类，省略了一些代码）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> name = <span class="string">"Calc计算器类"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Jia</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"这是Calc内的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LuaUpdate.lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"luanet"</span>  <span class="comment">-- 导入luanet.dll</span></span><br><span class="line">luanet.load_assembly(<span class="string">"LuaThree"</span>)  <span class="comment">-- 导入程序集</span></span><br><span class="line">Calc = luanet.import_type(<span class="string">"LuaThree.Calc"</span>) <span class="comment">-- 导入类</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Calc.Jia(<span class="number">10</span>, <span class="number">20</span>)) </span><br><span class="line"><span class="built_in">print</span>(Calc.name)</span><br></pre></td></tr></table></figure><p>Program.cs（只保留了核心代码）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line">lua.DoFile(<span class="string">"LuaUpdate.lua"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"><span class="comment">// 这是Calc内的方法</span></span><br></pre></td></tr></table></figure><h3 id="Lua内方法C-的类库"><a href="#Lua内方法C-的类库" class="headerlink" title="Lua内方法C#的类库"></a>Lua内方法C#的类库</h3><p>导入步骤和上面的几乎类似，比如我想导入<code>Console</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"luanet"</span> </span><br><span class="line">luanet.load_assembly(<span class="string">"System"</span>)</span><br><span class="line">Calc = luanet.import_type(<span class="string">"System.Console"</span>)</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"Lua内调用C#的类库"</span>)</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>主要资料来自擅码网Lua课程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lua与C#的交互&lt;br&gt;
    
    </summary>
    
      <category term="lua" scheme="http://lemmo.xyz/categories/lua/"/>
    
    
      <category term="Unity" scheme="http://lemmo.xyz/tags/Unity/"/>
    
      <category term="lua" scheme="http://lemmo.xyz/tags/lua/"/>
    
      <category term="Charp" scheme="http://lemmo.xyz/tags/Charp/"/>
    
  </entry>
  
</feed>
