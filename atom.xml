<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lemmo&#39;s Blog</title>
  
  <subtitle>一个人的碎碎念</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yslemmo.github.io/"/>
  <updated>2019-02-11T11:11:44.460Z</updated>
  <id>http://yslemmo.github.io/</id>
  
  <author>
    <name>lemmo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>抓取再豆瓣搜索到的图片</title>
    <link href="http://yslemmo.github.io/2019/02/11/crawl-douban-image-and-download/"/>
    <id>http://yslemmo.github.io/2019/02/11/crawl-douban-image-and-download/</id>
    <published>2019-02-11T04:01:02.000Z</published>
    <updated>2019-02-11T11:11:44.460Z</updated>
    
    <content type="html"><![CDATA[<p>爬取豆瓣图片并下载到本地</p><p>使用Python抓取和周迅有关的图片并下载到本地。<a id="more"></a></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>​    </p><p>豆瓣搜索“周迅”的相关图片，并且下载到本地</p><p><img src="https://blog-1258616090.cos.ap-chengdu.myqcloud.com/20190211120554.png" alt=""></p><h1 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h1><p>豆瓣图片是通过<code>Ajax</code>动态加载的，按F12打开Chrome浏览器的开发者工具，图片是通过GET来请求的，请求地址是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;<span class="built_in">limit</span>=20&amp;start=0</span><br></pre></td></tr></table></figure><p>其中：【q=：关键字| limit=：一次请求的数量（修改了也没用） | start=：请求的开始位置（偏移量）】。点开Preview，看到网站给我们发送了一个20个长度的<code>json数据包</code></p><p><img src="https://blog-1258616090.cos.ap-chengdu.myqcloud.com/20190211121129.png" alt=""></p><p>点开第一个，这里面有几个key，我们需要的是图片的<code>url</code>，另外还可以存储图片的<code>title</code>。这里面可以看到有两个url，分别是<code>scr</code>和<code>url</code>。</p><p><img src="https://blog-1258616090.cos.ap-chengdu.myqcloud.com/20190211122017.png" alt=""></p><p>把它们全部在地址栏打开，发现这个<code>scr</code>链接是图片的缩略图地址，这个<code>url</code>链接是图片post的主页地址。这两个都不是我们想要的，但是可以右键看一下图片的真实地址</p><p><img src="https://blog-1258616090.cos.ap-chengdu.myqcloud.com/20190211122906.png" alt=""></p><p>复制出来图片的地址，观察到图片的命名就是上面接受的<code>id值</code>，这样我们就可以通过获取每张图片的id值来组拼出图片的下载地址了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://img3.doubanio.com/view/photo/l/public/p637462204.webp</span><br></pre></td></tr></table></figure><h1 id="完整的爬取"><a href="#完整的爬取" class="headerlink" title="完整的爬取"></a>完整的爬取</h1><p>定义Header，图片的存储地址，保存抓取到的图片item</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="string">'./image'</span>         <span class="comment"># 图片地址</span></span><br><span class="line">imageItemList = []      <span class="comment"># 用列表存储所有的图片item（字典）</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>:<span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>:<span class="string">'gzip, deflate, sdch'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>:<span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Cache-Control'</span>:<span class="string">'max-age=0'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>:<span class="string">'keep-alive'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中"><a href="#获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中" class="headerlink" title="获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中"></a>获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_url</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取图片的url下载地址</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">300</span>,<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">'https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;limit=20&amp;start=0'</span></span><br><span class="line">        response = requests.request(<span class="string">'Get'</span>, url,headers=headers)</span><br><span class="line">        images = json.loads(response.content.decode(<span class="string">'utf-8'</span>))[<span class="string">'images'</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(images)):</span><br><span class="line">            imageItem = &#123;&#125;</span><br><span class="line">            imageItem[<span class="string">'title'</span>] = images[j][<span class="string">'title'</span>]</span><br><span class="line">            id = images[j][<span class="string">'id'</span>]</span><br><span class="line">            imageItem[<span class="string">'url'</span>] = <span class="string">'https://img3.doubanio.com/view/photo/l/public/p'</span>+str(id)+<span class="string">'.webp'</span></span><br><span class="line">            imageItemList.append(imageItem)</span><br></pre></td></tr></table></figure><ul><li>通过For循环获取，<code>range(0,300,20)</code>，表示要获取的图片数量为300张，Sep（步长）为20，因为每次获取的是20条数据。</li><li>通过<code>response.content</code>，获取<code>response</code>返回的内容，之前用<code>response.body</code>提示错误。这个应该是scrapy自己封装的属性。</li><li>通过<code>json.loads()</code>把<code>json对象</code>转换成<code>Python对象</code>，这样方便Python去解析。</li><li>图片的<code>url</code>是通过id值来组拼的。</li></ul><p>从列表获取图片链接并下载图片，然后使用<code>dwebp</code>工具转换图片格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_download</span><span class="params">(url, path)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    下载文件的方法</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_img_from</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    从数组中取出所有图片链接并下载，下载后使用dwebp转换图片格式为png，并删除dwebp源图片</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 判断是否电脑中是否有此目录，如果没有则创建一个空目录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir):</span><br><span class="line">        os.mkdir(dir)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> imageItemList:</span><br><span class="line">        url = item[<span class="string">'url'</span>]</span><br><span class="line">        fullpath = dir +<span class="string">'/'</span>+ str(index) + <span class="string">'.webp'</span></span><br><span class="line">        <span class="comment"># 调用下载方法</span></span><br><span class="line">        request_download(url, fullpath)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">'开始转换第'</span>+str(index)+<span class="string">'张图片：'</span>)</span><br><span class="line">            os.system(<span class="string">'dwebp ./image/%d.webp -o ./image/%d.png'</span> %(index,index))</span><br><span class="line">            print(<span class="string">'转换第'</span>+str(index)+<span class="string">'张图片完成.'</span>)</span><br><span class="line">            os.remove(<span class="string">'./image/'</span>+str(index)+<span class="string">'.webp'</span>) <span class="comment">#删除webp格式的图片</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            print(err)</span><br><span class="line">        index += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>从上面的图片item中获取每张图片的<code>url</code>，调用下载方法。</li><li>注意：这里获取下载的图片是<code>webp</code>编码的，需要使用<code>dwebp</code>工具进行转换。</li></ul><blockquote><p>WebP（Google开发），是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，派生自影像编码格式VP8。在同样大小的图片文件中，能比其他格式更加清晰，能提高网页加载速度，减少网络存储。</p></blockquote><h3 id="安装webp工具"><a href="#安装webp工具" class="headerlink" title="安装webp工具"></a>安装webp工具</h3><p>直接在<code>scoop</code>中搜索安装（libwqbp）即可，还可以直接去google的<a href="https://developers.google.com/speed/webp/docs/precompiled" target="_blank" rel="noopener">webp地址</a>去下载安装，安装完成之后，把安装路径里面bin文件夹路径添加到环境变量中去。</p><h3 id="使用webp"><a href="#使用webp" class="headerlink" title="使用webp"></a>使用webp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwebp *.webp -o *.png <span class="comment"># 第一个是webp文件名，第二个是转换后的png文件名。</span></span><br></pre></td></tr></table></figure><h2 id="启动爬虫程序"><a href="#启动爬虫程序" class="headerlink" title="启动爬虫程序"></a>启动爬虫程序</h2><ol><li>先调用爬取路径的方法，再调用下载文件的方法。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    get_img_url()</span><br><span class="line">    download_img_from()</span><br></pre></td></tr></table></figure><ol start="2"><li>启动爬虫</li></ol><p><img src="https://blog-1258616090.cos.ap-chengdu.myqcloud.com/20190211190516.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爬取豆瓣图片并下载到本地&lt;/p&gt;
&lt;p&gt;使用Python抓取和周迅有关的图片并下载到本地。
    
    </summary>
    
      <category term="clawl" scheme="http://yslemmo.github.io/categories/clawl/"/>
    
    
      <category term="python" scheme="http://yslemmo.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用Item Pipeline把Scrapy爬取的数据存储到MongoDB</title>
    <link href="http://yslemmo.github.io/2019/02/08/Scrapy-To-MongoDB-By-Pipeline/"/>
    <id>http://yslemmo.github.io/2019/02/08/Scrapy-To-MongoDB-By-Pipeline/</id>
    <published>2019-02-08T09:45:13.000Z</published>
    <updated>2019-02-08T10:50:45.552Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>Item Pipeline(项目管道)</code>来保存使用Scrapy爬取的item对象</p><a id="more"></a><h2 id="Pipeline是什么"><a href="#Pipeline是什么" class="headerlink" title="Pipeline是什么"></a>Pipeline是什么</h2><blockquote><p>当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。</p><p>每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。 ——<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html" target="_blank" rel="noopener">Scrapy Doc</a></p></blockquote><p>item pipeline的功能：</p><ul><li>清理HTML数据</li><li>验证爬取的数据(检查item包含某些字段)</li><li>查重(并丢弃)</li><li><strong>将爬取结果保存到数据库中</strong></li></ul><h2 id="在pipeline-py中编写MongoDBPipeline"><a href="#在pipeline-py中编写MongoDBPipeline" class="headerlink" title="在pipeline.py中编写MongoDBPipeline"></a>在pipeline.py中编写MongoDBPipeline</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Item</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonoDBPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将item写入到MongoDB中</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="comment"># 访问配置文件取mongodb的url和name，如果没有则使用默认值</span></span><br><span class="line">        cls.DB_URL = crawler.settings.get(<span class="string">'MONGO_DB_URI'</span>, <span class="string">'mongodb://localhost:27017'</span>)</span><br><span class="line">        cls.DB_NAME = crawler.settings.get(<span class="string">'MONGO_DB_NAME'</span>, <span class="string">'scrapy_data'</span>)</span><br><span class="line">        <span class="keyword">return</span> cls()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client = pymongo.MongoClient(self.DB_URL)</span><br><span class="line">        self.db = self.client[self.DB_NAME]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        collection = self.db[spider.name]</span><br><span class="line">        <span class="comment"># 三元表达式（调用前先对item的类型进行判断，如果item是Item对象，就将其转换为字典)</span></span><br><span class="line">        post = dict(item) <span class="keyword">if</span> isinstance(item, Item) <span class="keyword">else</span> item </span><br><span class="line">        collection.insert_one(post)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="from-crawler-cls-crawler"><a href="#from-crawler-cls-crawler" class="headerlink" title="from_crawler(cls, crawler)"></a>from_crawler(cls, crawler)</h3><blockquote><p>如果存在，则调用这个类方法来从爬行器创建管道实例。它必须返回管道的新实例。爬虫对象提供对所有Scrapy核心组件的访问，如设置和信号；它是管道访问这些组件并将其功能挂钩到Scrapy的一种方式。</p></blockquote><ul><li><p>cls（item pipeline类）（如果创建<code>MongoDBPipeline类</code>就为<code>MongoDBPipeline类对象</code></p></li><li><p>crawler（Crawlerobject） - 使用此管道的crawler（可以通过<code>crawler.settings</code>访问该配置<code>setting.py</code>文件）</p></li></ul><h3 id="open-spider-amp-close-spider"><a href="#open-spider-amp-close-spider" class="headerlink" title="open_spider() &amp; close_spider()"></a>open_spider() &amp; close_spider()</h3><p>在Spider整个爬取过程中，数据库的连接和关闭操作只需要进行一次，应在开始处理数据之前连接数据库，并在处理完所有数据之后关闭数据库，因此实现以下两个方法(在Scrapy打开和关闭时被调用)。</p><h3 id="process-item-self-item-spider"><a href="#process-item-self-item-spider" class="headerlink" title="process_item(self, item, spider)"></a>process_item(self, item, spider)</h3><blockquote><p>每个项目管道组件是一个Python类，<strong>必须实现</strong>以下方法： <code>process_item(self, item, spider)</code>；</p><p>对于每个项目管道组件调用此方法。process_item() 必须：返回一个带数据的dict，返回一个Item （或任何后代类）对象，返回一个Twisted Deferred或者raise DropItemexception。</p></blockquote><p>在process_item中实现MongoDB数据库的写入操作，使用self.db和spider.name获取一个集合(collection)，然后将数据插入该集合。</p><h2 id="在配置文件中配置MongoDB的url和name"><a href="#在配置文件中配置MongoDB的url和name" class="headerlink" title="在配置文件中配置MongoDB的url和name"></a>在配置文件中配置MongoDB的url和name</h2><p>打开<code>Setting.py</code>在任何位置写入（<em>如果不写则默认使用MongoPipeLine.from_crwaler()中的信息</em>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MONGO_DB_URI = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">'python_ZhuanLan'</span></span><br></pre></td></tr></table></figure><h2 id="启动MongoPipeline组件"><a href="#启动MongoPipeline组件" class="headerlink" title="启动MongoPipeline组件"></a>启动MongoPipeline组件</h2><p>打开<code>Setting.py</code>，把MongoPipeline添加到<code>ITEM_PIPELINES</code>中，后面的数字代表它们的运算优先级（顺序），item按数字从低到高的顺序，通过pipeline（1-1000，数字越低组件的优先级越高）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">      <span class="string">'zhihu_Crawl.pipelines.MonoDBPipeline'</span>:<span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料：</strong></p><ul><li><a href="https://www.jianshu.com/p/3a3da0272262" target="_blank" rel="noopener">Scrapy使用Pipeline写入MongoDB</a></li><li><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html#id2" target="_blank" rel="noopener">Scrapy中文文档-Item Pipeline</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;Item Pipeline(项目管道)&lt;/code&gt;来保存使用Scrapy爬取的item对象&lt;/p&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://yslemmo.github.io/categories/Scrapy/"/>
    
    
      <category term="Crawler" scheme="http://yslemmo.github.io/tags/Crawler/"/>
    
      <category term="MongoDB" scheme="http://yslemmo.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>使用Scrapy遇到的问题汇总</title>
    <link href="http://yslemmo.github.io/2019/02/07/The-Problem-Collection-Use-Scrapy/"/>
    <id>http://yslemmo.github.io/2019/02/07/The-Problem-Collection-Use-Scrapy/</id>
    <published>2019-02-07T12:31:32.000Z</published>
    <updated>2019-02-08T10:52:31.208Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下，自己再安装鹤使用Scrapy框架过程中遇到的各种问题及解决办法<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用环境：Win10 1803、Python 3.6.3</p><p>利用pip命令可以直接安装<code>Scrapy</code>，但是会出现一些安装包装不上而报错，比如Twisted。可以先去这个<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">Pyhton Extension Packages</a>下载<code>Twisted</code>到本地，然后单独安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install twisted</span><br></pre></td></tr></table></figure><p>（注意要下载<code>Twisted‑18.9.0‑cp36‑cp36m‑win_amd64.whl</code>不要下载错了，是cp36。否则安装的时候会提示<code>is not a supported wheel on this platform</code>）</p><h2 id="Scrapy输出文件编码为’utf-8’"><a href="#Scrapy输出文件编码为’utf-8’" class="headerlink" title="Scrapy输出文件编码为’utf-8’"></a>Scrapy输出文件编码为’utf-8’</h2><p>在编写爬虫中文内容输出到<code>*.json</code>文件后发现中文是<code>Unicode编码</code>，尝试了各种方法测试都不成功，后来找到一种方法终于成功了，把Scrapy项目文件夹中的<code>Setting.py</code>增加一行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEED_EXPORT_ENCODING = <span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure><h2 id="Scrapy导出csv文件乱码"><a href="#Scrapy导出csv文件乱码" class="headerlink" title="Scrapy导出csv文件乱码"></a>Scrapy导出csv文件乱码</h2><p>使用<code>Vscode的通过编码重新保存</code>，将文件的编码格式改为<code>UTF-8 with BOM</code>，再重新用Excel打开csv就正常了。</p><ul><li>参考：<a href="https://blog.csdn.net/u011361138/article/details/79912895" target="_blank" rel="noopener">https://blog.csdn.net/u011361138/article/details/79912895</a></li></ul><h2 id="Scrapy异常：http-status-code-is-not-handled-or-allowed"><a href="#Scrapy异常：http-status-code-is-not-handled-or-allowed" class="headerlink" title="Scrapy异常：http status code is not handled or allowed"></a>Scrapy异常：http status code is not handled or allowed</h2><p>原因是http状态码没有被识别，需要在settings.py中添加这个状态码信息，同样在<code>Setting.py</code>添加一行（如果是404错误就改为404，如果是400错误，就改成400：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTPERROR_ALLOWED_CODES = [状态码]</span><br><span class="line">HTTPERROR_ALLOWED_CODES = [404]</span><br><span class="line">HTTPERROR_ALLOWED_CODES = [400]</span><br></pre></td></tr></table></figure><p>另一种方法是在<code>Spider</code>函数中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handle_httpstatus_list = [404]</span><br><span class="line">handle_httpstatus_list = [400]</span><br></pre></td></tr></table></figure><hr><p><img src="https://blog-1258616090.cos.ap-chengdu.myqcloud.com/20190208160126.png" alt=""></p><p>如果还是出现<code>400错误</code>问题，我观察到后面的Debug信息是：*/robots.txt。</p><blockquote><p><strong>robots.txt（爬虫协议)</strong>是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。——<a href="https://zh.wikipedia.org/wiki/Robots.txt" target="_blank" rel="noopener">wiki</a></p><ul><li>知乎robots地址：<a href="https://www.zhihu.com/robots.txt" target="_blank" rel="noopener">https://www.zhihu.com/robots.txt</a></li><li>淘宝robots地址：<a href="https://www.taobao.com/robots.txt" target="_blank" rel="noopener">https://www.taobao.com/robots.txt</a></li></ul></blockquote><p>总结来说这个爬虫协议允许爬虫机器爬取的范围，不过这个协议属于君子协议，Scrapy默认是遵循<code>robot协议</code>，需要在<code>Setting.py</code>中改变<code>ROBOTSTXT_OBEY</code>的值为<code>False</code>。</p><p>在做了上面的设置之后还是400错误，可以给Reaqueset请求添加一个<code>Headers</code>头部，可以让爬虫伪装成浏览器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">    url = <span class="string">'http://www.hnfnu.edu.cn/index/xyxw/342.htm'</span>  <span class="comment"># 这样就不要设置Start_urls变量了</span></span><br><span class="line">    <span class="keyword">yield</span> Request(url, headers=self.headers)</span><br></pre></td></tr></table></figure><p>不过在我今天在爬去知乎专栏的文章（Ajax加载），调试了很久也只能抓取到第一次加载的列表内容，检查了后面的<code>yiled Requeset(url, callback=self.parse)</code> 设置没有问题，然后我把<code>Headers信息</code>添加在<code>Setting.py</code>中问题就解决了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>未完待补充……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录一下，自己再安装鹤使用Scrapy框架过程中遇到的各种问题及解决办法&lt;br&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://yslemmo.github.io/categories/Scrapy/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="Debug" scheme="http://yslemmo.github.io/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yslemmo.github.io/2019/02/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yslemmo.github.io/2019/02/03/单例模式/</id>
    <published>2019-02-02T17:51:57.900Z</published>
    <updated>2018-03-20T13:11:52.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、单例模式介绍"><a href="#一、单例模式介绍" class="headerlink" title="一、单例模式介绍"></a>一、单例模式介绍</h3><p>“单例”字面意思上理解为——一个类只有一个实例，所以单例模式也就是<strong>保证一个类只有一个实例的一种实现方法罢了</strong> [test][1]</p><a id="more"></a><p>(设计模式其实就是帮助我们解决实际开发过程中的方法, 该方法是为了降低对象之间的耦合度,然而解决方法有很多种,所以前人就总结了一些常用的解决方法为书籍,从而把这本书就称为设计模式)</p><blockquote><p>官方定义：<strong>确保一个类只有一个实例,并提供一个全局访问点。</strong></p></blockquote><h3 id="二、为什么会有单例模式"><a href="#二、为什么会有单例模式" class="headerlink" title="二、为什么会有单例模式"></a>二、为什么会有单例模式</h3><p>为什么要有单例模式的？它在什么情况下使用的？从单例模式的定义中我们可以看出——单例模式的使用自然是当我们的系统中某个对象只需要一个实例的情况，</p><blockquote><p>例如:操作系统中只能有一个任务管理器,操作文件时,同一时间内只允许一个实例对其操作等,既然现实生活中有这样的应用场景,自然在软件设计领域必须有这样的解决方案了(因为软件设计也是现实生活中的抽象)，所以也就有了单例模式了。</p></blockquote><h3 id="三、Mono子类C-脚本单例"><a href="#三、Mono子类C-脚本单例" class="headerlink" title="三、Mono子类C#脚本单例"></a>三、Mono子类C#脚本单例</h3><ol><li>定义一个当前类的公开，静态，当前类类型返回值的一个字段；</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Master Instance; <span class="comment">//一个名为Master的类</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在Awake 事件方法中完成该字段的赋值。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Instance = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在其他类中使用单例</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Master.Instance.字段/方法;</span><br></pre></td></tr></table></figure><h3 id="四、非Mono-子类C-脚本单例"><a href="#四、非Mono-子类C-脚本单例" class="headerlink" title="四、非Mono 子类C#脚本单例"></a>四、非Mono 子类C#脚本单例</h3><ol><li>定义一个当前类的私有，静态，当前类类型返回值的字段；</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassNmae instance;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个无参私有构造方法</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassNmae</span>(<span class="params"></span>)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建一个公开，静态，用于封装字段的属性；在该属性内实现单例，（或者可以创建<code>公开的、静态的方法</code>）</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClassNmae Instance</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">get</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               instance = <span class="keyword">new</span> ClassNmae();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> instance;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在其他类中使用单例</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、单例模式介绍&quot;&gt;&lt;a href=&quot;#一、单例模式介绍&quot; class=&quot;headerlink&quot; title=&quot;一、单例模式介绍&quot;&gt;&lt;/a&gt;一、单例模式介绍&lt;/h3&gt;&lt;p&gt;“单例”字面意思上理解为——一个类只有一个实例，所以单例模式也就是&lt;strong&gt;保证一个类只有一个实例的一种实现方法罢了&lt;/strong&gt; [test][1]&lt;/p&gt;
    
    </summary>
    
    
      <category term="Csharp" scheme="http://yslemmo.github.io/tags/Csharp/"/>
    
  </entry>
  
  <entry>
    <title>制作UI的流程总结</title>
    <link href="http://yslemmo.github.io/2019/02/03/%E5%88%B6%E4%BD%9CUI%E7%9A%84%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yslemmo.github.io/2019/02/03/制作UI的流程总结/</id>
    <published>2019-02-02T17:51:57.895Z</published>
    <updated>2018-03-20T13:09:49.603Z</updated>
    
    <content type="html"><![CDATA[<h4 id="UI制作流程总结"><a href="#UI制作流程总结" class="headerlink" title="UI制作流程总结"></a>UI制作流程总结</h4><ol><li>先制作基本的UI界面</li><li>然后根据需要重复显示的元素拖拽为预制体；</li><li>加载本地或服务器端的Json文件数据，循环实例化UI。</li></ol><p><strong>UI 界面制作完毕后，一定是和数据源绑定的。UI 是用于显示数据的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;UI制作流程总结&quot;&gt;&lt;a href=&quot;#UI制作流程总结&quot; class=&quot;headerlink&quot; title=&quot;UI制作流程总结&quot;&gt;&lt;/a&gt;UI制作流程总结&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;先制作基本的UI界面&lt;/li&gt;
&lt;li&gt;然后根据需要重复显示的元素拖拽为预制体；
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NexT主题如何显示摘要</title>
    <link href="http://yslemmo.github.io/2019/02/03/NexT%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E7%9F%A5%E6%91%98%E8%A6%81/"/>
    <id>http://yslemmo.github.io/2019/02/03/NexT主题如何显示知摘要/</id>
    <published>2019-02-02T17:51:57.823Z</published>
    <updated>2019-02-06T16:12:25.418Z</updated>
    
    <content type="html"><![CDATA[<p>刚创建好的网站，把几篇以前写的MarkDown文件放在<code>_Post</code>文件夹中，但是打开网站一下，发现在页面中每篇文章都全部显示了，翻看起来不方便。如何解决这个问题.</p><a id="more"></a><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/20180320204737.png" alt=""></p><h2 id="官方提供了三个解决办法"><a href="#官方提供了三个解决办法" class="headerlink" title="官方提供了三个解决办法!"></a>官方提供了三个<a href="http://theme-next.iissnan.com/faqs.html#%E9%A6%96%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E5%BD%95" target="_blank" rel="noopener">解决办法</a>!</h2><ol><li>在文章中使用手动截断的方法，截断的语句是<code>&lt;!-- more --&gt;</code></li><li>在文章的 front-matter 中添加 description，并提供文章摘录</li><li>自动形成摘要，在主题配置文件中添加，默认截取的长度为 150字符，可以根据需要自行设定：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="文章模版"><a href="#文章模版" class="headerlink" title="文章模版"></a>文章模版</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">git的基本使用</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-01</span><span class="bullet">-24</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cate1</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">tag1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&lt;img</span> <span class="string">src="/img/git.png"</span> <span class="string">width</span> <span class="string">=</span> <span class="string">"900"</span> <span class="string">height</span> <span class="string">=</span> <span class="string">"600"</span> <span class="string">alt="git"</span> <span class="string">align=center</span> <span class="string">/&gt;</span></span><br><span class="line"><span class="string">摘要内容......</span></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">more</span> <span class="bullet">--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚创建好的网站，把几篇以前写的MarkDown文件放在&lt;code&gt;_Post&lt;/code&gt;文件夹中，但是打开网站一下，发现在页面中每篇文章都全部显示了，翻看起来不方便。如何解决这个问题.&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yslemmo.github.io/categories/Hexo/"/>
    
    
      <category term="技巧" scheme="http://yslemmo.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hexo概念理解</title>
    <link href="http://yslemmo.github.io/2019/02/03/Hexo%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://yslemmo.github.io/2019/02/03/Hexo概念理解/</id>
    <published>2019-02-02T17:51:57.817Z</published>
    <updated>2019-02-06T16:22:48.691Z</updated>
    
    <content type="html"><![CDATA[<p>刚接触到Hexo，已经被Hexo的简洁性和部署网站的便捷性所惊叹到了，但是Hexo的一些概念在大脑中还不是很清晰，在网上也没有找到一篇特别好的文章来介绍总结。因此本文作为个人使用Hexo认识的比较重要概念的的一些总结。</p><a id="more"></a><h2 id="创建好Hexo后的路径树"><a href="#创建好Hexo后的路径树" class="headerlink" title="创建好Hexo后的路径树"></a>创建好Hexo后的路径树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">|── public</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">|   ├── categories</span><br><span class="line">|   └── tags</span><br><span class="line">└── themes</span><br><span class="line">    |_ next(主题的名字)</span><br><span class="line">        |_config.yml</span><br></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="config.yml"></a>config.yml</h3><p>配置文件，采用yml的格式</p><ul><li>root目录下的<code>_config.yml</code>:<strong>站点配置文件</strong></li><li>应用的某个主题（如NexT）下的<code>_config.yml</code>:<strong>主题配置文件</strong></li></ul><h3 id="public文件夹"><a href="#public文件夹" class="headerlink" title="public文件夹"></a>public文件夹</h3><p>这个文件夹存放的是当我们使用命令<code>hexo g</code>命令后，自动生成的一些<code>html文件</code>, 这些文件都是要上传到远程服务器中。</p><h3 id="source文件夹"><a href="#source文件夹" class="headerlink" title="source文件夹"></a>source文件夹</h3><ul><li>_posts：保存markdown的源文件</li><li>_categories：使用命令<code>hexo new page categories</code>创建<code>分类</code>分页自动生成的文件夹；</li><li>_tags：同上，这里创建<code>标签</code>分页；</li></ul><hr><ul><li><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">如何创建分页</a>!</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚接触到Hexo，已经被Hexo的简洁性和部署网站的便捷性所惊叹到了，但是Hexo的一些概念在大脑中还不是很清晰，在网上也没有找到一篇特别好的文章来介绍总结。因此本文作为个人使用Hexo认识的比较重要概念的的一些总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Computer skills" scheme="http://yslemmo.github.io/categories/Computer-skills/"/>
    
    
      <category term="Hexo" scheme="http://yslemmo.github.io/tags/Hexo/"/>
    
      <category term="技巧" scheme="http://yslemmo.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hexo本地建站</title>
    <link href="http://yslemmo.github.io/2019/02/03/Hexo%E6%9C%AC%E5%9C%B0%E5%BB%BA%E7%AB%99/"/>
    <id>http://yslemmo.github.io/2019/02/03/Hexo本地建站/</id>
    <published>2019-02-02T17:51:57.811Z</published>
    <updated>2019-02-06T16:23:18.743Z</updated>
    
    <content type="html"><![CDATA[<p>整理总结一下如何在本地安装Hexo，因为本人的电脑是Windows系统，所以以下都是在Windows环境下进行的。</p><a id="more"></a><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><ul><li>GIt</li><li>Node.Js</li></ul><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h3><ol><li>下载Git：<a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a></li><li>安装Git</li></ol><h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2. 安装Node.js"></a>2. 安装Node.js</h3><ol><li>直接下载Node.Js的<a href="https://nodejs.org/en/" target="_blank" rel="noopener">安装包</a></li><li>安装并Add 到Path（自动选择了）</li></ol><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ol><li><h5 id="打开Node-js-Command-Prompt"><a href="#打开Node-js-Command-Prompt" class="headerlink" title="打开Node.js Command Prompt"></a>打开<code>Node.js Command Prompt</code></h5></li><li><h5 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> d:/hexo <span class="comment">#要安装的Hexo的路径</span></span><br></pre></td></tr></table></figure><p>安装hexo的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>在Blog的目录下初始化 hexo博客，名字可以是任意取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog <span class="comment">#安装landscape的速度的比较慢</span></span><br></pre></td></tr></table></figure><p>进入博客根目录，并且安装相关插件依赖等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>运行hexo的几个名字，查看效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">#生成静态文件，汇总当前目录下生成一个新的叫做public的文件夹</span></span><br><span class="line">hexo s <span class="comment">#启动本地的Web服务，启动完成后，可以在地址栏输入「http://127.0.0.1:4000/」查看</span></span><br></pre></td></tr></table></figure><p>运行之后的效果</p></li><li><p>hexo的<a href="https://hexo.bootcss.com/docs/index.html" target="_blank" rel="noopener">官方文档</a></p></li></ol><h2 id="如何安装主题"><a href="#如何安装主题" class="headerlink" title="如何安装主题"></a>如何安装主题</h2><p>Hexo中很有很多不同类型的主题：</p><p><strong>一些参考</strong></p><ul><li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT.Mist</a>：<a href="http://wdxtub.com/" target="_blank" rel="noopener">示例网站</a></li><li><ul><li><a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">Next官方使用文档</a>!</li></ul></li><li><a href="https://link.jianshu.com/?t=https://github.com/cofess/hexo-theme-pure" target="_blank" rel="noopener">pure</a>：<a href="http://blog.cofess.com/" target="_blank" rel="noopener">示例网站</a></li></ul><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><ul><li><code>themes/next</code>为下载主题的路径</li></ul><h3 id="启动主题"><a href="#启动主题" class="headerlink" title="启动主题"></a>启动主题</h3><p>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为next(网站应该会启动themes下的next主题)</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git g <span class="comment">#生成</span></span><br><span class="line">git s <span class="comment">#启动本地服务器</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理总结一下如何在本地安装Hexo，因为本人的电脑是Windows系统，所以以下都是在Windows环境下进行的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yslemmo.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="http://yslemmo.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo插件记录</title>
    <link href="http://yslemmo.github.io/2019/02/03/Hexo%E6%8F%92%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    <id>http://yslemmo.github.io/2019/02/03/Hexo插件记录/</id>
    <published>2019-02-02T17:51:57.805Z</published>
    <updated>2019-02-07T08:15:07.236Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些常用的Hexo插件</p><a id="more"></a><ul><li>NexT官方集成插件介绍：<a href="https://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">https://theme-next.iissnan.com/third-party-services.html</a></li></ul><hr><h2 id="本地搜索：Local-Search"><a href="#本地搜索：Local-Search" class="headerlink" title="本地搜索：Local Search"></a>本地搜索：Local Search</h2><ol><li><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>编辑 <code>站点配置文件</code>，新增以下内容到任意位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure></li><li><p>编辑 <code>主题配置文件</code>，启用本地搜索功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>采坑注意：</strong>：在Next的主题配置文件中已经存在了<code>local_search</code>的语句了，不要重复添加，否则会报错。只需要搜索到相关位置，将<code>false</code>更改为<code>true</code>即可。搜索效果如下：<br><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-3-20/6928171.jpg" alt=""></p><h2 id="图片预览插件：FancyBox"><a href="#图片预览插件：FancyBox" class="headerlink" title="图片预览插件：FancyBox"></a>图片预览插件：FancyBox</h2><p>Hexo-Next主题中已经有图片预览的功能了，如果要使用，在主题的配置中文件中把<code>FancyBox:False</code>改为<code>true</code>。但是不知道什么原因，我开启之后无法打开网站。考虑到可能是没有下载FancyBox这个插件的原因。FancyBox有两个版本，<code>FancyBox2</code>和<code>FancyBox3</code>，一般来说v2版本就够用了。</p><p><img src="https://blog-1258616090.cos.ap-chengdu.myqcloud.com/20190207160448.png" alt=""></p><p>下面是安装插件的步骤（参考<a href="https://github.com/theme-next/theme-next-fancybox" target="_blank" rel="noopener">fancybox的github地址</a>））</p><ol><li><p>转到Next主题的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next</span><br></pre></td></tr></table></figure></li><li><p>安装FancyBox到<code>Source/lib</code>路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-fancybox <span class="built_in">source</span>/lib/fancybox</span><br></pre></td></tr></table></figure></li><li><p>在NexT的<code>_config.yml</code>中开启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/next/<span class="built_in">source</span>/lib/fancybox</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure></li></ol><hr><ul><li><a href="http://blog.cofess.com/2017/08/16/comon-plug-in-and-usage-of-hexo-blog.html" target="_blank" rel="noopener">Hexo博客常用插件及用法</a>!</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些常用的Hexo插件&lt;/p&gt;
    
    </summary>
    
      <category term="默认" scheme="http://yslemmo.github.io/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
      <category term="hexo" scheme="http://yslemmo.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>XLua_HotFix热补丁修复</title>
    <link href="http://yslemmo.github.io/2018/05/10/XLua-HotFix/"/>
    <id>http://yslemmo.github.io/2018/05/10/XLua-HotFix/</id>
    <published>2018-05-10T12:51:14.000Z</published>
    <updated>2019-02-06T16:12:25.421Z</updated>
    
    <content type="html"><![CDATA[<p>使用xlua热补丁修复</p><a id="more"></a><p>在使用Ulua方法进行热更新的时候，在项目的开发阶段就必要用独立的Lua脚本实现，这样才能使用Ulua来进行热更新，但是如果一个项目完成之后发现需要进行热更新，这个时候用ULua就非常不方便了。但是XLua可以解决这个问题，解决方案就是<strong>“HotFix”热补丁</strong>。（对项目进行修补）实现方式：</p><blockquote><p>对要进行“修补”的C#类，在该类的头部[Hotfix]标签来标记，对于已经使用了<code>[hotfix]</code>标记了的类，可以通过“Lua”代码修改“类中的方法”。</p></blockquote><h1 id="使用HotFix进行热修复"><a href="#使用HotFix进行热修复" class="headerlink" title="使用HotFix进行热修复"></a>使用HotFix进行热修复</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="添加宏信息"><a href="#添加宏信息" class="headerlink" title="添加宏信息"></a>添加宏信息</h3><blockquote><p>File–&gt; Build Settings… –&gt; Player Settings… –&gt; Configuration：Scripting Define Symbols：HOTFIX_ENABLE；（对于每一个平台都需要添加这条宏信息！）</p></blockquote><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-5-10/29613175.jpg" alt=""></p><h3 id="执行菜单生成命令"><a href="#执行菜单生成命令" class="headerlink" title="执行菜单生成命令"></a>执行菜单生成命令</h3><p><strong>XLua-&gt;Generate Code</strong>，该命令执行完毕后会生成一堆Wrap 文件，存放到XLua/Gen 文件夹下。</p><h3 id="执行菜单注入命令"><a href="#执行菜单注入命令" class="headerlink" title="执行菜单注入命令"></a>执行菜单注入命令</h3><p><strong>XLua-&gt;Hotfix Inject In Editor</strong>，成功之后，会在控制台输出：“hotfix inject finish!”或者“had injected!”。</p><ul><li>如果出现红色警告提示“please install the Tools”，就需要把Tools 文件夹拷贝到项目中，和Assets 文件夹同级别位置。</li><li>只要修改过C#中的代码，就需要重新执行注入命令！（否则会报错）</li></ul><h1 id="HotFix热修复案例"><a href="#HotFix热修复案例" class="headerlink" title="HotFix热修复案例"></a>HotFix热修复案例</h1><h2 id="Hotfix语法"><a href="#Hotfix语法" class="headerlink" title="Hotfix语法"></a>Hotfix语法</h2><ul><li>引入命名空间：<code>using Xlua;</code></li><li>对要进行热修复的C#类用【hotfix】标记</li><li>编写hotfix命令：<code>xlua.hotfix(CS.类名, &#39;方法名&#39;, lua 方法)</code>（对于CS.类中的某个方法使用lua方法修复）</li><li>创建XLua虚拟机对象（Lua解析器），使用Dostring方法执行。</li></ul><h2 id="修复案例"><a href="#修复案例" class="headerlink" title="修复案例"></a>修复案例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Hotfix</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotFixDemo</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LuaEnv luaEnv;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> hotfixStrOne = <span class="string">@"</span></span><br><span class="line"><span class="string">        xlua.hotfix(CS.HotFixDemo, 'Hello', function()</span></span><br><span class="line"><span class="string">            print('Lua Hello~~')    </span></span><br><span class="line"><span class="string">        end)</span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> hotfixStrTwo = <span class="string">@"</span></span><br><span class="line"><span class="string">        xlua.hotfix(CS.HotFixDemo, 'Add', function(self, a, b)</span></span><br><span class="line"><span class="string">            print('Lua中的乘法:' .. a*b)</span></span><br><span class="line"><span class="string">        end)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        luaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.A))&#123;</span><br><span class="line">            Hello();</span><br><span class="line">            Add(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))&#123;</span><br><span class="line">            luaEnv.DoString(hotfixStrOne);</span><br><span class="line">            luaEnv.DoString(hotfixStrTwo);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"C# Hello~~"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"C#中的加法："</span> + (a + b));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参方法修复时，需要传递当前脚本对象this，在lua 中用self 代替。</li><li>要修复无参的方法，但是那个方法内使用到了该类中的字段，如果想要在Lua代码中方法到，有两种方法：<ol><li>C#类中的字段公开（使用Public修饰），在lua代码中通过<code>self.字段名</code>的方式来方法（破坏了C#语言的“封装性”）</li><li>在lua 语言中，使用代码获取C#类中private 成员的访问权<code>xlua.private_accessible(CS.类名)</code>，这样就可以在Lua 脚本中访问到C#类当中的私有成员，同时不会破坏C#原有的封装性和逻辑关系。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用xlua热补丁修复&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://yslemmo.github.io/categories/Unity/"/>
    
    
      <category term="热更新" scheme="http://yslemmo.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="xLua" scheme="http://yslemmo.github.io/tags/xLua/"/>
    
      <category term="Untiy" scheme="http://yslemmo.github.io/tags/Untiy/"/>
    
  </entry>
  
  <entry>
    <title>SimpleFrameWork框架简单介绍</title>
    <link href="http://yslemmo.github.io/2018/05/07/SimpleFrameWork-Introduction/"/>
    <id>http://yslemmo.github.io/2018/05/07/SimpleFrameWork-Introduction/</id>
    <published>2018-05-07T07:18:19.000Z</published>
    <updated>2019-02-06T16:12:25.420Z</updated>
    
    <content type="html"><![CDATA[<p>SimpleFramework的框架介绍<br><a id="more"></a></p><h1 id="SimpleFramework-框架"><a href="#SimpleFramework-框架" class="headerlink" title="SimpleFramework 框架"></a>SimpleFramework 框架</h1><p>SimpleFramework 框架是ULua的集成开发环境</p><ul><li>SimpleFramework     框架官网地址： <a href="http://www.ulua.org/index.html" target="_blank" rel="noopener">http://www.ulua.org/index.html</a></li><li>SimpleFramework 分为两个版本：NGUI 版和UGUI 版，区别是NGUI 版本的框架资源中含有NGUI 这个插件。</li></ul><h1 id="SimpleFramework-和ULua和Lua的关系"><a href="#SimpleFramework-和ULua和Lua的关系" class="headerlink" title="SimpleFramework 和ULua和Lua的关系"></a>SimpleFramework 和ULua和Lua的关系</h1><p>ULua是对原生Lua 环境进行了一次“包装”，用于满足Unity 环境下的热更新需求。为了更方便的使用，于是又对ULua进行“二次包装”，包装成了一个框架：SimpleFramework，比如它们创建Lua的解析器对象都不相同。</p><ul><li>Lua：<code>Lua lua = New Lua();</code></li><li>Ulua：<code>LuaState Lua = new LuaState();</code></li><li>SimpleFramework:<code>LuaScriptMgr lua = new LuaScriptMgr();</code></li></ul><p>它们的关系是：<code>SimpleFramework</code> &gt; <code>ULua</code> &gt; <code>Lua</code></p><h1 id="SimpleFramework框架资源结构"><a href="#SimpleFramework框架资源结构" class="headerlink" title="SimpleFramework框架资源结构"></a>SimpleFramework框架资源结构</h1><ul><li><code>Examples</code>：SimpleFramework 热更新案例；</li><li><code>Lua</code>：SimpleFramework 框架自带的Lua 源码文件；（自己写的Lua脚本放在这个路径）</li><li><code>NGUI</code>：NGUI3.8.2，当你需用更高版本的NGUI 时，替换即可，不需要碰；</li><li><code>Plugins</code>：uLua 运行所依赖的底层库文件，不需要碰；</li><li><code>Scripts</code>：SimpleFramework 自带的C#脚本文件；</li><li><code>uLua</code>：uLua 全部代码。</li></ul><p>和Ulua紧密相关的是：<code>Plugins</code>、<code>uLua</code>。和SimpleFramework相关的是：<code>Examples</code>、<code>Lua</code>、<code>Scripts</code></p><h1 id="使用框架"><a href="#使用框架" class="headerlink" title="使用框架"></a>使用框架</h1><h2 id="框架自带的编辑器命令"><a href="#框架自带的编辑器命令" class="headerlink" title="框架自带的编辑器命令"></a>框架自带的编辑器命令</h2><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-5-6/71191708.jpg" alt=""></p><h3 id="Lua菜单：uLua-环境相关处理命令-必备操作"><a href="#Lua菜单：uLua-环境相关处理命令-必备操作" class="headerlink" title="Lua菜单：uLua 环境相关处理命令(必备操作)"></a>Lua菜单：uLua 环境相关处理命令(必备操作)</h3><ul><li><p>Gen Lua Wrap Files：生成LuaWrap文件</p><p>该命令用于生成“Lua 包装文件”，存放在<strong>uLua\Source\LuaWrap</strong> 目录下。该文件夹下全部是C#脚本，这些脚本文件的名称特点是：脚本名+ Wrap；该文件夹下的脚本对Unity 内常用组件脚本的二次包装，、</p><p>Lua 环境运行后，会把这些Wrap 文件加载到Lua 运行环境(Lua 虚拟机)中，最终的效果就是：Lua 调用Wrap 文件，Wrap 文件调用C#，来实现Lua 调用C#。</p></li><li><p>Clear Lua….. Wrap Files：清除LuaWrap文件，也可以自己手动删除。</p></li></ul><h3 id="Game菜单：Build-xxxx-生成不同平台的AssetBundle-资源-必备操作"><a href="#Game菜单：Build-xxxx-生成不同平台的AssetBundle-资源-必备操作" class="headerlink" title="Game菜单：Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]"></a>Game菜单：Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]</h3><p>Game–&gt;Build Windows Resource 生成Windows 平台下的AB 文件。生成后的AB 会存放到StreamingAssets 文件夹下。在生成的过程中同时还会把Lua 文件夹下的所有脚本拷贝到该目录，存放到lua 文件夹下。</p><p>在<code>\Assets\uLua\Editor\Packager.cs</code>脚本中的<code>HandleLuaFile方法</code>就是将<code>/Lua/</code>文件复制到<code>/StreamingAssets/</code>文件夹中（这是本地Server设置的资源的地址，模拟服务器的资源地址）</p><h1 id="Lua-文件夹结构分析"><a href="#Lua-文件夹结构分析" class="headerlink" title="Lua 文件夹结构分析"></a>Lua 文件夹结构分析</h1><ul><li>3rd：第三方的Lua 脚本插件；</li><li>Common：公共Lua 文件目录；</li><li>Controller：控制器目录；</li><li>Logic：管理器目录；</li><li>System：cstolua 的系统目录；</li><li>View：视图层目录。</li></ul><h1 id="ULua-文件夹结构"><a href="#ULua-文件夹结构" class="headerlink" title="ULua 文件夹结构"></a>ULua 文件夹结构</h1><p>SimpleFramework 框架项目的核心是uLua，在Unity 环境下使用uLua可以实现Lua 脚本与Unity 内C#脚本的交互，通过Lua 脚本来操作Unity3D内的各种游戏组件。</p><ul><li>Core：uLua 核心；</li><li>Docs：uLua 文档，其实就是LuaInterface 的PDF 使用文档；</li><li>Editor：uLua 编辑器扩展；<br>[备注：项目内所有的Editor 文件夹都是编辑器扩展文件夹，并不局限于根目录]</li><li>Examples：uLua 自带演示案例；</li><li>Source：cstolua 核心目录。</li></ul><h1 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h1><p>参考：擅码网Lua热更新文档资料</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SimpleFramework的框架介绍&lt;br&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://yslemmo.github.io/categories/Unity/"/>
    
      <category term="Lua" scheme="http://yslemmo.github.io/categories/Unity/Lua/"/>
    
    
      <category term="Unity" scheme="http://yslemmo.github.io/tags/Unity/"/>
    
      <category term="ULua" scheme="http://yslemmo.github.io/tags/ULua/"/>
    
      <category term="SimpleFramework" scheme="http://yslemmo.github.io/tags/SimpleFramework/"/>
    
  </entry>
  
  <entry>
    <title>Ulua-And-Charp-Communicate</title>
    <link href="http://yslemmo.github.io/2018/05/07/Ulua-And-C-Communicate/"/>
    <id>http://yslemmo.github.io/2018/05/07/Ulua-And-C-Communicate/</id>
    <published>2018-05-07T07:09:54.000Z</published>
    <updated>2018-05-07T12:20:28.569Z</updated>
    
    <content type="html"><![CDATA[<p>在SimpleFramwork框架下，Ulua与C#的交互！</p><a id="more"></a><h1 id="uLua环境下与C-交互（基本操作）"><a href="#uLua环境下与C-交互（基本操作）" class="headerlink" title="uLua环境下与C#交互（基本操作）"></a>uLua环境下与C#交互（基本操作）</h1><p>在C#与Lua进行交互需要两个DLL文件来实现分别是<code>Luainterface.dll</code>（C#脚本使用Lua）、<code>luanet.dll</code>(Lua脚本调用C#)。因此需要事先把那两个DLL文件拷贝到项目路径中去，再引用。</p><p>在uLua 环境下本质也是通过LuaInterface 来实现Lua 与C#语言交互的。但是uLua 对LuaInterface 进行了二次的封装，不需需要自己手动拷贝这个DLL文件，但是的使用的使用还是要引入命名空间：<code>using LuaInterface;</code></p><h2 id="Lua-代码与Unity-内的类的交互-反射方式-原生方式"><a href="#Lua-代码与Unity-内的类的交互-反射方式-原生方式" class="headerlink" title="Lua 代码与Unity 内的类的交互[反射方式/ 原生方式]"></a>Lua 代码与Unity 内的类的交互[反射方式/ 原生方式]</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个字符串变量保存Lua代码（调用C#的类和方法来创建了一个游戏物体，并给它添加了一个“BoxCollider”组件）    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> str1 = <span class="string">@"</span></span><br><span class="line"><span class="string">    luanet.load_assembly('UnityEngine')</span></span><br><span class="line"><span class="string">    GameObject = luanet.import_type('UnityEngine.GameObject')</span></span><br><span class="line"><span class="string">    BoxCollider = luanet.import_type('UnityEngine.BoxCollider')</span></span><br><span class="line"><span class="string">    local player = GameObject('Lemmo')</span></span><br><span class="line"><span class="string">    player:AddComponent(luanet.ctype(BoxCollider))</span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Lua解析器对象，并执行上面定义的Lua脚本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        LuaState lua = <span class="keyword">new</span> LuaState();</span><br><span class="line">        lua.DoString(str1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>luanet 已经被封装到了LuaInterface 命名空间内，所以我们可以在Lua代码中直接使用luanet 这个对象；</li><li>在Lua 环境内操作C#中的类创建对象，不要写new 关键字！</li><li>在Lua 环境内操作C#中的类创建对象，访问对象中的方法使用分号（:）；</li><li><p>这种“反射方式”在项目开发中并不常用，但是也有用无之地，真正大量使用的是下方的Wrap 方式。</p></li><li><p>同样需要在C#代码中引入LuaInterface；</p></li><li>原生的Lua 解析器对象“Lua”被二次封装成了“LuaState”；</li><li>LuaState 类存在的位置是：uLua\Core\Lua.cs。</li></ul><h2 id="Lua-代码与Unity-内的类的交互-Wrap-方式"><a href="#Lua-代码与Unity-内的类的交互-Wrap-方式" class="headerlink" title="Lua 代码与Unity 内的类的交互[Wrap 方式]"></a>Lua 代码与Unity 内的类的交互[Wrap 方式]</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 和Str1的功能类似，只不过str2使用了Wrap的方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> str2 = <span class="string">@"</span></span><br><span class="line"><span class="string">    luanet.load_assembly('UnityEngine')</span></span><br><span class="line"><span class="string">    GameObject = UnityEngine.GameObject</span></span><br><span class="line"><span class="string">    BoxCollider = UnityEngine.BoxCollider</span></span><br><span class="line"><span class="string">    local player = GameObject('WrapLemmo')</span></span><br><span class="line"><span class="string">    player:AddComponent(BoxCollider.GetClassType())</span></span><br><span class="line"><span class="string">        "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        LuaScriptMgr lua = <span class="keyword">new</span> LuaScriptMgr();</span><br><span class="line">        lua.Start();</span><br><span class="line">        lua.DoString(str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p>这种是在uLua 开发过程中最常用的方式，95%+情况都是使用这种方式；</p></li><li><p>Wrap 方式实现Lua 调用C#，依赖的是之前生成的LuaWrap 文件；</p><p>[也就是我们通过菜单自动生成到<strong>uLua\Source\LuaWrap</strong> 下的脚本文件]</p></li><li><p>当使用Wrap 方式时，运行Lua 代码需要使用LuaScriptMgr；</p></li><li><p>需要把AppConst.cs 脚本中的的DebugMode 修改为true。</p></li></ul><h2 id="包装新的Wrap-脚本"><a href="#包装新的Wrap-脚本" class="headerlink" title="包装新的Wrap 脚本"></a>包装新的Wrap 脚本</h2><p>当我们用Lua 的Wrap 方式访问Unity 中的组件脚本，或者自己写的脚本的使用，如果这些脚本没有自动生成“xxxxWrap”,项目运行后，就会报错。比如在用Wrap的方式给Player对象通过Lua添加<code>Animator</code>组件的时候，就会报错.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animator = UnityEngine.Animator </span><br><span class="line">player:AddComponent(Animator.GetClassType())</span><br></pre></td></tr></table></figure><p>解决办法：往框架内添加需要处理的新的类。</p><ol><li>找到uLua\Editor\WrapFile.cs 打开该脚本，使用该格式进行添加：_GT(typeof(类名)) ；</li><li>Lua–&gt;Clear LuaBinder File + Wrap File 清空原有的Wrap 文件；</li><li>Lua–&gt;Gen Lua Wrap Files 重新生成Wrap 文件；</li></ol><h1 id="关于Lua使用“-”和“-”来调用属性和方法"><a href="#关于Lua使用“-”和“-”来调用属性和方法" class="headerlink" title="关于Lua使用“.”和“:”来调用属性和方法"></a>关于Lua使用“.”和“:”来调用属性和方法</h1><p>在Lua语言中，直接调用操作C#中的对象的方法和属性直接使用“.”来调用，如果是在Lua代码中实例化出来的对象，再调用这个对象的方法则需要用“:”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SimpleFramwork框架下，Ulua与C#的交互！&lt;/p&gt;
    
    </summary>
    
      <category term="Lua - Ulua" scheme="http://yslemmo.github.io/categories/Lua-Ulua/"/>
    
    
      <category term="热更新" scheme="http://yslemmo.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="Unity" scheme="http://yslemmo.github.io/tags/Unity/"/>
    
      <category term="Lua" scheme="http://yslemmo.github.io/tags/Lua/"/>
    
      <category term="SimpleFramwork" scheme="http://yslemmo.github.io/tags/SimpleFramwork/"/>
    
  </entry>
  
  <entry>
    <title>Lua与Charp进行交互</title>
    <link href="http://yslemmo.github.io/2018/04/24/C-use-Lua/"/>
    <id>http://yslemmo.github.io/2018/04/24/C-use-Lua/</id>
    <published>2018-04-24T11:33:39.000Z</published>
    <updated>2019-02-06T16:12:25.418Z</updated>
    
    <content type="html"><![CDATA[<p>Lua与C#的交互<br><a id="more"></a></p><h1 id="Lua与C-进行交互"><a href="#Lua与C-进行交互" class="headerlink" title="Lua与C#进行交互"></a>Lua与C#进行交互</h1><p>在项目中，C#语言是主语言，Lua 语言是辅助语言，如何才能让两门语言的代码互相访问那？这时候我们需要一座“桥梁”来连接两门语言。</p><h2 id="LuaInterface"><a href="#LuaInterface" class="headerlink" title="LuaInterface"></a>LuaInterface</h2><p>LuaInterface 就是C#与Lua 语言相连的那座桥梁。LuaInterface 是一个开源的项目工程，内部有两个核心的DLL 文件：</p><ul><li><code>LuaInterface.dll</code>：在C#代码中操作Lua 代码需要依赖该文件；</li><li><code>luanet.dll</code>：在Lua 代码中访问C#的类库脚本需要依赖该文件。</li></ul><h2 id="在项目中配置使用Lua环境"><a href="#在项目中配置使用Lua环境" class="headerlink" title="在项目中配置使用Lua环境"></a>在项目中配置使用Lua环境</h2><ol><li>将两个dll 文件拷贝到项目工程中；</li><li>项目工程设置“引用”导入LuaInterface.dll；</li><li>将两个dll 的属性都设置成“如果较新则复制”（非常重要，如果不引用则会报错）</li></ol><h2 id="使用lua解析器对象"><a href="#使用lua解析器对象" class="headerlink" title="使用lua解析器对象"></a>使用lua解析器对象</h2><ol><li>引入<code>using LuaInterface;</code>命名空间；</li><li>实例化<code>lua解析器对象</code>：<code>Lua lua = new Lua()</code>；</li><li>使用lua解析器对象的一些方法。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> LuaInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LuaThree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line">            lua.DoString(<span class="string">"print('This is Lua program')"</span>); <span class="comment">// 这里执行的是Lua代码</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-中Lua代码空间分析"><a href="#C-中Lua代码空间分析" class="headerlink" title="C#中Lua代码空间分析"></a>C#中Lua代码空间分析</h3><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-4-24/96335950.jpg" alt=""></p><p>实际上，虽然C#代码和Lua代码是在一个脚本文件中，但是在程序执行的时候，lua代码（上面第11代码是放到了Lua的那块空间去的）</p><h1 id="C-调用Lua代码"><a href="#C-调用Lua代码" class="headerlink" title="C#调用Lua代码"></a>C#调用Lua代码</h1><h2 id="C-内执行lua代码"><a href="#C-内执行lua代码" class="headerlink" title="C#内执行lua代码"></a>C#内执行lua代码</h2><p>语法：<code>Lua解析器对象.DoString(&quot;Lua代码&quot;)</code></p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 变量的声明与访问；</span></span><br><span class="line">lua.DoString(<span class="string">"name = 'YangJie' age = 19 gender = 'Man' address = 'HuNan'"</span>);</span><br><span class="line">Console.WriteLine(lua[<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. for循环语句；[演示@符号的用途]</span></span><br><span class="line">lua.DoString(<span class="string">@"for i = 1,10,1 do</span></span><br><span class="line"><span class="string">                print(i) </span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 函数的定义与调用；</span></span><br><span class="line">lua.DoString(<span class="string">@"function Show()</span></span><br><span class="line"><span class="string">                print('Show LuaFunction in Csharp.');</span></span><br><span class="line"><span class="string">             end</span></span><br><span class="line"><span class="string">            Show()"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. table 数组声明</span></span><br><span class="line">lua.DoString(<span class="string">@" MyArray = &#123;'AAA', 'BBB', 'CCC'&#125;"</span>);</span><br></pre></td></tr></table></figure><h2 id="C-中调用外部的Lua脚本"><a href="#C-中调用外部的Lua脚本" class="headerlink" title="C#中调用外部的Lua脚本"></a>C#中调用外部的Lua脚本</h2><p>在实际的时候中，大都汇直接调用外部的Lua脚本</p><p><strong>语法：</strong><code>Lua解析器对象.DoFile(&quot;[path]fileName.lua&quot;)</code>方法。</p><blockquote><p><strong>创建Lua脚本文件：</strong>添加-&gt;新建项-&gt;常规-&gt;文本文件，改名且后缀写为.lua;（注意要用其他的编辑器把编码格式从“UTF-8 BOM”改成 “UTF-8”或“GB2312”(中文编码)，否则会抛异常）</p></blockquote><p>注意：在创建Lua文件之后，在VS里面将该文件的<strong>“复制到输出路径”设置为“如果较新则复制”</strong>，否则也会抛异常。（无法找到该文件）</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>MyLua.lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Yangjie"</span></span><br><span class="line">address = <span class="string">"HuNan"</span></span><br><span class="line">age = <span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Lua脚本内的方法"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>C#执行脚本</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lua.DoFile(<span class="string">"MyLua.lua"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> name = lua.GetString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">string</span> address = lua.GetString(<span class="string">"address"</span>);</span><br><span class="line">Double age = lua.GetNumber(<span class="string">"age"</span>);</span><br><span class="line">Console.WriteLine(name + <span class="string">".."</span> + address + <span class="string">".."</span> + age.ToString());</span><br><span class="line"></span><br><span class="line">LuaFunction luaFunction = lua.GetFunction(<span class="string">"Fun"</span>);</span><br><span class="line">luaFunction.Call();</span><br></pre></td></tr></table></figure><h1 id="Lua调用Charp"><a href="#Lua调用Charp" class="headerlink" title="Lua调用Charp"></a>Lua调用Charp</h1><p>对于C#的项目来说，Lua脚本是作为资源存在资源路径下，我们可以对Lua脚本的进行热更新。而Lua脚本就需要访问C#脚本。在Lua中调用C#脚本需要使用<code>luanet.dll</code>这个类库。</p><p><strong>使用步骤：</strong></p><ol><li>导入luanet.dll：<code>require &quot;luanet&quot;</code></li><li>获取程序集：<code>luanet.load_assembly(&quot;程序集名&quot;)</code></li><li>获取类型：<code>变量名 = luanet.import_type(&quot;程序集名.类名&quot;)</code></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Calc.cs（C#中创建一个类，省略了一些代码）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> name = <span class="string">"Calc计算器类"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Jia</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"这是Calc内的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LuaUpdate.lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"luanet"</span>  <span class="comment">-- 导入luanet.dll</span></span><br><span class="line">luanet.load_assembly(<span class="string">"LuaThree"</span>)  <span class="comment">-- 导入程序集</span></span><br><span class="line">Calc = luanet.import_type(<span class="string">"LuaThree.Calc"</span>) <span class="comment">-- 导入类</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Calc.Jia(<span class="number">10</span>, <span class="number">20</span>)) </span><br><span class="line"><span class="built_in">print</span>(Calc.name)</span><br></pre></td></tr></table></figure><p>Program.cs（只保留了核心代码）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line">lua.DoFile(<span class="string">"LuaUpdate.lua"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"><span class="comment">// 这是Calc内的方法</span></span><br></pre></td></tr></table></figure><h3 id="Lua内方法C-的类库"><a href="#Lua内方法C-的类库" class="headerlink" title="Lua内方法C#的类库"></a>Lua内方法C#的类库</h3><p>导入步骤和上面的几乎类似，比如我想导入<code>Console</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"luanet"</span> </span><br><span class="line">luanet.load_assembly(<span class="string">"System"</span>)</span><br><span class="line">Calc = luanet.import_type(<span class="string">"System.Console"</span>)</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"Lua内调用C#的类库"</span>)</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>主要资料来自擅码网Lua课程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lua与C#的交互&lt;br&gt;
    
    </summary>
    
      <category term="lua" scheme="http://yslemmo.github.io/categories/lua/"/>
    
    
      <category term="lua" scheme="http://yslemmo.github.io/tags/lua/"/>
    
      <category term="Charp" scheme="http://yslemmo.github.io/tags/Charp/"/>
    
      <category term="热更新" scheme="http://yslemmo.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="Unity" scheme="http://yslemmo.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra（迪杰特斯拉算法）——查找加权图中最短（快）路径</title>
    <link href="http://yslemmo.github.io/2018/04/22/Dijkstra%EF%BC%88%E8%BF%AA%E6%9D%B0%E7%89%B9%E6%96%AF%E6%8B%89%E7%AE%97%E6%B3%95%EF%BC%89%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE%E5%8A%A0%E6%9D%83%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://yslemmo.github.io/2018/04/22/Dijkstra（迪杰特斯拉算法）——查找加权图中最短路径/</id>
    <published>2018-04-22T07:08:45.000Z</published>
    <updated>2019-02-06T16:12:25.417Z</updated>
    
    <content type="html"><![CDATA[<p>迪克斯特拉算法（英语：Dijkstra’s algorithm）是采用了「广度优先搜索」解决在“加权图”中最短路径的问题</p><a id="more"></a><h1 id="理解迪克斯特拉算法"><a href="#理解迪克斯特拉算法" class="headerlink" title="理解迪克斯特拉算法"></a>理解迪克斯特拉算法</h1><p>使用「广度优先搜索」算法，可以对「非加权图」查词最短路径</p><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-4-22/57363362.jpg" alt=""></p><p>但是对于「加权图」的最短路径问题，则需要使用「迪克斯特拉算法」</p><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-4-22/86778440.jpg" alt=""></p><p>这个图包括四个顶点（起点、A、B、终点），以及连接这些点的边，边上的数字是一点的另一点的「花销」，或者叫做权重。权重越大，花销就越大，反之，花销就越小。要找到从「起点」到「终点」的最短路径，需要在所有路径中找到「总权重」最小的一条路径。下图是我们任意寻找的一条路径，我们可以用迪克斯特拉算法在所有的路径中找出最短（优）的那条路径。</p><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-4-22/81043504.jpg" alt=""></p><h2 id="实现迪克斯特拉算法的步骤"><a href="#实现迪克斯特拉算法的步骤" class="headerlink" title="实现迪克斯特拉算法的步骤"></a>实现迪克斯特拉算法的步骤</h2><ol><li>找出“最便宜”的节点（花销最低），即可在最短时间内到达的节点。</li><li>更新该节点的邻居的开销。</li><li>重复这个过程，直到对图中的每个节点都这样做了。</li><li>计算最终路径。</li></ol><h1 id="代码实现迪克斯特拉算法"><a href="#代码实现迪克斯特拉算法" class="headerlink" title="代码实现迪克斯特拉算法"></a>代码实现迪克斯特拉算法</h1><p>需要实现找到图2的最短路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个散列表来模拟路径图</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一条路径采用了两个散列表，例如["start"]表示自身节点、["a"]表示邻居节点， 6 表示自身节点前往邻居节点的花销</span></span><br><span class="line">graph[<span class="string">"start"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"start"</span>][<span class="string">"a"</span>] = <span class="number">6</span></span><br><span class="line">graph[<span class="string">"start"</span>][<span class="string">"b"</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"a"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"a"</span>][<span class="string">"fin"</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"b"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"b"</span>][<span class="string">"a"</span>] = <span class="number">3</span></span><br><span class="line">graph[<span class="string">"b"</span>][<span class="string">"fin"</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"fin"</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建节点的开销：表示从「起点」出发到该节点需要的“时间”，对于非起始节点的「子节点」我们并不知道它的花销，假设它为无穷大</span></span><br><span class="line">infinity = float(<span class="string">"inf"</span>) <span class="comment"># 表示无穷大</span></span><br><span class="line">costs = &#123;&#125;</span><br><span class="line">costs[<span class="string">"a"</span>] = <span class="number">6</span></span><br><span class="line">costs[<span class="string">"b"</span>] = <span class="number">2</span></span><br><span class="line">costs[<span class="string">"fin"</span>] = infinity</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建父节点的散列表</span></span><br><span class="line">parents = &#123;&#125;</span><br><span class="line">parents[<span class="string">"a"</span>] = <span class="string">"start"</span></span><br><span class="line">parents[<span class="string">"b"</span>] = <span class="string">"start"</span></span><br><span class="line">parents[<span class="string">"fin"</span>] = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录处理过的节点</span></span><br><span class="line">processed = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找开销最低的节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_const_node</span><span class="params">(costs)</span>:</span></span><br><span class="line">    lowest_const = float(<span class="string">"inf"</span>)</span><br><span class="line">    lowest_const_node = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">        cost = costs[node]</span><br><span class="line">        <span class="keyword">if</span> cost &lt; lowest_const <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:       <span class="comment"># 如果当前节点开销更低且为处理过</span></span><br><span class="line">            lowest_const = cost                                 <span class="comment"># 将其视为开销最低的节点</span></span><br><span class="line">            lowest_const_node = node</span><br><span class="line">    <span class="keyword">return</span> lowest_const_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node = find_lowest_const_node(costs) <span class="comment"># 在未处理的节点中找出花销最小的节点</span></span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:              <span class="comment"># 这个while循环在所有节点都被处理过后结束</span></span><br><span class="line">    cost = costs[node]</span><br><span class="line">    neighbors = graph[node]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbors.keys():          <span class="comment"># 遍历当前节点的所有邻居</span></span><br><span class="line">        new_cost = cost + neighbors[n]</span><br><span class="line">        <span class="keyword">if</span> costs[n] &gt; new_cost:               <span class="comment"># 如果当前节点前往该邻居更近</span></span><br><span class="line">            costs[n] = new_cost                 <span class="comment"># 则更新该邻居的开销</span></span><br><span class="line">            parents[n] = node                   <span class="comment"># 同时将该邻居的父节点设置为当前节点</span></span><br><span class="line">    processed.append(node)                  <span class="comment"># 将当前节点标记为处理过</span></span><br><span class="line">    node = find_lowest_const_node(costs)    <span class="comment"># 找出接下来要处理的排名，并循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于显示输出效果    </span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> costs.items():</span><br><span class="line">    print(key + <span class="string">":"</span> + str(value))</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"\n-----------------\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> parents.items():</span><br><span class="line">    print(key + <span class="string">":"</span> + value)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-4-22/48381641.jpg" alt=""></p><p>「终点」的父节点是「a」、「a」的父节点是「b」、「b」的父节点是「start」，这样就把这个加权图的最短路径给找出来了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径。</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《算法图解》第7章节</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迪克斯特拉算法（英语：Dijkstra’s algorithm）是采用了「广度优先搜索」解决在“加权图”中最短路径的问题&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yslemmo.github.io/categories/Python/"/>
    
      <category term="Algorithm" scheme="http://yslemmo.github.io/categories/Python/Algorithm/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="Algorithm" scheme="http://yslemmo.github.io/tags/Algorithm/"/>
    
      <category term="Map" scheme="http://yslemmo.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>[生存之战]_背包合成模块制作总结</title>
    <link href="http://yslemmo.github.io/2018/04/13/%E7%94%9F%E5%AD%98%E4%B9%8B%E6%88%98-%E8%83%8C%E5%8C%85%E5%90%88%E6%88%90%E6%A8%A1%E5%9D%97%E5%88%B6%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yslemmo.github.io/2018/04/13/生存之战-背包合成模块制作总结/</id>
    <published>2018-04-13T11:56:58.000Z</published>
    <updated>2019-02-06T16:12:25.422Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续花了半个月的时间，把《生存之战》背包系统大概做出来了。这也相当于一个大项目的一个较为完整的模块，现在整理一下，也方便以后回顾。</p><a id="more"></a><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-4-13/65782005.jpg" alt=""></p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-4-13/71970226.jpg" alt=""></p><ul><li>整体上这属于一个<strong>背包系统</strong>，包括<code>1</code>的「背包模块」和<code>2</code>「合成模块」</li></ul><h2 id="背包模块"><a href="#背包模块" class="headerlink" title="背包模块"></a>背包模块</h2><p>背包模块比较简单，由一个整体的背景，背包背景子层生成固定数量的背包框，背包物体动态生成，数据是从Json的数据进行解析。</p><h2 id="合成模块"><a href="#合成模块" class="headerlink" title="合成模块"></a>合成模块</h2><p>合成模块相对比较复杂一点，整个上分为3个相对独立的部分（2.1和2.3在搭建UI层次的时候可以先分为一个，然后在拆分成2.1 和 2.3）</p><ul><li><strong>2.1</strong>是合成的类型，比如<strong>武器类</strong>可以有弓箭、长矛；而建筑类可以有窗户、门。</li><li><strong>2.2</strong>是具体的合成物品的种类，比如上面提到的弓箭、长矛等。</li><li><strong>2.3</strong>是某个物品的合成图谱，也就是说合成这个物品需要哪些原材料，在合成之前需要把原材料从背包模块拖拽到对应的图谱位置。</li><li><strong>2.4</strong>是进行合成的具体区域，当某个物品的合成图谱全部被填充好之后，才可以进行合成。</li></ul><h1 id="搭建UI布局"><a href="#搭建UI布局" class="headerlink" title="搭建UI布局"></a>搭建UI布局</h1><p>这里的UI布局是“死”的UI，先把整个的UI布局确定好，后面再根据这个UI布局进行灵活的“动态生成”，“逻辑控制”。搭建UI布局要注意的点：</p><ul><li>“大元素套小元素”，相对大的元素与覆盖在它表面的相对小的元素形成父子关系。这也是在Web开发中常常会使用到的「Div + CSS」布局的思路。</li><li>重复的子元素（比如合成图谱分类的Tab、各种的物品框）才表格布局的方法，先手动复制多个元素调试到适合的布局，再将这个元素制作成一个「预制体」，最后在代码中动态生成。</li></ul><h1 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h1><h2 id="M-V-C架构介绍"><a href="#M-V-C架构介绍" class="headerlink" title="M.V.C架构介绍"></a>M.V.C架构介绍</h2><p>在以前的案例制作中，常常会把「数据控制」「UI控制」「逻辑控制」放到一个Manager的控制脚本中，这样做的问题时，单个脚本的代码量非常庞大，管理起来不方便。因此，我们可以把UI相关的脚本分为三块：</p><ul><li><strong>数据控制[Model]</strong> (对XML、Json 读取，存储，更新…)</li></ul><ul><li><strong>界面控制[View]</strong> (组件查找，UI 数据更新…)</li><li><strong>整体逻辑[Controller]</strong> (循环生成子元素，UI 的事件处理，商品购买…)</li></ul><h3 id="迷你版MVC"><a href="#迷你版MVC" class="headerlink" title="迷你版MVC"></a>迷你版MVC</h3><p>迷你版MVC 主要应用在UI 功能模块的Panel 上，也就是模块的整体控制。</p><ul><li><strong>XxxxPanelView.cs</strong></li><li><strong>XxxxPanelController.cs</strong></li><li><strong>XxxxPanelModel.cs</strong></li></ul><p>而Panel 的子级物体还是单个脚本控制，叫做<code>XxxxItemController.cs</code>，因为子级物体逻辑相对简单，可以先不分层。</p><h3 id="使用迷你版MVC的注意事项"><a href="#使用迷你版MVC的注意事项" class="headerlink" title="使用迷你版MVC的注意事项"></a>使用迷你版MVC的注意事项</h3><ul><li>创建好MVC的三个脚本挂载到XxxPanel之后，「Controller脚本」要分别持有「View脚本」「Model脚本的引用」。因为「Controller脚本」处于主导地位。「View脚本」与「Model脚本」不直接通信。</li><li>Model脚本把加载好的数据以字段封装成属性的方式公开，Controller脚本可以调用，View的设置UI的方法也公开，通用供Controller脚本使用。</li><li>View 和Model 脚本当中的初始化操作需要放到Awake 方法内，Controller的初始化放到Start 方法内。目的是为了Controller 控制界面和数据的时候，这两个脚本必须已经初始化完毕。</li></ul><h2 id="脚本分析"><a href="#脚本分析" class="headerlink" title="脚本分析"></a>脚本分析</h2><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-4-13/54304579.jpg" alt=""></p><p>从上面的脚本关系图可以看出，整体上有两个「MVC框架」，因为我们之前已经把背包系统分为了两个模块，背包模块和合成模块，所以使用两个「MVC」分别对背包模块和合成模块进行控制：</p><ul><li>背包模块<ul><li>InventoryPanelController.cs</li><li>InventoryPanelView.cs</li><li>InventoryPanelModel.cs</li></ul></li><li>合成模块<ul><li>CraftingPanelController.cs</li><li>CraftingPanelView.cs</li><li>CraftingPanelModel.cs</li></ul></li></ul><h3 id="背包模块-1"><a href="#背包模块-1" class="headerlink" title="背包模块"></a>背包模块</h3><p>背包模块比较简单：</p><p>View层查找相关组件，并加载（Resources）生成UI所需的预制体供Controller层使用；</p><p>Model层从Json文件中解析出生成背包物体所需要的数据，并公开相应的方法让Controller使用这些数据；注意这里还创建想背包物体的「数据实体类」<code>InventoryItem.cs</code></p><p>Controller层负责调用View层和Model层的数据，循环生成UI物体</p><h3 id="合成模块-1"><a href="#合成模块-1" class="headerlink" title="合成模块"></a>合成模块</h3><p>合成模块相对于背包模块来说复杂一些，主要体现在Controller脚本中有几个子类物体的控制脚本。主要是因为北城模块的UI层次就很复杂，但是合成模块的MVC职责分工和背包模块的MVC的职责分工是一样的。</p><p>需要注意的是，「CraftingPanelController.cs」负责总的逻辑控制，而它的子物体的控制脚本只需要负责公开方法供它使用就可以的。</p><p>如果生成子类物体的时候想要初始化它的控制脚本的数据，可以在子类的控制脚本定义一个初始化的方法<code>Init（）</code>，在生成子类的之后就调用它的子类控制脚本的初始化方法，并传递必要的数据。</p><h3 id="模块间进行通信"><a href="#模块间进行通信" class="headerlink" title="模块间进行通信"></a>模块间进行通信</h3><p>两个模块进行通信，可以先把两个MVC的「Controller脚本」封装成单例，然后通过<code>XxxxPanelController.Instance.方法名()</code>的方式进行通信。</p><p>需要注意的是，模块与模块之间，最好只是两个Controller层通信，比如：》</p><blockquote><p><code>InventoryItemController.cs</code>想要调用<code>CarftingPanelController.cs</code>的方法则可以先在<code>InventoryPanelController.cs</code>声明一个公开的方法去调用<code>CarftingPanelContoller</code>的方法</p><p>然后<code>InventoryItemController.cs</code>再去调用那个公开的方法。</p></blockquote><p>这样做的目的是单一“脚本的职责”，减少脚本的耦合</p><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>在上面的脚本关系图中，最右边有两个工具类，分别是<code>ResourcesTools.cs</code>和<code>JsonTools.cs</code>，这两个脚本是在脚本编写过程中抽离出来的（在实际开发过程中，这些工具类是事先已经提供好的，可以直接进行使用，一般是“主程”编写好的），它与游戏逻辑没有直接业务关系。但是游戏逻辑需要使用到这些工具类。工具类的特点：</p><ul><li>工具类的实现有两种语法格式：密封类，结构体；最常用的还是密封类（sealed）格式；</li><li>工具类内的成员全部用static 静态关键字修饰；</li><li>工具类不需要实例对象，使用格式是：工具类名.字段名/属性名/方法名/；</li><li>工具类就是一个普通的C#类，不需要继承Mono 行为类。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>项目文件：链接: <a href="https://pan.baidu.com/s/1yeGrQNXHshJfAWG9N9gzhA" target="_blank" rel="noopener">https://pan.baidu.com/s/1yeGrQNXHshJfAWG9N9gzhA</a> 密码: wfnk</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;断断续续花了半个月的时间，把《生存之战》背包系统大概做出来了。这也相当于一个大项目的一个较为完整的模块，现在整理一下，也方便以后回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://yslemmo.github.io/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yslemmo.github.io/tags/Unity/"/>
    
      <category term="UI" scheme="http://yslemmo.github.io/tags/UI/"/>
    
      <category term="Project" scheme="http://yslemmo.github.io/tags/Project/"/>
    
  </entry>
  
  <entry>
    <title>Python-简单的递归</title>
    <link href="http://yslemmo.github.io/2018/04/02/Python-%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92/"/>
    <id>http://yslemmo.github.io/2018/04/02/Python-简单的递归/</id>
    <published>2018-04-02T04:11:05.000Z</published>
    <updated>2018-04-02T06:58:08.189Z</updated>
    
    <content type="html"><![CDATA[<p>什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身称为递归调用。</p><a id="more"></a><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身成为递归调用。</p><p>“庙里的老和尚”的故事可以用来理解这种模式</p><blockquote><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’” ——<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92" target="_blank" rel="noopener">维基百科</a></p></blockquote><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>使用递归函数的关键：</p><ol><li><strong>找出基线条件，退出递归函数</strong></li><li><strong>缩小问题的规模</strong></li></ol><h2 id="用递归来求和"><a href="#用递归来求和" class="headerlink" title="用递归来求和"></a>用递归来求和</h2><ul><li>用循环来求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(arr)</span>:</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">        total += x</span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><ul><li>用递归的求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(arr)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> arr == []:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">return</span> list[<span class="number">0</span>]+sum(list[<span class="number">1</span>:]) </span><br><span class="line"></span><br><span class="line">print(sum([<span class="number">12</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">9</span>])) </span><br><span class="line"><span class="comment"># 输入结果：42</span></span><br></pre></td></tr></table></figure><h2 id="用递归来计算列表的长度"><a href="#用递归来计算列表的长度" class="headerlink" title="用递归来计算列表的长度"></a>用递归来计算列表的长度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countElem</span><span class="params">(arr)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> arr==[]:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+countElem(arr[<span class="number">1</span>:])  </span><br><span class="line"></span><br><span class="line">print(countElem([<span class="number">12</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">9</span>]))</span><br><span class="line"><span class="comment"># 输出结果：4</span></span><br></pre></td></tr></table></figure><h2 id="用递归来找出最大元素"><a href="#用递归来找出最大元素" class="headerlink" title="用递归来找出最大元素"></a>用递归来找出最大元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxElem</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>] <span class="keyword">if</span> arr[<span class="number">0</span>] &gt; maxElem(arr[<span class="number">1</span>:]) <span class="keyword">else</span> maxElem(arr[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">print(maxElem([<span class="number">12</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">9</span>]))</span><br><span class="line"><span class="comment"># 输出结果：17</span></span><br></pre></td></tr></table></figure><ul><li>理解<code>return-if-else</code>：这是Python支持的一种语法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"a"</span> <span class="keyword">if</span> <span class="number">1</span>&lt;<span class="number">2</span> <span class="keyword">else</span> <span class="string">"b"</span></span><br></pre></td></tr></table></figure><ul><li>在这里<code>1&lt;2</code>是判断条件，如果条件成立则返回“a”，如果条件不成立则返回“b”</li></ul><h2 id="快速排序（quick）"><a href="#快速排序（quick）" class="headerlink" title="快速排序（quick）"></a>快速排序（quick）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>] <span class="comment"># 递归条件</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line">    </span><br><span class="line"> print(quicksort([<span class="number">12</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">9</span>]))</span><br><span class="line"> <span class="comment"># 输出结果：[4, 9, 12, 17]</span></span><br></pre></td></tr></table></figure><ul><li>基线条件：<code>2行</code>：当数组为空或者只包含一个元素，这样最后只需要原样恢复数组，不用再进行排序</li><li><code>pivot</code>是基准值，用于对其他的数进行分类</li><li><code>less</code>存储的是比<code>pivot</code>小的数组成的数组</li><li><code>greater</code>存储的是比<code>pivot</code>大的数组成的数组</li><li>快速排序的算法复杂度<code>O(n * Log n)</code></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/" target="_blank" rel="noopener">递归算法详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身称为递归调用。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yslemmo.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="递归" scheme="http://yslemmo.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="算法" scheme="http://yslemmo.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>迪米特原则</title>
    <link href="http://yslemmo.github.io/2018/03/26/%E8%BF%AA%E7%B1%B3%E7%89%B9%E5%8E%9F%E5%88%99/"/>
    <id>http://yslemmo.github.io/2018/03/26/迪米特原则/</id>
    <published>2018-03-26T13:13:59.000Z</published>
    <updated>2018-03-26T13:35:54.649Z</updated>
    
    <content type="html"><![CDATA[<p>迪米特原则也叫最小知道原则</p><a id="more"></a><h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><blockquote><p>一个对象应该对其他对象保持最少的了解。</p></blockquote><ul><li>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另外一个类的某一个方法的话，可以通过第三者转发这个调用。</li><li>一个对象应当对其他对象有尽可能少的了解。</li></ul><h1 id="迪米特原则的切入点"><a href="#迪米特原则的切入点" class="headerlink" title="迪米特原则的切入点"></a>迪米特原则的切入点</h1><ol><li><strong>在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</strong></li></ol><p>Unity 项目开发，不要使用public 公开字段，然后面板拖拽资源赋值这种方式。应该把字段全部private 修饰，然后public 属性公开调用。</p><ol start="2"><li><strong>迪米特原则主要是强调了类与类之间的松耦合</strong></li></ol><p>类与类之间的耦合度越低，越有利于代码的复用，一个处于低耦合的类被修改了，<br>不会对有关系的类造成影响</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/zhengzhb/article/details/7296930" target="_blank" rel="noopener">迪米特原则</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迪米特原则也叫最小知道原则&lt;/p&gt;
    
    </summary>
    
      <category term="OOP" scheme="http://yslemmo.github.io/categories/OOP/"/>
    
    
      <category term="OOP六大原则" scheme="http://yslemmo.github.io/tags/OOP%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="Design Pattern" scheme="http://yslemmo.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>依赖倒置原则</title>
    <link href="http://yslemmo.github.io/2018/03/26/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
    <id>http://yslemmo.github.io/2018/03/26/依赖倒置原则/</id>
    <published>2018-03-26T12:44:56.000Z</published>
    <updated>2019-02-06T16:12:25.423Z</updated>
    
    <content type="html"><![CDATA[<p>针对抽象编程，不要针对实现编程；</p><a id="more"></a><h1 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h1><blockquote><p><em>A. High-level modules should not depend on low-level modules. Both should depend on abstractions.</em></p><p>B. Abstractions should not depend on details. Details should depend on abstractions.</p></blockquote><ul><li><p>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">抽象接口</a>)。</p><p><em>模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</em></p></li><li><p>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</p></li></ul><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>参考擅码网的讲解</p><h2 id="PHP中的依赖倒置原则"><a href="#PHP中的依赖倒置原则" class="headerlink" title="PHP中的依赖倒置原则"></a>PHP中的依赖倒置原则</h2><p><img src="http://blog-1258616090.cos.ap-chengdu.myqcloud.com/18-3-26/79150972.jpg" alt=""></p><p>代码逻辑并不是直接操控数据库，而是通过一个抽象的<code>PDO类</code>来进行增删改查，这样的好处是如果要更改使用的数据库类型，比如原本是使用「MySQL」，现在要改成「SQLite」，只需要对<code>PDO类</code>更改操作数据库的逻辑，而关键的「代码逻辑」不需要发生任何变化。</p><h2 id="Unity引擎的依赖倒置"><a href="#Unity引擎的依赖倒置" class="headerlink" title="Unity引擎的依赖倒置"></a>Unity引擎的依赖倒置</h2><p>Unity引擎的跨平台性很强</p><ol><li>早期开发游戏</li></ol><blockquote><ul><li>Android 平台的游戏，需要使用Eclipse 开发，只能运行于Android 平台；</li><li>IOS 平台的游戏，需要使用XCode 开发，只能运行于IOS 平台；</li><li>因为编写这些游戏时，使用的代码，都是各个平台提供的针对性的API。</li><li><strong>高层依赖于底层：开发游戏需要依赖于该平台的底层API。</strong></li></ul></blockquote><ol start="2"><li>Unity开发游戏</li></ol><blockquote><ul><li>使用C#开发一个版本，稍作调整就能发布到N 个平台。在我们发布成不同平台的游戏的时候，Unity 本身就做了一个“对接”的任务，把我们的代码里面的API，对接到该平台上相应的API。</li><li><strong>高层和底层都依赖于抽象：我们的游戏是依赖Unity 的，各个平台的API 也是Unity 完成对接任务的。</strong></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对抽象编程，不要针对实现编程；&lt;/p&gt;
    
    </summary>
    
      <category term="OOP" scheme="http://yslemmo.github.io/categories/OOP/"/>
    
    
      <category term="OOP六大原则" scheme="http://yslemmo.github.io/tags/OOP%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="Design Pattern" scheme="http://yslemmo.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>开闭原则</title>
    <link href="http://yslemmo.github.io/2018/03/26/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>http://yslemmo.github.io/2018/03/26/开闭原则/</id>
    <published>2018-03-26T12:17:42.000Z</published>
    <updated>2018-03-26T12:43:29.613Z</updated>
    
    <content type="html"><![CDATA[<p><strong>开闭原则</strong> 规定“<em>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的</em>”</p><a id="more"></a><blockquote><p>定义：软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</p></blockquote><ul><li>面对需求，对程序的改动应该是以增加新代码的方式解决，而不是更改旧的代码。</li><li>在实际开发过程中，开发的某个功能，可能因为需求有变化，要重新构建新的代码。但是原来的代码也不能删掉，如果之后需求再发生变化，又要换到之前的代码，则只需要简单更换一个业务逻辑即可。</li><li>开放封闭原则，其中的封闭不是绝对的封闭。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;开闭原则&lt;/strong&gt; 规定“&lt;em&gt;软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的&lt;/em&gt;”&lt;/p&gt;
    
    </summary>
    
      <category term="OOP" scheme="http://yslemmo.github.io/categories/OOP/"/>
    
    
      <category term="OOP六大原则" scheme="http://yslemmo.github.io/tags/OOP%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="Design Pattern" scheme="http://yslemmo.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>使用Jieba库制作统计《水浒传》角色的出现次数</title>
    <link href="http://yslemmo.github.io/2018/03/25/%E4%BD%BF%E7%94%A8Jieba%E5%BA%93%E5%88%B6%E4%BD%9C%E7%BB%9F%E8%AE%A1%E3%80%8A%E6%B0%B4%E6%B5%92%E4%BC%A0%E3%80%8B%E8%A7%92%E8%89%B2%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
    <id>http://yslemmo.github.io/2018/03/25/使用Jieba库制作统计《水浒传》角色的出现次数/</id>
    <published>2018-03-25T05:38:17.000Z</published>
    <updated>2018-03-25T06:16:01.336Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习Python一个星期依赖独立制作的一个比较小的案例脚本，计算一段文本的「词频」</p><a id="more"></a><h1 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h1><p>统计出某一文本中词条的词频。这个案例我是用水浒传文本来统计出每一名角色(108将)出现的次数</p><h1 id="案例知识点"><a href="#案例知识点" class="headerlink" title="案例知识点"></a>案例知识点</h1><ul><li>使用<code>Jieba模块</code>分词</li><li>使用<code>json模块</code>将字典导出成<code>json文本</code></li><li>Python的<code>IO操作</code></li></ul><h1 id="案例准备"><a href="#案例准备" class="headerlink" title="案例准备"></a>案例准备</h1><ul><li>Windows 10</li><li>Python 3.6</li><li>安装好JieBa库</li><li>《水浒传》.txt文本</li><li>水浒108将.txt文本</li></ul><h2 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── namerate.json</span><br><span class="line">├── RoleCount.py</span><br><span class="line">├── role.txt</span><br><span class="line">└── shuihu.txt</span><br></pre></td></tr></table></figure><h2 id="安装JieBa库"><a href="#安装JieBa库" class="headerlink" title="安装JieBa库"></a>安装JieBa库</h2><blockquote><p>jieba 是一个python实现的分词库，对中文有着很强大的分词能力。</p><p>Git链接：<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">https://github.com/fxsjy/jieba</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py -3 -m pip install Jieba</span><br></pre></td></tr></table></figure><h2 id="处理素材文本"><a href="#处理素材文本" class="headerlink" title="处理素材文本"></a>处理素材文本</h2><p>“水浒传.txt”不需要额外处理，但是“108将”需要使用「正则表达式」进行处理，处理结果最后应该是，每一行文本只有一个将领的名字。</p><h1 id="实验脚本"><a href="#实验脚本" class="headerlink" title="实验脚本"></a>实验脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 108将字典</span></span><br><span class="line">roles = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储水浒所有的文本</span></span><br><span class="line">shuihu_str = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入文件的名字</span></span><br><span class="line">filename = <span class="string">'namerate.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把108将添加到jieba词库中去</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddWords</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> roles:</span><br><span class="line">        jieba.add_word(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开role文本，创建字典</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"role.txt"</span>, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> file_Object:</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> file_Object:</span><br><span class="line">        roles[name.strip()] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">AddWords()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开shuihu文本，存储到shuihu_str变量中去</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"shuihu.txt"</span>, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> file_Object:</span><br><span class="line">    lines = file_Object.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        shuihu_str += line.strip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分词匹配</span></span><br><span class="line">seg_list = jieba.cut(shuihu_str, cut_all=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> seg_list:</span><br><span class="line">    <span class="keyword">for</span> role <span class="keyword">in</span> roles:</span><br><span class="line">        <span class="keyword">if</span>(role == word):</span><br><span class="line">            roles[role] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"匹配完毕"</span>)</span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    f_obj.write(json.dumps(roles, ensure_ascii=<span class="keyword">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Cmd窗口输出字典</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> roles.items():</span><br><span class="line">    print(key)</span><br></pre></td></tr></table></figure><h1 id="案例制作总结"><a href="#案例制作总结" class="headerlink" title="案例制作总结"></a>案例制作总结</h1><p>这个项目遇到的最大的问题是“中文字符”的编码问题，比如在<code>30行</code>open的文本无法与str相加，可能是字符编码不相同，存储字典到<code>.json</code>的中文字符也是乱码的。    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习Python一个星期依赖独立制作的一个比较小的案例脚本，计算一段文本的「词频」&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yslemmo.github.io/categories/Python/"/>
    
      <category term="Module" scheme="http://yslemmo.github.io/categories/Python/Module/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="案例" scheme="http://yslemmo.github.io/tags/%E6%A1%88%E4%BE%8B/"/>
    
      <category term="Module" scheme="http://yslemmo.github.io/tags/Module/"/>
    
      <category term="自然语言处理" scheme="http://yslemmo.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
