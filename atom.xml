<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lemmo&#39;s Blog</title>
  
  <subtitle>一个人的碎碎念</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yslemmo.github.io/"/>
  <updated>2019-03-23T08:10:37.000Z</updated>
  <id>http://yslemmo.github.io/</id>
  
  <author>
    <name>lemmo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity3D音频管理器「生存之战」</title>
    <link href="http://yslemmo.github.io/post/Unity3D-AudioManager.html"/>
    <id>http://yslemmo.github.io/post/Unity3D-AudioManager.html</id>
    <published>2019-03-23T08:10:37.000Z</published>
    <updated>2019-03-23T08:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unity3D的音频系统介绍</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想象如果电影没有了声音，我的观影体验会大打折扣，声音也对于游戏有非常重大的意义。游戏中的声音主要是指游戏交互过程中的各种音效，如走路会产生脚步声，射击时会有枪声，这些音效就是为了产生更沉浸的世界（环境），另外游戏的背景音乐也可以烘托游戏气氛。</p><h2 id="Unity3D中的声音"><a href="#Unity3D中的声音" class="headerlink" title="Unity3D中的声音"></a>Unity3D中的声音</h2><h2 id="音频管理器"><a href="#音频管理器" class="headerlink" title="音频管理器"></a>音频管理器</h2><blockquote><p><strong>Edit–&gt;ProjectSetting–&gt; Audio</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190323172804.png" alt=""></p><h2 id="AudioClip（音频文件）"><a href="#AudioClip（音频文件）" class="headerlink" title="AudioClip（音频文件）"></a>AudioClip（音频文件）</h2><p>Unity3D中支持各种格式的音频文件，可以导入的音频格式有<code>.wav</code> <code>.mp3</code> <code>.ogg</code>，可以直接将音频文件拖拽到Unity3D的「Assets」中里。在Unity3D里面，这些音频文件叫做<code>Audio Clip</code>。</p><h2 id="AudioListener-（音频监听器组件）"><a href="#AudioListener-（音频监听器组件）" class="headerlink" title="AudioListener （音频监听器组件）"></a>AudioListener （音频监听器组件）</h2><p>一个<code>Scence</code>中有一个<code>AudioListener</code>，它可以接受游戏中的所有音乐和音效，相当于人的“耳朵”，创建场景中它会自动挂载在<code>Main Camera</code>物体上。</p><h2 id="AudioSource（声音源组件）"><a href="#AudioSource（声音源组件）" class="headerlink" title="AudioSource（声音源组件）"></a>AudioSource（声音源组件）</h2><p>在Unity3D中是通过<code>Audio Source</code>这个声音组件来播放声音的，在任何一个物体（gameobject）上都可以直接挂在这个<code>Audio Source</code>组件。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190323165557.png" alt=""></p><ul><li>AudioClip：拖入音频AudioClip文件</li><li>Output：音频剪辑通过音频混合器输出;</li><li>Mute：是否静音；</li><li>Play On Awake：是否自动播放（<em>如果这个组件时通过代码添加上的，而不是一开始就有的，不会自动播放，需要使用<code>AudioSource.Play()</code>来播放</em>）</li><li>Loop：是否循环播放</li><li>Priority：当场景中有多个音频共存时，设定的优先级播放</li><li>Volume：音量大小</li></ul><h2 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h2><p>使用代码设置音频和对音频的控制需要先获取<code>AudioSource</code>组件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取AudioSouce组件</span></span><br><span class="line">AudioSource audioSource = transform.GetComponent&lt;AudioSource&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制音频</span></span><br><span class="line">audioSource.clip = clip;    <span class="comment">// 设置clip</span></span><br><span class="line">audioSource.volume = <span class="number">0.5f</span>;  <span class="comment">// 设置音量大小</span></span><br><span class="line">audioSource.loop = <span class="literal">true</span>;    <span class="comment">// 设置循环播放 </span></span><br><span class="line">audioSource.Play();         <span class="comment">// 开始播放</span></span><br><span class="line">audioSource.Stop();         <span class="comment">// 停止播放</span></span><br><span class="line">audioSource.Pause();        <span class="comment">// 暂停播放</span></span><br><span class="line">audioSource.UnPause();      <span class="comment">// 继续播放</span></span><br></pre></td></tr></table></figure><h1 id="独立的音频管理器（生存之战音频管理器为例）"><a href="#独立的音频管理器（生存之战音频管理器为例）" class="headerlink" title="独立的音频管理器（生存之战音频管理器为例）"></a>独立的音频管理器（生存之战音频管理器为例）</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需要控制的音频比较少时可以直接在物体自身的脚本中获取<code>AudioSource</code>组件进行控制，但如果需要控制的音频比较多时，或想后期修改音频逻辑时，需要重新打开对应的脚本比较复杂。将和音频控制相关的代码封装了独立的脚本会方便很多。需求点：</p><ul><li>管理器必须是单例模式，方便在项目中随处使用该类的功能；</li><li>直接持有和管理几十个甚至几百个音频资源；</li><li>可以实现传递音频资源名，然后在某个位置播放音频；</li><li>可以实现动态的给某个游戏物体添加音频组件，配置音频组件相关属性；</li><li>还要提高音频管理器的“易用性”，规范音频资源命名，方便快速找到需要的资源。</li></ul><h2 id="导入音频"><a href="#导入音频" class="headerlink" title="导入音频"></a>导入音频</h2><p>将所有音频资源导入「Resources」文件夹中</p><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><h3 id="创建音频资源枚举"><a href="#创建音频资源枚举" class="headerlink" title="创建音频资源枚举"></a>创建音频资源枚举</h3><p>使用资源名称枚举可以方便我们使用对应的音频时快速找到需要的音频资源，枚举值和音频资源名要一一对应</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ClipName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 野猪攻击音效.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    BoarAttack,</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 野猪死亡音效.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    BoarDeath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建AudiosManager-cs，加载音频资源"><a href="#创建AudiosManager-cs，加载音频资源" class="headerlink" title="创建AudiosManager.cs，加载音频资源"></a>创建<code>AudiosManager.cs</code>，加载音频资源</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AudiosManager Instance;<span class="comment">// 单例</span></span><br><span class="line"><span class="keyword">private</span> AudioClip[] audioClip;</span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="keyword">string</span>, AudioClip&gt; audioClipDic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Instance = <span class="keyword">this</span>;</span><br><span class="line">    audioClipDic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, AudioClip&gt;();</span><br><span class="line">    audioClip = Resources.LoadAll&lt;AudioClip&gt;(<span class="string">"Audios/All/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把所有音频添加到字典中去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; audioClip.Length; i++)&#123;</span><br><span class="line">        audioClipDic.Add(audioClip[i].name, audioClip[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将该类定义为单例模式</li><li>使用<code>Resources.LoadAll&lt;&gt;()</code>加载所有AudioClip，得到一个AudioClip数组</li><li>将资源数组遍历存储到一个字典结构中</li></ul><h3 id="音频播放方法"><a href="#音频播放方法" class="headerlink" title="音频播放方法"></a>音频播放方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过名字获取音频资源</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AudioClip <span class="title">GetAudioClipByName</span>(<span class="params">ClipName clipName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AudioClip tempClip;</span><br><span class="line">    audioClipDic.TryGetValue(clipName.ToString(), <span class="keyword">out</span> tempClip);</span><br><span class="line">    <span class="keyword">return</span> tempClip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 在指定位置播放音频</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayAudioClipByName</span>(<span class="params">ClipName clipName, Vector3 pos</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AudioSource.PlayClipAtPoint(GetAudioClipByName(clipName), pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 给游戏物体添加音频组件来播放音频</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AudioSource <span class="title">AddAudioSourceComponent</span>(<span class="params">ClipName clipName, GameObject go, <span class="keyword">bool</span> playOnAwake = <span class="literal">true</span>, <span class="keyword">bool</span> loop = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AudioSource audioSource = go.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">    audioSource.clip = GetAudioClipByName(clipName);</span><br><span class="line">    <span class="keyword">if</span> (playOnAwake)    audioSource.Play();</span><br><span class="line">    audioSource.loop = loop;</span><br><span class="line">    <span class="keyword">return</span> audioSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在其他脚本中使用AudioManger-cs"><a href="#在其他脚本中使用AudioManger-cs" class="headerlink" title="在其他脚本中使用AudioManger.cs"></a>在其他脚本中使用<code>AudioManger.cs</code></h3><p>需要先查找持有这个脚本的引用，调用该管理器内的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AudiosManager.Instance.</span><br><span class="line">    PlayAudioClipByName(ClipName.BoarInjured, transform.position);</span><br></pre></td></tr></table></figure><hr><p>参考资料：</p><ul><li><a href="http://gad.qq.com/article/detail/288828" target="_blank" rel="noopener">关于Unity中3D声音的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unity3D的音频系统介绍&lt;/p&gt;
    
    </summary>
    
      <category term="Unity3D" scheme="http://yslemmo.github.io/categories/Unity3D/"/>
    
    
      <category term="Unity3D" scheme="http://yslemmo.github.io/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>降噪耳机Bose-QC-30使用体验</title>
    <link href="http://yslemmo.github.io/post/Bose-QC-30.html"/>
    <id>http://yslemmo.github.io/post/Bose-QC-30.html</id>
    <published>2019-03-14T22:53:46.000Z</published>
    <updated>2019-03-18T10:49:12.625Z</updated>
    
    <content type="html"><![CDATA[<p>这是我买的第一款“主动降噪”耳机，本文谈谈对 QC-30 这款产品的使用体验。</p><a id="more"></a><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在买一款耳机之前，买过至少10条以上还不错的耳机。目前还在使用的有，1条小米平头耳机、2条“入耳式耳机”（分别是AKG和小米活塞耳机）、一个不知名的运动耳机、一个头戴式耳机（Sony 1AbT）。我并不是一个耳机发烧友，有HIFI音质没有很大的追求，但喜欢在不同的使用场景下使用合适的耳机。</p><p>18年底到19年初这段期间听了比较多的播客，就一直想买一款「分体式耳机」，也就是商家标称的「真·无线耳机」，以AirPorts为参考，考虑过<a href="http://item.mi.com/product/9016.html" target="_blank" rel="noopener">小米AirDots</a>、<a href="http://item.mi.com/product/9209.html" target="_blank" rel="noopener">小米蓝牙耳机Air</a>，另外还有 QCY T1，漫步者 W2等小众品牌，但考虑到颜值问题，还是优先考虑小米的两款。（值得一提的时候，小米AirDots就是Qcy T1的贴牌产品，只是换了外观设计）。但小米的这两款蓝牙耳机一直买不到，无论是线上还是在小米之家，后来想着就入手一款降噪耳机。</p><p>目前，主流的降噪耳机分3种，一种是「分体式耳机」，一种是「项圈式耳机」，一种是头戴式耳机（Sony WH-1000XM3、Bose Qc35）。考虑到自己已经有一款头戴式耳机，就只有「项圈式降噪耳机」了，千元以后的有「Sony Wi-1000x」、「Bose QC-30」，百元以内的有「DyPlay ANC30（￥279）」。前几天的晚上，逛闲鱼的时候发现有人在卖全新未拆封的 QC-30 ，直接砍了50元后，以1200元的价格买了。</p><h1 id="外观与佩戴"><a href="#外观与佩戴" class="headerlink" title="外观与佩戴"></a>外观与佩戴</h1><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190315074148.png" alt=""></p><p>Bose QC-30 的简单一点描述就是一个「项圈」，采用半圈形的结构，让耳机直接挂在脖子上，能在一定程度上提升耳机的佩戴舒适度。项圈部分采用”类肤质“的材料、耳塞外部是金属材料、按键控制是硬塑料，鲨鱼鳍耳塞是软硅胶材质的。整体来看，产品在设计风格、材料选择方面都比较协调，统一。再说一说细节部分，仔细看耳机，我都不敢相信这做工是2000价位的耳机，与Sony的做工（细节把控）有点差距，如项圈有些部分的胶并没有粘好，使用一段时间或出汗可能会导致脱胶、鼓包等问题。</p><p>因为耳式项圈部分采用了类肤质的材料，所以直接把耳机与皮肤接触并没有什么不适，长时间佩戴甚至会忽视它的存在。当穿上有领的衣服时，项圈还可以直接放在领子的外面。佩戴上另一个非常难受的问题，项圈戴久之后，项圈的位置会变歪，对强迫症来说非常难受呀！不得不过几十分钟就要把它手动放正。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/photo_2019-03-15_08-00-40.jpg" alt=""></p><p>另外一个关键的问题时耳塞的的舒适度。得益于Bose 独家的<code>鲨鱼鳍耳塞</code>，半入耳式的设计能让做到长时间佩戴都很舒适，而且怎么甩耳机都不会从耳朵里溜出来。解决了平头耳机容易掉，耳塞式耳机的堵耳，头戴式耳机夹眼镜夹耳等问题。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190315080958.png" alt=""></p><h1 id="连接耳机"><a href="#连接耳机" class="headerlink" title="连接耳机"></a>连接耳机</h1><p>QC-30支持蓝牙4.2连接，不支持LDAC以及aptX。蓝牙连接设备没什么好说的，QC-30还支持NFC连接的，但经过我多次测验，无论是通过手机NFC还是 Sony-A30 的 NFC 都无法正常连接，只能通过手动点击蓝牙连接。当然，耳机开机时如果手机的蓝牙时打开的，耳机会自动连接手机，连接的速度还是挺快的。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190315093655.png" alt=""></p><p>连接好APP后，可以拖动中间的滑动条调节降噪的等级，支持11级调节。左下角的连接蓝牙标志可以进行蓝牙连接，往右边的是Bose 音乐分享功能，介绍说时能在两台Bose设备之间无线传输音频，可惜我只有一台 Bose设备，最右边的时蓝牙当前的剩余电量。最下面的播放播放控制，这个控制可以接管连接上设备的音频控制权。比如 网易云音乐 或是 Spotify 播放音乐，或是连接上的其他播放器（Sony-A30）也可以控制。</p><p>Bose-QC-30 可以同时连接两台设备，但是使用体验并不是很好。</p><ul><li>同时连接 Sony-A30 和手机，并使用 Sony-A30 播放音乐时，如果手机上要播放音频，需要先暂停 Sony-A30上的播放，否则手机播放没有声音。</li><li><del>同时连接 PC 和手机，使用 PC 播放音乐，如果手机接到任何通知或要播放声音，会中断当前音乐的播放，过一会又继续播放。</del></li></ul><p>注意：在使用 Win10 连接耳机时，需要先连接手机，打开 Bose Connect ，点击蓝牙-连接新设备，再使用 Win10 搜索蓝牙设备连接 Bose QuietControl 30。</p><h1 id="降噪表现"><a href="#降噪表现" class="headerlink" title="降噪表现"></a>降噪表现</h1><p>降噪是这款耳机最主要的功能，降噪分为两种。一种是被动降噪，一种是主动降噪。对于第一种，更恰当地说是隔音，戴海绵耳塞、头戴耳机式。</p><blockquote><p>被动式降噪耳机利用物理特性将外部噪声与耳朵隔绝开，主要通过隔声材料阻挡噪声，对高频率声音非常有效，一般可使噪声降低大约为15-20dB。</p></blockquote><p>而主动降噪不只是简单地物理材料隔音</p><blockquote><p> 主动降噪的原理在于首先要收集噪音的波型特点，然后<strong>通过内置的处理芯片运算出反相的波，再通过高还原度扬声器相抵消。</strong>所以主动降噪系统必备的设备有拾音器、处理芯片、扬声器，每一个部分都要保证高质量才能达到最终的效果，故成本上就要比传统非降噪设备高。</p></blockquote><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/ce0BPVeFZzz5g.jpg" alt=""></p><p>Bose QC-30 一个特色式支持11档地「可控降噪」，可以满足在不同场景地使用需求。在嘈杂的食堂、公交、地铁上可以将降噪全开。而在需要与人交谈的时候，可以把通过线控的方式将降噪级别降低，当前我还是建议把耳机取下来再与人交谈，一是方便，二是对别人的尊重。</p><p>将降噪开到最高时，即使播放音乐，也会感觉少了很多嘈杂的声音，这些声音在没有戴降噪耳机之前不会有明显的感觉，当我把降噪耳机取下来之后，各种中频、低频的噪音「扑耳而来」，用了降噪耳机之后怕是再也回不去不用降噪耳机的时候了。</p><p>对人声的降噪情况，如果有人在你身边讲话时，还是可以清楚听清说话的声音，但是人声会有明显的变化。</p><p>Bose QC 30 并没有明显的底噪（电流声），如果旁边有手机或其他设备在充电可以听到明显的电流声。如果衣服摩擦耳机的线，会有一点点的听诊器效应。</p><p>如果使用场景有风，QC-30会有很大的风噪音，可能是拾音器又加大风声。</p><p>总的来说，QC30的降噪表现还是延续了Bose家族一如既往的高水准，比市面上很多同类型的降噪耳机效果要更优秀一些。对近距离的高频噪音和人声不能屏蔽掉，但开启降噪再用小音量放一些音乐就可以做好普通耳机需要很大音量才能隔绝噪音的效果。</p><h1 id="音乐表现"><a href="#音乐表现" class="headerlink" title="音乐表现"></a>音乐表现</h1><p>到了玄学的音效的环境，对于音质不是特别敏感的耳朵来说，Bose QC30 的音效还是能过的去的。网上的评测大都说不如 Sony WI-1000x 听感好，我没有自己听过 Sony Wi-1000x ，所以不好下判断。更何况音质这东西见仁见智，耳朵适应一段时间一般都会适应。</p><p>（各频段音乐表现待一段时间的使用之后再补充）</p><h1 id="续航"><a href="#续航" class="headerlink" title="续航"></a>续航</h1><p>官方参数：充满电可以使用10个小时，充满电需要2个小时（实际体验2h20min）</p><hr><p>参考：</p><ul><li><a href="https://www.bose.cn/zh_cn/products/headphones/earphones/quietcontrol-30.html#v=qc30_black" target="_blank" rel="noopener">Bose-QC-30_官方介绍</a></li><li><a href="https://www.bilibili.com/video/av41982410?from=search&amp;seid=13107583089083392405" target="_blank" rel="noopener">平价真无线耳机们到底好用不好用【值不值得买第307期】</a></li><li><a href="http://sound.zol.com.cn/439/4392078.html" target="_blank" rel="noopener">破解”听不见”的秘密 降噪耳机技术浅谈</a></li><li><a href="http://www.52audio.com/archives/14885.html" target="_blank" rel="noopener">BOSE QC30无线消噪耳机体验</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我买的第一款“主动降噪”耳机，本文谈谈对 QC-30 这款产品的使用体验。&lt;/p&gt;
    
    </summary>
    
      <category term="新玩具" scheme="http://yslemmo.github.io/categories/%E6%96%B0%E7%8E%A9%E5%85%B7/"/>
    
    
      <category term="耳机" scheme="http://yslemmo.github.io/tags/%E8%80%B3%E6%9C%BA/"/>
    
      <category term="体验" scheme="http://yslemmo.github.io/tags/%E4%BD%93%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>「故事」读书笔记</title>
    <link href="http://yslemmo.github.io/post/Story-Notes.html"/>
    <id>http://yslemmo.github.io/post/Story-Notes.html</id>
    <published>2019-02-19T10:24:11.000Z</published>
    <updated>2019-03-18T10:49:03.919Z</updated>
    
    <content type="html"><![CDATA[<p>罗伯特·麦基的《故事》中摘录的笔记</p><a id="more"></a><h1 id="Part-1-故事"><a href="#Part-1-故事" class="headerlink" title="Part 1 故事"></a>Part 1 故事</h1><ul><li>故事是人生必需的设备。</li><li>娱乐即使沉浸于故事的仪式之中，达到一种知识上和情感上令人满足的目的。</li><li>凡是优秀的电影、小说、戏剧，都能通过其各不相同的喜剧和悲剧色彩来达到娱乐的目的，给观众一种具有感染力的生活模式。（电子游戏亦是如此）</li><li>故事并不是对现实的逃避，而是一种载体，承载着我们去追寻显示、尽最大的努力挖掘出混乱人生的真谛。</li><li>故事艺术是世界上主导的文化力量，而电影艺术则是这一辉煌事业的主导媒体。</li><li>创作者的技巧并不是什么手艺的东西，只不过是他对所遇到的每一部小说、电影或戏剧中故事要素的无意识吸收。</li><li>创造故事必须深入地挖掘生活，找到新地见解、新版本的价值和意义，然后创造出一个故事载体。</li><li>一个好故事使一部好影片成为可能，如果故事不能成立，那么影片必将成为灾难。</li><li>所有的故事，无论真诚还是虚假，明智还是愚蠢，都会忠实地映现出作者本人，暴露出其人性…..或人性地缺乏。</li><li>每一门艺术都是由其根本形式决定地。故事地普遍形式使其作品成为一个故事，而不是肖像画或艺术拼贴。</li><li>一个作家必须掌握故事形式，但形式并不是“公式”，故事是丰富多彩、纷繁复杂、神妙莫测的。</li></ul><h2 id="故事是生活的比喻"><a href="#故事是生活的比喻" class="headerlink" title="故事是生活的比喻"></a>故事是生活的比喻</h2><ul><li><p>一个讲故事的人即是一个生活诗人，一个艺术家，将日常生活事件、内在生活和外在生活、梦想和现实转化为一首诗，一首以事件而不是以语言作为韵律的诗<br>一个长达两小时的比喻，告诉观众:生活就像是这样！因此，<strong>故事必须抽象于生活，提取其精华，但又不能成为生活的抽象化，以致失却实际生活的原味。故事必须像生活，但又不能一成不变地照搬生活，以致除了市井乡民都能一目了然的生活之外便别无深度和意味。</strong></p></li><li><p>电影美学是表达故事生动内容的手段，其本身绝不能成为目的。</p></li></ul><h1 id="Part-2-：故事的要素"><a href="#Part-2-：故事的要素" class="headerlink" title="Part 2 ：故事的要素"></a>Part 2 ：故事的要素</h1><blockquote><p>​    <strong>节拍</strong>构成场景，<strong>场景</strong>构成序列，<strong>序列</strong>构成幕，<strong>幕</strong>构建成故事，最后达到<strong>高潮</strong>。</p></blockquote><p><code>节拍</code>是场景里面最小的结构成分。</p><p><code>场景</code>是再某一相对连续的时空中，通过冲突表现出来的一段动作，这个动作至少是让人生的生活负荷发生转折。<strong>理想的场景是一个故事事件。</strong></p><p><code>序列</code>是一系列场景——一般是两到五个，每一个场景的冲击力呈递增趋于，直到最后到达顶峰。</p><p><code>幕</code>是一系列序列的组合，以一个高潮场景为顶点，导致价值的重大转折。</p><p><code>高潮</code>：故事是一系列幕的组合，渐次构成一个最后的幕高潮。引发出<strong>绝对不可逆转的变化。</strong></p><p>总结：场景导致较小而有意义的变化，序列中的终结场景的变化更强劲、具有决定性的变化，而幕导致的价值转折比场景和序列中的冲击力更强。场景、序列、幕中的变化都是可以逆转的，但是最后一幕的高潮是不可逆转的。</p><h2 id="故事三角"><a href="#故事三角" class="headerlink" title="故事三角"></a>故事三角</h2><p>故事经典设计：</p><blockquote><p>经典设计是指围绕一个主动主人公构建的故事，主人公为了追求自己的欲望，与主要来自外界的对抗力量进行抗争，通过连续的时间、在一个连贯而具有因果关联的虚构现实里，到达一个表现绝对、而变化不可逆转的闭合式结局。</p></blockquote><p>我们的故事大部分都是这样的经典设计的。被麦基成为<code>大情节</code>故事，但是这种形式并不是故事讲述形态的极限。与之不同的，有<code>小情节</code>和<code>反情节</code>，如图：</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190219205455.png" alt=""></p><p><strong>最小主义</strong>是指作者从经典设计的成分开始，对它们进行削减—对大情节的突出特性进行精炼、浓缩、删节或修剪。<strong>小情节并不意味着无情节</strong>，其故事必须像大情节一样给予精美的处理。确切地说，最小主义的情节处理是要在简约、精炼的前提下保持经典的精华，使影片仍然能够满足观众。</p><p><strong>反情节</strong>是反小说（新小说）和荒诞派戏剧的电影翻版。反结构变体并没有削减经典，而是反其道而行，否认传统形式，以利用甚至嘲弄形式原理的要义。反情节的制造者对欲语还休的描写方法或暗度陈仓式的收敛几乎没有兴趣；相反，为了昭示他的“革命”雄心，他的影片倾向于过度铺陈和自我意识的大肆渲染。</p><h3 id="闭合式结局-VS-开放式结局"><a href="#闭合式结局-VS-开放式结局" class="headerlink" title="闭合式结局 VS 开放式结局"></a>闭合式结局 VS 开放式结局</h3><blockquote><p>如果一个表达绝对而不可逆转变化的故事高潮，回答了故事讲述过程中所提出的所有问题并满足了所有观众情感，则被称为<strong>闭合式结局。</strong></p></blockquote><blockquote><p>一个故事高潮如果留下一两个未解答的问题和一些没被满足的情感，则被称为<strong>开放式结局。</strong></p></blockquote><h3 id="外在冲突-VS-内在冲突"><a href="#外在冲突-VS-内在冲突" class="headerlink" title="外在冲突 VS 内在冲突"></a>外在冲突 VS 内在冲突</h3><blockquote><p>大情节强调<strong>外在冲突</strong>。尽管人物常常具有强烈的内心冲突，但重点却落在他们与人际关系、社会机构或自然界力量的斗争上。</p></blockquote><blockquote><p>在小情节中，主人公也许与家庭、社会和环境具有强烈的外在冲突，但其重点却集结在他与自己思想情感有意或无意的角斗里。(<strong>内在冲突</strong>即内心冲突)</p></blockquote><h3 id="单一主人公-VS-多重主人公"><a href="#单一主人公-VS-多重主人公" class="headerlink" title="单一主人公 VS 多重主人公"></a>单一主人公 VS 多重主人公</h3><blockquote><p>如果是单一主人公，则影片中所有的事件变化都围绕主角。</p></blockquote><blockquote><p>如果作者将影片分解成若干较小的次情节，每一个次情节都有一个单一主人公。</p></blockquote><h3 id="主动主人公-VS-被动主人公"><a href="#主动主人公-VS-被动主人公" class="headerlink" title="主动主人公 VS 被动主人公"></a>主动主人公 VS 被动主人公</h3><blockquote><p><strong>主动主人公</strong>在欲望追求中采取行动时，与他周围的人和世界发生直接冲突。</p></blockquote><blockquote><p><strong>被动主人公</strong>表面消极被动，而在内心追求欲望时，与其自身性格的方方面面发生冲突。</p></blockquote><h3 id="线性时间-VS-非线性时间"><a href="#线性时间-VS-非线性时间" class="headerlink" title="线性时间 VS 非线性时间"></a>线性时间 VS 非线性时间</h3><blockquote><p>无论有无闪回，一个故事的事件如果被安排成一个观众能够跟踪的时间顺序，那么这个故事便是按照线性时间来讲述的。</p></blockquote><blockquote><p>如果一个故事在时间中随意跳跃，从而模糊了时间的连续性，以致观众无从判断什么发生在前什么发生在后，那么这个故事便是按照非线性时间来讲述的。</p></blockquote><h3 id="因果-VS-巧合"><a href="#因果-VS-巧合" class="headerlink" title="因果 VS 巧合"></a>因果 VS 巧合</h3><p>大情节因果性强，反情节常常以巧合代替因果，强调宇宙万物的随意碰撞。</p><h3 id="连贯现实-VS-非连管现实"><a href="#连贯现实-VS-非连管现实" class="headerlink" title="连贯现实 VS 非连管现实"></a>连贯现实 VS 非连管现实</h3><blockquote><p>连贯现实是确立人物及其世界之间互动模式的虚拟背景，在整个讲述过程中，这些互动模式一直保持着连贯性，从而创造出意义。</p></blockquote><blockquote><p>非连贯现实是混合了多种互动模式的背景，其中故事章节不连贯地从一个“现实”跳向另一个“现实”，以营造出一种荒诞感。</p></blockquote><hr><p>未完….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;罗伯特·麦基的《故事》中摘录的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="reading-list" scheme="http://yslemmo.github.io/categories/reading-list/"/>
    
    
      <category term="movie" scheme="http://yslemmo.github.io/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>使用Scrapy爬虫抓取并下载豆瓣图片</title>
    <link href="http://yslemmo.github.io/post/crawl-douban-image-by-scrapy.html"/>
    <id>http://yslemmo.github.io/post/crawl-douban-image-by-scrapy.html</id>
    <published>2019-02-11T11:16:24.000Z</published>
    <updated>2019-03-18T10:49:03.928Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇笔记我直接自己写了一个Python来抓取豆瓣图片，为了让我更加熟悉<code>Scrapy</code>，我又用Scrapy做了一遍。</p><a id="more"></a><h1 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h1><p>直接参考上一篇的目标和网站分析。</p><h1 id="工具分析"><a href="#工具分析" class="headerlink" title="工具分析"></a>工具分析</h1><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211194221.png" alt=""></p><p>需要添加一个自己的下载图片的<code>Item Pipeline</code>。</p><h1 id="爬虫程序"><a href="#爬虫程序" class="headerlink" title="爬虫程序"></a>爬虫程序</h1><h2 id="创建一个新的Scrapy项目"><a href="#创建一个新的Scrapy项目" class="headerlink" title="创建一个新的Scrapy项目"></a>创建一个新的Scrapy项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject db_img_crawler</span><br><span class="line">scrapy genspider dbimg htpp://douban.com</span><br></pre></td></tr></table></figure><h2 id="编写items-py"><a href="#编写items-py" class="headerlink" title="编写items.py"></a>编写items.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImagesItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    image_title = scrapy.Field()  <span class="comment"># 图片的标题</span></span><br><span class="line">    image_url = scrapy.Field()  <span class="comment"># 图片的地址</span></span><br></pre></td></tr></table></figure><h2 id="编写主Spider文件，dbimg-crawler-py"><a href="#编写主Spider文件，dbimg-crawler-py" class="headerlink" title="编写主Spider文件，dbimg_crawler.py"></a>编写主Spider文件，<code>dbimg_crawler.py</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> doubanimg.items <span class="keyword">import</span> ImagesItem</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbimgSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'dbimg'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36'</span>,&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">300</span>,<span class="number">20</span>):</span><br><span class="line">            url = <span class="string">'https://www.douban.com/j/search_photo?q=%E7%8E%8B%E7%A5%96%E8%B4%A4&amp;limit=20&amp;start='</span> + str(i)</span><br><span class="line">            <span class="keyword">yield</span> Request(url,callback=self.parse_one)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_one</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = ImagesItem()</span><br><span class="line">        images = json.loads(response.body.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">        images = images[<span class="string">'images'</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(images)):</span><br><span class="line">            item[<span class="string">'image_title'</span>] = images[i][<span class="string">'title'</span>]</span><br><span class="line">            image_id = images[i][<span class="string">'id'</span>]</span><br><span class="line">            item[<span class="string">'image_url'</span>] = <span class="string">'https://img3.doubanio.com/view/photo/l/public/p'</span>+str(image_id)+<span class="string">'.webp'</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(item)</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><ul><li>直接在<code>start_requeset()</code>中开启循环抓取，方法<code>yield Request</code>，回调给<code>parse_one()</code>抓取每一次的20条数据。</li><li>图片的地址同时是由获取到的id值来组拼成的。</li></ul><h2 id="编辑piepelines-py"><a href="#编辑piepelines-py" class="headerlink" title="编辑piepelines.py"></a>编辑<code>piepelines.py</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"><span class="keyword">from</span> scrapy.exceptions <span class="keyword">import</span> DropItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImagePipeline</span><span class="params">(ImagesPipeline)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span><span class="params">(self, item, info)</span>:</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(item[<span class="string">'image_url'</span>], meta=&#123;<span class="string">'item'</span>:item&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span><span class="params">(self, request, response=None, info=None)</span>:</span></span><br><span class="line">        <span class="comment"># item = response.meta['item']</span></span><br><span class="line">        name = <span class="string">'full/%s'</span> % ((request.url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]).split(<span class="string">'.'</span>,<span class="number">1</span>)[<span class="number">0</span>]) + <span class="string">'.jpg'</span></span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">item_completed</span><span class="params">(self, results, item, info)</span>:</span></span><br><span class="line">        path = [x[<span class="string">'path'</span>] <span class="keyword">for</span> ok,x <span class="keyword">in</span> results <span class="keyword">if</span> ok]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'Item contains no images'</span>)</span><br><span class="line">        print(<span class="string">'Saving img...'</span>,item[<span class="string">'image_url'</span>])</span><br><span class="line">        print(<span class="string">'title'</span>,item[<span class="string">'image_title'</span>])</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>创建自己的Item Pipeline，继承<code>ImagesPipeline</code>(图片管道)，这个管道的特性有：</p><blockquote><ul><li>将所有下载的图片转换成通用的格式（JPG）和模式（RGB）</li><li>避免重新下载最近已经下载过的图片</li><li>缩略图生成</li><li>检测图像的宽/高，确保它们满足最小限制</li></ul></blockquote><p>要下载图片，需要重写<code>get_media_requests()</code>方法，方法内对图片URL返回一个Request。（<em>默认返回None，表示没有图可下载</em>）要想传递item对象可以把它写在request的<code>meta</code>里面。当下载完成之后，由管道接起，传递到<code>item_completed()</code>方法内。</p><p>如果想设置文件的名字，可以重写<code>file_path()</code>，可以通过<code>item = response.meta[&#39;item&#39;]</code>来接受item对象。</p><h2 id="编辑Setting-py"><a href="#编辑Setting-py" class="headerlink" title="编辑Setting.py"></a>编辑Setting.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">设置Header</span><br><span class="line"></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>:<span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>:<span class="string">'gzip, deflate, sdch'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>:<span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Cache-Control'</span>:<span class="string">'max-age=0'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>:<span class="string">'keep-alive'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片存储路径</span></span><br><span class="line">IMAGES_STORE = <span class="string">'D:\\img'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬虫协议</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大Requests数</span></span><br><span class="line">CONCURRENT_REQUESTS = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载延时</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭Cookies</span></span><br><span class="line">COOKIES_ENABLED = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始MyImagePipeline</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'doubanimg.pipelines.MyImagePipeline'</span>: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="启动爬虫程序"><a href="#启动爬虫程序" class="headerlink" title="启动爬虫程序"></a>启动爬虫程序</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl dbimg</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><ul><li><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/images.html" target="_blank" rel="noopener">下载项目图片-scrapy中文文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇笔记我直接自己写了一个Python来抓取豆瓣图片，为了让我更加熟悉&lt;code&gt;Scrapy&lt;/code&gt;，我又用Scrapy做了一遍。&lt;/p&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://yslemmo.github.io/categories/Scrapy/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="Scrapy" scheme="http://yslemmo.github.io/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>抓取豆瓣搜索到的图片</title>
    <link href="http://yslemmo.github.io/post/crawl-douban-image-and-download.html"/>
    <id>http://yslemmo.github.io/post/crawl-douban-image-and-download.html</id>
    <published>2019-02-11T04:01:02.000Z</published>
    <updated>2019-03-18T10:49:03.928Z</updated>
    
    <content type="html"><![CDATA[<p>使用Python抓取和周迅有关的图片并下载到本地。<br><a id="more"></a></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>豆瓣搜索“周迅”的相关图片，并且下载到本地</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211120554.png" alt=""></p><h1 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h1><p>豆瓣图片是通过<code>Ajax</code>动态加载的，按F12打开Chrome浏览器的开发者工具，图片是通过GET来请求的，请求地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;<span class="built_in">limit</span>=20&amp;start=0</span><br></pre></td></tr></table></figure><p>其中：【q=：关键字| limit=：一次请求的数量（修改了也没用） | start=：请求的开始位置（偏移量）】。<br>点开Preview，看到网站给我们发送了一个20个长度的<code>json数据包</code></p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211121129.png" alt=""></p><p>点开第一个，这里面有几个key，我们需要的是图片的<code>url</code>，另外还可以存储图片的<code>title</code>。这里面可以看到有两个url，分别是<code>scr</code>和<code>url</code>。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211122017.png" alt=""></p><p>把它们全部在地址栏打开，发现这个<code>scr</code>链接是图片的缩略图地址，这个<code>url</code>链接是图片post的主页地址。这两个都不是我们想要的，但是可以右键看一下图片的真实地址</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211122906.png" alt=""></p><p>复制出来图片的地址，观察到图片的命名就是上面接受的<code>id值</code>，这样我们就可以通过获取每张图片的id值来组拼出图片的下载地址了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://img3.doubanio.com/view/photo/l/public/p637462204.webp</span><br></pre></td></tr></table></figure><h1 id="完整的爬取"><a href="#完整的爬取" class="headerlink" title="完整的爬取"></a>完整的爬取</h1><p>定义Header，图片的存储地址，保存抓取到的图片item</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dir = <span class="string">'./image'</span>         <span class="comment"># 图片地址</span></span><br><span class="line">imageItemList = []      <span class="comment"># 用列表存储所有的图片item（字典）</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>:<span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>:<span class="string">'gzip, deflate, sdch'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>:<span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Cache-Control'</span>:<span class="string">'max-age=0'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>:<span class="string">'keep-alive'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中"><a href="#获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中" class="headerlink" title="获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中"></a>获取并存储图片的url地址以键值对的方式存储到字典中，并把把所有的item字典追加到列表中</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_url</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取图片的url下载地址</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">300</span>,<span class="number">20</span>):</span><br><span class="line">        url = <span class="string">'https://www.douban.com/j/search_photo?q=%E5%91%A8%E8%BF%85&amp;limit=20&amp;start=0'</span></span><br><span class="line">        response = requests.request(<span class="string">'Get'</span>, url,headers=headers)</span><br><span class="line">        images = json.loads(response.content.decode(<span class="string">'utf-8'</span>))[<span class="string">'images'</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(images)):</span><br><span class="line">            imageItem = &#123;&#125;</span><br><span class="line">            imageItem[<span class="string">'title'</span>] = images[j][<span class="string">'title'</span>]</span><br><span class="line">            id = images[j][<span class="string">'id'</span>]</span><br><span class="line">            imageItem[<span class="string">'url'</span>] = <span class="string">'https://img3.doubanio.com/view/photo/l/public/p'</span>+str(id)+<span class="string">'.webp'</span></span><br><span class="line">            imageItemList.append(imageItem)</span><br></pre></td></tr></table></figure><ul><li>通过For循环获取，<code>range(0,300,20)</code>，表示要获取的图片数量为300张，Sep（步长）为20，因为每次获取的是20条数据。</li><li>通过<code>response.content</code>，获取<code>response</code>返回的内容，之前用<code>response.body</code>提示错误。这个应该是scrapy自己封装的属性。</li><li>通过<code>json.loads()</code>把<code>json对象</code>转换成<code>Python对象</code>，这样方便Python去解析。</li><li>图片的<code>url</code>是通过id值来组拼的。</li></ul><p>从列表获取图片链接并下载图片，然后使用<code>dwebp</code>工具转换图片格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_download</span><span class="params">(url, path)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    下载文件的方法</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_img_from</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    从数组中取出所有图片链接并下载，下载后使用dwebp转换图片格式为png，并删除dwebp源图片</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 判断是否电脑中是否有此目录，如果没有则创建一个空目录</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dir):</span><br><span class="line">        os.mkdir(dir)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> imageItemList:</span><br><span class="line">        url = item[<span class="string">'url'</span>]</span><br><span class="line">        fullpath = dir +<span class="string">'/'</span>+ str(index) + <span class="string">'.webp'</span></span><br><span class="line">        <span class="comment"># 调用下载方法</span></span><br><span class="line">        request_download(url, fullpath)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(<span class="string">'开始转换第'</span>+str(index)+<span class="string">'张图片：'</span>)</span><br><span class="line">            os.system(<span class="string">'dwebp ./image/%d.webp -o ./image/%d.png'</span> %(index,index))</span><br><span class="line">            print(<span class="string">'转换第'</span>+str(index)+<span class="string">'张图片完成.'</span>)</span><br><span class="line">            os.remove(<span class="string">'./image/'</span>+str(index)+<span class="string">'.webp'</span>) <span class="comment">#删除webp格式的图片</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            print(err)</span><br><span class="line">        index += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>从上面的图片item中获取每张图片的<code>url</code>，调用下载方法。</li><li>注意：这里获取下载的图片是<code>webp</code>编码的，需要使用<code>dwebp</code>工具进行转换。</li></ul><blockquote><p>WebP（Google开发），是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，派生自影像编码格式VP8。在同样大小的图片文件中，能比其他格式更加清晰，能提高网页加载速度，减少网络存储。</p></blockquote><h3 id="安装webp工具"><a href="#安装webp工具" class="headerlink" title="安装webp工具"></a>安装webp工具</h3><p>直接在<code>scoop</code>中搜索安装（libwqbp）即可，还可以直接去google的<a href="https://developers.google.com/speed/webp/docs/precompiled" target="_blank" rel="noopener">webp地址</a>去下载安装，安装完成之后，把安装路径里面bin文件夹路径添加到环境变量中去。</p><h3 id="使用webp"><a href="#使用webp" class="headerlink" title="使用webp"></a>使用webp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwebp *.webp -o *.png <span class="comment"># 第一个是webp文件名，第二个是转换后的png文件名。</span></span><br></pre></td></tr></table></figure><h2 id="启动爬虫程序"><a href="#启动爬虫程序" class="headerlink" title="启动爬虫程序"></a>启动爬虫程序</h2><ol><li>先调用爬取路径的方法，再调用下载文件的方法。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    get_img_url()</span><br><span class="line">    download_img_from()</span><br></pre></td></tr></table></figure><ol start="2"><li>启动爬虫</li></ol><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190211190516.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Python抓取和周迅有关的图片并下载到本地。&lt;br&gt;
    
    </summary>
    
      <category term="clawl" scheme="http://yslemmo.github.io/categories/clawl/"/>
    
    
      <category term="python" scheme="http://yslemmo.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用Item Pipeline把Scrapy爬取的数据存储到MongoDB</title>
    <link href="http://yslemmo.github.io/post/Scrapy-To-MongoDB-By-Pipeline.html"/>
    <id>http://yslemmo.github.io/post/Scrapy-To-MongoDB-By-Pipeline.html</id>
    <published>2019-02-08T09:45:13.000Z</published>
    <updated>2019-02-11T13:26:52.911Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>Item Pipeline(项目管道)</code>来保存使用Scrapy爬取的item对象</p><a id="more"></a><h2 id="Pipeline是什么"><a href="#Pipeline是什么" class="headerlink" title="Pipeline是什么"></a>Pipeline是什么</h2><blockquote><p>当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。</p><p>每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。 ——<a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html" target="_blank" rel="noopener">Scrapy Doc</a></p></blockquote><p>item pipeline的功能：</p><ul><li>清理HTML数据</li><li>验证爬取的数据(检查item包含某些字段)</li><li>查重(并丢弃)</li><li><strong>将爬取结果保存到数据库中</strong></li></ul><h2 id="在pipeline-py中编写MongoDBPipeline"><a href="#在pipeline-py中编写MongoDBPipeline" class="headerlink" title="在pipeline.py中编写MongoDBPipeline"></a>在pipeline.py中编写MongoDBPipeline</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Item</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonoDBPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将item写入到MongoDB中</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="comment"># 访问配置文件取mongodb的url和name，如果没有则使用默认值</span></span><br><span class="line">        cls.DB_URL = crawler.settings.get(<span class="string">'MONGO_DB_URI'</span>, <span class="string">'mongodb://localhost:27017'</span>)</span><br><span class="line">        cls.DB_NAME = crawler.settings.get(<span class="string">'MONGO_DB_NAME'</span>, <span class="string">'scrapy_data'</span>)</span><br><span class="line">        <span class="keyword">return</span> cls()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client = pymongo.MongoClient(self.DB_URL)</span><br><span class="line">        self.db = self.client[self.DB_NAME]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        collection = self.db[spider.name]</span><br><span class="line">        <span class="comment"># 三元表达式（调用前先对item的类型进行判断，如果item是Item对象，就将其转换为字典)</span></span><br><span class="line">        post = dict(item) <span class="keyword">if</span> isinstance(item, Item) <span class="keyword">else</span> item </span><br><span class="line">        collection.insert_one(post)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="from-crawler-cls-crawler"><a href="#from-crawler-cls-crawler" class="headerlink" title="from_crawler(cls, crawler)"></a>from_crawler(cls, crawler)</h3><blockquote><p>如果存在，则调用这个类方法来从爬行器创建管道实例。它必须返回管道的新实例。爬虫对象提供对所有Scrapy核心组件的访问，如设置和信号；它是管道访问这些组件并将其功能挂钩到Scrapy的一种方式。</p></blockquote><ul><li><p>cls（item pipeline类）（如果创建<code>MongoDBPipeline类</code>就为<code>MongoDBPipeline类对象</code></p></li><li><p>crawler（Crawlerobject） - 使用此管道的crawler（可以通过<code>crawler.settings</code>访问该配置<code>setting.py</code>文件）</p></li></ul><h3 id="open-spider-amp-close-spider"><a href="#open-spider-amp-close-spider" class="headerlink" title="open_spider() &amp; close_spider()"></a>open_spider() &amp; close_spider()</h3><p>在Spider整个爬取过程中，数据库的连接和关闭操作只需要进行一次，应在开始处理数据之前连接数据库，并在处理完所有数据之后关闭数据库，因此实现以下两个方法(在Scrapy打开和关闭时被调用)。</p><h3 id="process-item-self-item-spider"><a href="#process-item-self-item-spider" class="headerlink" title="process_item(self, item, spider)"></a>process_item(self, item, spider)</h3><blockquote><p>每个项目管道组件是一个Python类，<strong>必须实现</strong>以下方法： <code>process_item(self, item, spider)</code>；</p><p>对于每个项目管道组件调用此方法。process_item() 必须：返回一个带数据的dict，返回一个Item （或任何后代类）对象，返回一个Twisted Deferred或者raise DropItemexception。</p></blockquote><p>在process_item中实现MongoDB数据库的写入操作，使用self.db和spider.name获取一个集合(collection)，然后将数据插入该集合。</p><h2 id="在配置文件中配置MongoDB的url和name"><a href="#在配置文件中配置MongoDB的url和name" class="headerlink" title="在配置文件中配置MongoDB的url和name"></a>在配置文件中配置MongoDB的url和name</h2><p>打开<code>Setting.py</code>在任何位置写入（<em>如果不写则默认使用MongoPipeLine.from_crwaler()中的信息</em>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MONGO_DB_URI = <span class="string">'mongodb://localhost:27017'</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">'python_ZhuanLan'</span></span><br></pre></td></tr></table></figure><h2 id="启动MongoPipeline组件"><a href="#启动MongoPipeline组件" class="headerlink" title="启动MongoPipeline组件"></a>启动MongoPipeline组件</h2><p>打开<code>Setting.py</code>，把MongoPipeline添加到<code>ITEM_PIPELINES</code>中，后面的数字代表它们的运算优先级（顺序），item按数字从低到高的顺序，通过pipeline（1-1000，数字越低组件的优先级越高）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">      <span class="string">'zhihu_Crawl.pipelines.MonoDBPipeline'</span>:<span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考资料：</strong></p><ul><li><a href="https://www.jianshu.com/p/3a3da0272262" target="_blank" rel="noopener">Scrapy使用Pipeline写入MongoDB</a></li><li><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/item-pipeline.html#id2" target="_blank" rel="noopener">Scrapy中文文档-Item Pipeline</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;Item Pipeline(项目管道)&lt;/code&gt;来保存使用Scrapy爬取的item对象&lt;/p&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://yslemmo.github.io/categories/Scrapy/"/>
    
    
      <category term="Crawler" scheme="http://yslemmo.github.io/tags/Crawler/"/>
    
      <category term="MongoDB" scheme="http://yslemmo.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>使用Scrapy遇到的问题汇总</title>
    <link href="http://yslemmo.github.io/post/The-Problem-Collection-Use-Scrapy.html"/>
    <id>http://yslemmo.github.io/post/The-Problem-Collection-Use-Scrapy.html</id>
    <published>2019-02-07T12:31:32.000Z</published>
    <updated>2019-03-18T10:49:03.928Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下，自己再安装和使用Scrapy框架过程中遇到的各种问题及解决办法<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用环境：Win10 1803、Python 3.6.3</p><p>利用pip命令可以直接安装<code>Scrapy</code>，但是会出现一些安装包装不上而报错，比如Twisted。可以先去这个<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">Pyhton Extension Packages</a>下载<code>Twisted</code>到本地，然后单独安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install twisted</span><br></pre></td></tr></table></figure><p>（注意要下载<code>Twisted‑18.9.0‑cp36‑cp36m‑win_amd64.whl</code>不要下载错了，是cp36。否则安装的时候会提示<code>is not a supported wheel on this platform</code>）</p><h2 id="Scrapy输出文件编码为’utf-8’"><a href="#Scrapy输出文件编码为’utf-8’" class="headerlink" title="Scrapy输出文件编码为’utf-8’"></a>Scrapy输出文件编码为’utf-8’</h2><p>在编写爬虫中文内容输出到<code>*.json</code>文件后发现中文是<code>Unicode编码</code>，尝试了各种方法测试都不成功，后来找到一种方法终于成功了，把Scrapy项目文件夹中的<code>Setting.py</code>增加一行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEED_EXPORT_ENCODING = <span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure><h2 id="Scrapy导出csv文件乱码"><a href="#Scrapy导出csv文件乱码" class="headerlink" title="Scrapy导出csv文件乱码"></a>Scrapy导出csv文件乱码</h2><p>使用<code>Vscode的通过编码重新保存</code>，将文件的编码格式改为<code>UTF-8 with BOM</code>，再重新用Excel打开csv就正常了。</p><ul><li>参考：<a href="https://blog.csdn.net/u011361138/article/details/79912895" target="_blank" rel="noopener">https://blog.csdn.net/u011361138/article/details/79912895</a></li></ul><h2 id="Scrapy异常：http-status-code-is-not-handled-or-allowed"><a href="#Scrapy异常：http-status-code-is-not-handled-or-allowed" class="headerlink" title="Scrapy异常：http status code is not handled or allowed"></a>Scrapy异常：http status code is not handled or allowed</h2><p>原因是http状态码没有被识别，需要在settings.py中添加这个状态码信息，同样在<code>Setting.py</code>添加一行（如果是404错误就改为404，如果是400错误，就改成400：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTPERROR_ALLOWED_CODES = [状态码]</span><br><span class="line">HTTPERROR_ALLOWED_CODES = [404]</span><br><span class="line">HTTPERROR_ALLOWED_CODES = [400]</span><br></pre></td></tr></table></figure><p>另一种方法是在<code>Spider</code>函数中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">handle_httpstatus_list = [404]</span><br><span class="line">handle_httpstatus_list = [400]</span><br></pre></td></tr></table></figure><hr><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/20190208160126.png" alt=""></p><p>如果还是出现<code>400错误</code>问题，我观察到后面的Debug信息是：*/robots.txt。</p><blockquote><p><strong>robots.txt（爬虫协议)</strong>是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。——<a href="https://zh.wikipedia.org/wiki/Robots.txt" target="_blank" rel="noopener">wiki</a></p><ul><li>知乎robots地址：<a href="https://www.zhihu.com/robots.txt" target="_blank" rel="noopener">https://www.zhihu.com/robots.txt</a></li><li>淘宝robots地址：<a href="https://www.taobao.com/robots.txt" target="_blank" rel="noopener">https://www.taobao.com/robots.txt</a></li></ul></blockquote><p>总结来说这个爬虫协议允许爬虫机器爬取的范围，不过这个协议属于君子协议，Scrapy默认是遵循<code>robot协议</code>，需要在<code>Setting.py</code>中改变<code>ROBOTSTXT_OBEY</code>的值为<code>False</code>。</p><p>在做了上面的设置之后还是400错误，可以给Reaqueset请求添加一个<code>Headers</code>头部，可以让爬虫伪装成浏览器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">    url = <span class="string">'http://www.hnfnu.edu.cn/index/xyxw/342.htm'</span>  <span class="comment"># 这样就不要设置Start_urls变量了</span></span><br><span class="line">    <span class="keyword">yield</span> Request(url, headers=self.headers)</span><br></pre></td></tr></table></figure><p>不过在我今天在爬去知乎专栏的文章（Ajax加载），调试了很久也只能抓取到第一次加载的列表内容，检查了后面的<code>yiled Requeset(url, callback=self.parse)</code> 设置没有问题，然后我把<code>Headers信息</code>添加在<code>Setting.py</code>中问题就解决了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">  <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>未完待补充……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录一下，自己再安装和使用Scrapy框架过程中遇到的各种问题及解决办法&lt;br&gt;
    
    </summary>
    
      <category term="Scrapy" scheme="http://yslemmo.github.io/categories/Scrapy/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="Debug" scheme="http://yslemmo.github.io/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>Xlua热补丁修复</title>
    <link href="http://yslemmo.github.io/post/xlua-hotfix.html"/>
    <id>http://yslemmo.github.io/post/xlua-hotfix.html</id>
    <published>2018-05-10T12:51:14.000Z</published>
    <updated>2019-03-18T10:49:03.916Z</updated>
    
    <content type="html"><![CDATA[<p>使用xlua热补丁修复</p><a id="more"></a><p>在使用Ulua方法进行热更新的时候，在项目的开发阶段就必要用独立的Lua脚本实现，这样才能使用Ulua来进行热更新，但是如果一个项目完成之后发现需要进行热更新，这个时候用ULua就非常不方便了。但是XLua可以解决这个问题，解决方案就是<strong>“HotFix”热补丁</strong>。（对项目进行修补）实现方式：</p><blockquote><p>对要进行“修补”的C#类，在该类的头部[Hotfix]标签来标记，对于已经使用了<code>[hotfix]</code>标记了的类，可以通过“Lua”代码修改“类中的方法”。</p></blockquote><h1 id="使用HotFix进行热修复"><a href="#使用HotFix进行热修复" class="headerlink" title="使用HotFix进行热修复"></a>使用HotFix进行热修复</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="添加宏信息"><a href="#添加宏信息" class="headerlink" title="添加宏信息"></a>添加宏信息</h3><blockquote><p>File–&gt; Build Settings… –&gt; Player Settings… –&gt; Configuration：Scripting Define Symbols：HOTFIX_ENABLE；（对于每一个平台都需要添加这条宏信息！）</p></blockquote><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/29613175.jpg" alt=""></p><h3 id="执行菜单生成命令"><a href="#执行菜单生成命令" class="headerlink" title="执行菜单生成命令"></a>执行菜单生成命令</h3><p><strong>XLua-&gt;Generate Code</strong>，该命令执行完毕后会生成一堆Wrap 文件，存放到XLua/Gen 文件夹下。</p><h3 id="执行菜单注入命令"><a href="#执行菜单注入命令" class="headerlink" title="执行菜单注入命令"></a>执行菜单注入命令</h3><p><strong>XLua-&gt;Hotfix Inject In Editor</strong>，成功之后，会在控制台输出：“hotfix inject finish!”或者“had injected!”。</p><ul><li>如果出现红色警告提示“please install the Tools”，就需要把Tools 文件夹拷贝到项目中，和Assets 文件夹同级别位置。</li><li>只要修改过C#中的代码，就需要重新执行注入命令！（否则会报错）</li></ul><h1 id="HotFix热修复案例"><a href="#HotFix热修复案例" class="headerlink" title="HotFix热修复案例"></a>HotFix热修复案例</h1><h2 id="Hotfix语法"><a href="#Hotfix语法" class="headerlink" title="Hotfix语法"></a>Hotfix语法</h2><ul><li>引入命名空间：<code>using Xlua;</code></li><li>对要进行热修复的C#类用【hotfix】标记</li><li>编写hotfix命令：<code>xlua.hotfix(CS.类名, &#39;方法名&#39;, lua 方法)</code>（对于CS.类中的某个方法使用lua方法修复）</li><li>创建XLua虚拟机对象（Lua解析器），使用Dostring方法执行。</li></ul><h2 id="修复案例"><a href="#修复案例" class="headerlink" title="修复案例"></a>修复案例</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Hotfix</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotFixDemo</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LuaEnv luaEnv;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> hotfixStrOne = <span class="string">@"</span></span><br><span class="line"><span class="string">        xlua.hotfix(CS.HotFixDemo, 'Hello', function()</span></span><br><span class="line"><span class="string">            print('Lua Hello~~')    </span></span><br><span class="line"><span class="string">        end)</span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> hotfixStrTwo = <span class="string">@"</span></span><br><span class="line"><span class="string">        xlua.hotfix(CS.HotFixDemo, 'Add', function(self, a, b)</span></span><br><span class="line"><span class="string">            print('Lua中的乘法:' .. a*b)</span></span><br><span class="line"><span class="string">        end)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        luaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.A))&#123;</span><br><span class="line">            Hello();</span><br><span class="line">            Add(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))&#123;</span><br><span class="line">            luaEnv.DoString(hotfixStrOne);</span><br><span class="line">            luaEnv.DoString(hotfixStrTwo);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"C# Hello~~"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"C#中的加法："</span> + (a + b));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参方法修复时，需要传递当前脚本对象this，在lua 中用self 代替。</li><li>要修复无参的方法，但是那个方法内使用到了该类中的字段，如果想要在Lua代码中方法到，有两种方法：<ol><li>C#类中的字段公开（使用Public修饰），在lua代码中通过<code>self.字段名</code>的方式来方法（破坏了C#语言的“封装性”）</li><li>在lua 语言中，使用代码获取C#类中private 成员的访问权<code>xlua.private_accessible(CS.类名)</code>，这样就可以在Lua 脚本中访问到C#类当中的私有成员，同时不会破坏C#原有的封装性和逻辑关系。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用xlua热补丁修复&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://yslemmo.github.io/categories/Unity/"/>
    
    
      <category term="热更新" scheme="http://yslemmo.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="xLua" scheme="http://yslemmo.github.io/tags/xLua/"/>
    
      <category term="Untiy" scheme="http://yslemmo.github.io/tags/Untiy/"/>
    
  </entry>
  
  <entry>
    <title>SimpleFrameWork框架简单介绍</title>
    <link href="http://yslemmo.github.io/post/SimpleFrameWork-Introduction.html"/>
    <id>http://yslemmo.github.io/post/SimpleFrameWork-Introduction.html</id>
    <published>2018-05-07T07:18:19.000Z</published>
    <updated>2019-03-18T10:49:03.919Z</updated>
    
    <content type="html"><![CDATA[<p>SimpleFramework的框架介绍<br><a id="more"></a></p><h1 id="SimpleFramework-框架"><a href="#SimpleFramework-框架" class="headerlink" title="SimpleFramework 框架"></a>SimpleFramework 框架</h1><p>SimpleFramework 框架是ULua的集成开发环境</p><ul><li>SimpleFramework     框架官网地址： <a href="http://www.ulua.org/index.html" target="_blank" rel="noopener">http://www.ulua.org/index.html</a></li><li>SimpleFramework 分为两个版本：NGUI 版和UGUI 版，区别是NGUI 版本的框架资源中含有NGUI 这个插件。</li></ul><h1 id="SimpleFramework-和ULua和Lua的关系"><a href="#SimpleFramework-和ULua和Lua的关系" class="headerlink" title="SimpleFramework 和ULua和Lua的关系"></a>SimpleFramework 和ULua和Lua的关系</h1><p>ULua是对原生Lua 环境进行了一次“包装”，用于满足Unity 环境下的热更新需求。为了更方便的使用，于是又对ULua进行“二次包装”，包装成了一个框架：SimpleFramework，比如它们创建Lua的解析器对象都不相同。</p><ul><li>Lua：<code>Lua lua = New Lua();</code></li><li>Ulua：<code>LuaState Lua = new LuaState();</code></li><li>SimpleFramework:<code>LuaScriptMgr lua = new LuaScriptMgr();</code></li></ul><p>它们的关系是：<code>SimpleFramework</code> &gt; <code>ULua</code> &gt; <code>Lua</code></p><h1 id="SimpleFramework框架资源结构"><a href="#SimpleFramework框架资源结构" class="headerlink" title="SimpleFramework框架资源结构"></a>SimpleFramework框架资源结构</h1><ul><li><code>Examples</code>：SimpleFramework 热更新案例；</li><li><code>Lua</code>：SimpleFramework 框架自带的Lua 源码文件；（自己写的Lua脚本放在这个路径）</li><li><code>NGUI</code>：NGUI3.8.2，当你需用更高版本的NGUI 时，替换即可，不需要碰；</li><li><code>Plugins</code>：uLua 运行所依赖的底层库文件，不需要碰；</li><li><code>Scripts</code>：SimpleFramework 自带的C#脚本文件；</li><li><code>uLua</code>：uLua 全部代码。</li></ul><p>和Ulua紧密相关的是：<code>Plugins</code>、<code>uLua</code>。和SimpleFramework相关的是：<code>Examples</code>、<code>Lua</code>、<code>Scripts</code></p><h1 id="使用框架"><a href="#使用框架" class="headerlink" title="使用框架"></a>使用框架</h1><h2 id="框架自带的编辑器命令"><a href="#框架自带的编辑器命令" class="headerlink" title="框架自带的编辑器命令"></a>框架自带的编辑器命令</h2><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/71191708.jpg" alt=""></p><h3 id="Lua菜单：uLua-环境相关处理命令-必备操作"><a href="#Lua菜单：uLua-环境相关处理命令-必备操作" class="headerlink" title="Lua菜单：uLua 环境相关处理命令(必备操作)"></a>Lua菜单：uLua 环境相关处理命令(必备操作)</h3><ul><li><p>Gen Lua Wrap Files：生成LuaWrap文件</p><p>该命令用于生成“Lua 包装文件”，存放在<strong>uLua\Source\LuaWrap</strong> 目录下。该文件夹下全部是C#脚本，这些脚本文件的名称特点是：脚本名+ Wrap；该文件夹下的脚本对Unity 内常用组件脚本的二次包装，、</p><p>Lua 环境运行后，会把这些Wrap 文件加载到Lua 运行环境(Lua 虚拟机)中，最终的效果就是：Lua 调用Wrap 文件，Wrap 文件调用C#，来实现Lua 调用C#。</p></li><li><p>Clear Lua….. Wrap Files：清除LuaWrap文件，也可以自己手动删除。</p></li></ul><h3 id="Game菜单：Build-xxxx-生成不同平台的AssetBundle-资源-必备操作"><a href="#Game菜单：Build-xxxx-生成不同平台的AssetBundle-资源-必备操作" class="headerlink" title="Game菜单：Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]"></a>Game菜单：Build xxxx [生成不同平台的AssetBundle 资源(必备操作)]</h3><p>Game–&gt;Build Windows Resource 生成Windows 平台下的AB 文件。生成后的AB 会存放到StreamingAssets 文件夹下。在生成的过程中同时还会把Lua 文件夹下的所有脚本拷贝到该目录，存放到lua 文件夹下。</p><p>在<code>\Assets\uLua\Editor\Packager.cs</code>脚本中的<code>HandleLuaFile方法</code>就是将<code>/Lua/</code>文件复制到<code>/StreamingAssets/</code>文件夹中（这是本地Server设置的资源的地址，模拟服务器的资源地址）</p><h1 id="Lua-文件夹结构分析"><a href="#Lua-文件夹结构分析" class="headerlink" title="Lua 文件夹结构分析"></a>Lua 文件夹结构分析</h1><ul><li>3rd：第三方的Lua 脚本插件；</li><li>Common：公共Lua 文件目录；</li><li>Controller：控制器目录；</li><li>Logic：管理器目录；</li><li>System：cstolua 的系统目录；</li><li>View：视图层目录。</li></ul><h1 id="ULua-文件夹结构"><a href="#ULua-文件夹结构" class="headerlink" title="ULua 文件夹结构"></a>ULua 文件夹结构</h1><p>SimpleFramework 框架项目的核心是uLua，在Unity 环境下使用uLua可以实现Lua 脚本与Unity 内C#脚本的交互，通过Lua 脚本来操作Unity3D内的各种游戏组件。</p><ul><li>Core：uLua 核心；</li><li>Docs：uLua 文档，其实就是LuaInterface 的PDF 使用文档；</li><li>Editor：uLua 编辑器扩展；<br>[备注：项目内所有的Editor 文件夹都是编辑器扩展文件夹，并不局限于根目录]</li><li>Examples：uLua 自带演示案例；</li><li>Source：cstolua 核心目录。</li></ul><h1 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h1><p>参考：擅码网Lua热更新文档资料</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SimpleFramework的框架介绍&lt;br&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://yslemmo.github.io/categories/Unity/"/>
    
      <category term="Lua" scheme="http://yslemmo.github.io/categories/Unity/Lua/"/>
    
    
      <category term="Unity" scheme="http://yslemmo.github.io/tags/Unity/"/>
    
      <category term="ULua" scheme="http://yslemmo.github.io/tags/ULua/"/>
    
      <category term="SimpleFramework" scheme="http://yslemmo.github.io/tags/SimpleFramework/"/>
    
  </entry>
  
  <entry>
    <title>SimpleFramwork框架下Ulua与C#的交互</title>
    <link href="http://yslemmo.github.io/post/Ulua-And-Charp-Communicate.html"/>
    <id>http://yslemmo.github.io/post/Ulua-And-Charp-Communicate.html</id>
    <published>2018-05-07T07:09:54.000Z</published>
    <updated>2019-02-11T13:31:05.384Z</updated>
    
    <content type="html"><![CDATA[<p>在SimpleFramwork框架下，Ulua与C#的交互！</p><a id="more"></a><h1 id="uLua环境下与C-交互（基本操作）"><a href="#uLua环境下与C-交互（基本操作）" class="headerlink" title="uLua环境下与C#交互（基本操作）"></a>uLua环境下与C#交互（基本操作）</h1><p>在C#与Lua进行交互需要两个DLL文件来实现分别是<code>Luainterface.dll</code>（C#脚本使用Lua）、<code>luanet.dll</code>(Lua脚本调用C#)。因此需要事先把那两个DLL文件拷贝到项目路径中去，再引用。</p><p>在uLua 环境下本质也是通过LuaInterface 来实现Lua 与C#语言交互的。但是uLua 对LuaInterface 进行了二次的封装，不需需要自己手动拷贝这个DLL文件，但是的使用的使用还是要引入命名空间：<code>using LuaInterface;</code></p><h2 id="Lua-代码与Unity-内的类的交互-反射方式-原生方式"><a href="#Lua-代码与Unity-内的类的交互-反射方式-原生方式" class="headerlink" title="Lua 代码与Unity 内的类的交互[反射方式/ 原生方式]"></a>Lua 代码与Unity 内的类的交互[反射方式/ 原生方式]</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个字符串变量保存Lua代码（调用C#的类和方法来创建了一个游戏物体，并给它添加了一个“BoxCollider”组件）    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> str1 = <span class="string">@"</span></span><br><span class="line"><span class="string">    luanet.load_assembly('UnityEngine')</span></span><br><span class="line"><span class="string">    GameObject = luanet.import_type('UnityEngine.GameObject')</span></span><br><span class="line"><span class="string">    BoxCollider = luanet.import_type('UnityEngine.BoxCollider')</span></span><br><span class="line"><span class="string">    local player = GameObject('Lemmo')</span></span><br><span class="line"><span class="string">    player:AddComponent(luanet.ctype(BoxCollider))</span></span><br><span class="line"><span class="string">    "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Lua解析器对象，并执行上面定义的Lua脚本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        LuaState lua = <span class="keyword">new</span> LuaState();</span><br><span class="line">        lua.DoString(str1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>luanet 已经被封装到了LuaInterface 命名空间内，所以我们可以在Lua代码中直接使用luanet 这个对象；</li><li>在Lua 环境内操作C#中的类创建对象，不要写new 关键字！</li><li>在Lua 环境内操作C#中的类创建对象，访问对象中的方法使用分号（:）；</li><li><p>这种“反射方式”在项目开发中并不常用，但是也有用无之地，真正大量使用的是下方的Wrap 方式。</p></li><li><p>同样需要在C#代码中引入LuaInterface；</p></li><li>原生的Lua 解析器对象“Lua”被二次封装成了“LuaState”；</li><li>LuaState 类存在的位置是：uLua\Core\Lua.cs。</li></ul><h2 id="Lua-代码与Unity-内的类的交互-Wrap-方式"><a href="#Lua-代码与Unity-内的类的交互-Wrap-方式" class="headerlink" title="Lua 代码与Unity 内的类的交互[Wrap 方式]"></a>Lua 代码与Unity 内的类的交互[Wrap 方式]</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 和Str1的功能类似，只不过str2使用了Wrap的方式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> str2 = <span class="string">@"</span></span><br><span class="line"><span class="string">    luanet.load_assembly('UnityEngine')</span></span><br><span class="line"><span class="string">    GameObject = UnityEngine.GameObject</span></span><br><span class="line"><span class="string">    BoxCollider = UnityEngine.BoxCollider</span></span><br><span class="line"><span class="string">    local player = GameObject('WrapLemmo')</span></span><br><span class="line"><span class="string">    player:AddComponent(BoxCollider.GetClassType())</span></span><br><span class="line"><span class="string">        "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        LuaScriptMgr lua = <span class="keyword">new</span> LuaScriptMgr();</span><br><span class="line">        lua.Start();</span><br><span class="line">        lua.DoString(str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p>这种是在uLua 开发过程中最常用的方式，95%+情况都是使用这种方式；</p></li><li><p>Wrap 方式实现Lua 调用C#，依赖的是之前生成的LuaWrap 文件；</p><p>[也就是我们通过菜单自动生成到<strong>uLua\Source\LuaWrap</strong> 下的脚本文件]</p></li><li><p>当使用Wrap 方式时，运行Lua 代码需要使用LuaScriptMgr；</p></li><li><p>需要把AppConst.cs 脚本中的的DebugMode 修改为true。</p></li></ul><h2 id="包装新的Wrap-脚本"><a href="#包装新的Wrap-脚本" class="headerlink" title="包装新的Wrap 脚本"></a>包装新的Wrap 脚本</h2><p>当我们用Lua 的Wrap 方式访问Unity 中的组件脚本，或者自己写的脚本的使用，如果这些脚本没有自动生成“xxxxWrap”,项目运行后，就会报错。比如在用Wrap的方式给Player对象通过Lua添加<code>Animator</code>组件的时候，就会报错.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animator = UnityEngine.Animator </span><br><span class="line">player:AddComponent(Animator.GetClassType())</span><br></pre></td></tr></table></figure><p>解决办法：往框架内添加需要处理的新的类。</p><ol><li>找到uLua\Editor\WrapFile.cs 打开该脚本，使用该格式进行添加：_GT(typeof(类名)) ；</li><li>Lua–&gt;Clear LuaBinder File + Wrap File 清空原有的Wrap 文件；</li><li>Lua–&gt;Gen Lua Wrap Files 重新生成Wrap 文件；</li></ol><h1 id="关于Lua使用“-”和“-”来调用属性和方法"><a href="#关于Lua使用“-”和“-”来调用属性和方法" class="headerlink" title="关于Lua使用“.”和“:”来调用属性和方法"></a>关于Lua使用“.”和“:”来调用属性和方法</h1><p>在Lua语言中，直接调用操作C#中的对象的方法和属性直接使用“.”来调用，如果是在Lua代码中实例化出来的对象，再调用这个对象的方法则需要用“:”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在SimpleFramwork框架下，Ulua与C#的交互！&lt;/p&gt;
    
    </summary>
    
      <category term="Lua - Ulua" scheme="http://yslemmo.github.io/categories/Lua-Ulua/"/>
    
    
      <category term="Unity" scheme="http://yslemmo.github.io/tags/Unity/"/>
    
      <category term="Lua" scheme="http://yslemmo.github.io/tags/Lua/"/>
    
      <category term="热更新" scheme="http://yslemmo.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="SimpleFramwork" scheme="http://yslemmo.github.io/tags/SimpleFramwork/"/>
    
  </entry>
  
  <entry>
    <title>Lua与Charp交互</title>
    <link href="http://yslemmo.github.io/post/lua-with-csharp.html"/>
    <id>http://yslemmo.github.io/post/lua-with-csharp.html</id>
    <published>2018-04-24T11:33:39.000Z</published>
    <updated>2019-03-18T10:49:03.915Z</updated>
    
    <content type="html"><![CDATA[<p>Lua与C#的交互<br><a id="more"></a></p><h1 id="Lua与C-进行交互"><a href="#Lua与C-进行交互" class="headerlink" title="Lua与C#进行交互"></a>Lua与C#进行交互</h1><p>在项目中，C#语言是主语言，Lua 语言是辅助语言，如何才能让两门语言的代码互相访问那？这时候我们需要一座“桥梁”来连接两门语言。</p><h2 id="LuaInterface"><a href="#LuaInterface" class="headerlink" title="LuaInterface"></a>LuaInterface</h2><p>LuaInterface 就是C#与Lua 语言相连的那座桥梁。LuaInterface 是一个开源的项目工程，内部有两个核心的DLL 文件：</p><ul><li><code>LuaInterface.dll</code>：在C#代码中操作Lua 代码需要依赖该文件；</li><li><code>luanet.dll</code>：在Lua 代码中访问C#的类库脚本需要依赖该文件。</li></ul><h2 id="在项目中配置使用Lua环境"><a href="#在项目中配置使用Lua环境" class="headerlink" title="在项目中配置使用Lua环境"></a>在项目中配置使用Lua环境</h2><ol><li>将两个dll 文件拷贝到项目工程中；</li><li>项目工程设置“引用”导入LuaInterface.dll；</li><li>将两个dll 的属性都设置成“如果较新则复制”（非常重要，如果不引用则会报错）</li></ol><h2 id="使用lua解析器对象"><a href="#使用lua解析器对象" class="headerlink" title="使用lua解析器对象"></a>使用lua解析器对象</h2><ol><li>引入<code>using LuaInterface;</code>命名空间；</li><li>实例化<code>lua解析器对象</code>：<code>Lua lua = new Lua()</code>；</li><li>使用lua解析器对象的一些方法。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> LuaInterface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LuaThree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line">            lua.DoString(<span class="string">"print('This is Lua program')"</span>); <span class="comment">// 这里执行的是Lua代码</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-中Lua代码空间分析"><a href="#C-中Lua代码空间分析" class="headerlink" title="C#中Lua代码空间分析"></a>C#中Lua代码空间分析</h3><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/96335950.jpg" alt=""></p><p>实际上，虽然C#代码和Lua代码是在一个脚本文件中，但是在程序执行的时候，lua代码（上面第11代码是放到了Lua的那块空间去的）</p><h1 id="C-调用Lua代码"><a href="#C-调用Lua代码" class="headerlink" title="C#调用Lua代码"></a>C#调用Lua代码</h1><h2 id="C-内执行lua代码"><a href="#C-内执行lua代码" class="headerlink" title="C#内执行lua代码"></a>C#内执行lua代码</h2><p>语法：<code>Lua解析器对象.DoString(&quot;Lua代码&quot;)</code></p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 变量的声明与访问；</span></span><br><span class="line">lua.DoString(<span class="string">"name = 'YangJie' age = 19 gender = 'Man' address = 'HuNan'"</span>);</span><br><span class="line">Console.WriteLine(lua[<span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. for循环语句；[演示@符号的用途]</span></span><br><span class="line">lua.DoString(<span class="string">@"for i = 1,10,1 do</span></span><br><span class="line"><span class="string">                print(i) </span></span><br><span class="line"><span class="string">            end</span></span><br><span class="line"><span class="string">            "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 函数的定义与调用；</span></span><br><span class="line">lua.DoString(<span class="string">@"function Show()</span></span><br><span class="line"><span class="string">                print('Show LuaFunction in Csharp.');</span></span><br><span class="line"><span class="string">             end</span></span><br><span class="line"><span class="string">            Show()"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. table 数组声明</span></span><br><span class="line">lua.DoString(<span class="string">@" MyArray = &#123;'AAA', 'BBB', 'CCC'&#125;"</span>);</span><br></pre></td></tr></table></figure><h2 id="C-中调用外部的Lua脚本"><a href="#C-中调用外部的Lua脚本" class="headerlink" title="C#中调用外部的Lua脚本"></a>C#中调用外部的Lua脚本</h2><p>在实际的时候中，大都汇直接调用外部的Lua脚本</p><p><strong>语法：</strong><code>Lua解析器对象.DoFile(&quot;[path]fileName.lua&quot;)</code>方法。</p><blockquote><p><strong>创建Lua脚本文件：</strong>添加-&gt;新建项-&gt;常规-&gt;文本文件，改名且后缀写为.lua;（注意要用其他的编辑器把编码格式从“UTF-8 BOM”改成 “UTF-8”或“GB2312”(中文编码)，否则会抛异常）</p></blockquote><p>注意：在创建Lua文件之后，在VS里面将该文件的<strong>“复制到输出路径”设置为“如果较新则复制”</strong>，否则也会抛异常。（无法找到该文件）</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>MyLua.lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Yangjie"</span></span><br><span class="line">address = <span class="string">"HuNan"</span></span><br><span class="line">age = <span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Lua脚本内的方法"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>C#执行脚本</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lua.DoFile(<span class="string">"MyLua.lua"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> name = lua.GetString(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">string</span> address = lua.GetString(<span class="string">"address"</span>);</span><br><span class="line">Double age = lua.GetNumber(<span class="string">"age"</span>);</span><br><span class="line">Console.WriteLine(name + <span class="string">".."</span> + address + <span class="string">".."</span> + age.ToString());</span><br><span class="line"></span><br><span class="line">LuaFunction luaFunction = lua.GetFunction(<span class="string">"Fun"</span>);</span><br><span class="line">luaFunction.Call();</span><br></pre></td></tr></table></figure><h1 id="Lua调用Charp"><a href="#Lua调用Charp" class="headerlink" title="Lua调用Charp"></a>Lua调用Charp</h1><p>对于C#的项目来说，Lua脚本是作为资源存在资源路径下，我们可以对Lua脚本的进行热更新。而Lua脚本就需要访问C#脚本。在Lua中调用C#脚本需要使用<code>luanet.dll</code>这个类库。</p><p><strong>使用步骤：</strong></p><ol><li>导入luanet.dll：<code>require &quot;luanet&quot;</code></li><li>获取程序集：<code>luanet.load_assembly(&quot;程序集名&quot;)</code></li><li>获取类型：<code>变量名 = luanet.import_type(&quot;程序集名.类名&quot;)</code></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>Calc.cs（C#中创建一个类，省略了一些代码）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Calc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> name = <span class="string">"Calc计算器类"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Jia</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"这是Calc内的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LuaUpdate.lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"luanet"</span>  <span class="comment">-- 导入luanet.dll</span></span><br><span class="line">luanet.load_assembly(<span class="string">"LuaThree"</span>)  <span class="comment">-- 导入程序集</span></span><br><span class="line">Calc = luanet.import_type(<span class="string">"LuaThree.Calc"</span>) <span class="comment">-- 导入类</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Calc.Jia(<span class="number">10</span>, <span class="number">20</span>)) </span><br><span class="line"><span class="built_in">print</span>(Calc.name)</span><br></pre></td></tr></table></figure><p>Program.cs（只保留了核心代码）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lua lua = <span class="keyword">new</span> Lua();</span><br><span class="line">lua.DoFile(<span class="string">"LuaUpdate.lua"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 30</span></span><br><span class="line"><span class="comment">// 这是Calc内的方法</span></span><br></pre></td></tr></table></figure><h3 id="Lua内方法C-的类库"><a href="#Lua内方法C-的类库" class="headerlink" title="Lua内方法C#的类库"></a>Lua内方法C#的类库</h3><p>导入步骤和上面的几乎类似，比如我想导入<code>Console</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"luanet"</span> </span><br><span class="line">luanet.load_assembly(<span class="string">"System"</span>)</span><br><span class="line">Calc = luanet.import_type(<span class="string">"System.Console"</span>)</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"Lua内调用C#的类库"</span>)</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>主要资料来自擅码网Lua课程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lua与C#的交互&lt;br&gt;
    
    </summary>
    
      <category term="lua" scheme="http://yslemmo.github.io/categories/lua/"/>
    
    
      <category term="Unity" scheme="http://yslemmo.github.io/tags/Unity/"/>
    
      <category term="lua" scheme="http://yslemmo.github.io/tags/lua/"/>
    
      <category term="Charp" scheme="http://yslemmo.github.io/tags/Charp/"/>
    
  </entry>
  
  <entry>
    <title>迪杰特斯拉算法(Dijkstra)</title>
    <link href="http://yslemmo.github.io/post/Dijkstra&#39;s-algorithm-use-python.html"/>
    <id>http://yslemmo.github.io/post/Dijkstra&#39;s-algorithm-use-python.html</id>
    <published>2018-04-22T07:08:45.000Z</published>
    <updated>2019-03-18T10:49:03.915Z</updated>
    
    <content type="html"><![CDATA[<p>迪克斯特拉算法（英语：Dijkstra’s algorithm）是采用了「广度优先搜索」解决在“加权图”中最短路径的问题</p><a id="more"></a><h1 id="理解迪克斯特拉算法"><a href="#理解迪克斯特拉算法" class="headerlink" title="理解迪克斯特拉算法"></a>理解迪克斯特拉算法</h1><p>使用「广度优先搜索」算法，可以对「非加权图」查词最短路径</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/57363362.jpg" alt=""></p><p>但是对于「加权图」的最短路径问题，则需要使用「迪克斯特拉算法」</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/86778440.jpg" alt=""></p><p>这个图包括四个顶点（起点、A、B、终点），以及连接这些点的边，边上的数字是一点的另一点的「花销」，或者叫做权重。权重越大，花销就越大，反之，花销就越小。要找到从「起点」到「终点」的最短路径，需要在所有路径中找到「总权重」最小的一条路径。下图是我们任意寻找的一条路径，我们可以用迪克斯特拉算法在所有的路径中找出最短（优）的那条路径。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/81043504.jpg" alt=""></p><h2 id="实现迪克斯特拉算法的步骤"><a href="#实现迪克斯特拉算法的步骤" class="headerlink" title="实现迪克斯特拉算法的步骤"></a>实现迪克斯特拉算法的步骤</h2><ol><li>找出“最便宜”的节点（花销最低），即可在最短时间内到达的节点。</li><li>更新该节点的邻居的开销。</li><li>重复这个过程，直到对图中的每个节点都这样做了。</li><li>计算最终路径。</li></ol><h1 id="代码实现迪克斯特拉算法"><a href="#代码实现迪克斯特拉算法" class="headerlink" title="代码实现迪克斯特拉算法"></a>代码实现迪克斯特拉算法</h1><p>需要实现找到图2的最短路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个散列表来模拟路径图</span></span><br><span class="line">graph = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一条路径采用了两个散列表，例如["start"]表示自身节点、["a"]表示邻居节点， 6 表示自身节点前往邻居节点的花销</span></span><br><span class="line">graph[<span class="string">"start"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"start"</span>][<span class="string">"a"</span>] = <span class="number">6</span></span><br><span class="line">graph[<span class="string">"start"</span>][<span class="string">"b"</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"a"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"a"</span>][<span class="string">"fin"</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"b"</span>] = &#123;&#125;</span><br><span class="line">graph[<span class="string">"b"</span>][<span class="string">"a"</span>] = <span class="number">3</span></span><br><span class="line">graph[<span class="string">"b"</span>][<span class="string">"fin"</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">"fin"</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建节点的开销：表示从「起点」出发到该节点需要的“时间”，对于非起始节点的「子节点」我们并不知道它的花销，假设它为无穷大</span></span><br><span class="line">infinity = float(<span class="string">"inf"</span>) <span class="comment"># 表示无穷大</span></span><br><span class="line">costs = &#123;&#125;</span><br><span class="line">costs[<span class="string">"a"</span>] = <span class="number">6</span></span><br><span class="line">costs[<span class="string">"b"</span>] = <span class="number">2</span></span><br><span class="line">costs[<span class="string">"fin"</span>] = infinity</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建父节点的散列表</span></span><br><span class="line">parents = &#123;&#125;</span><br><span class="line">parents[<span class="string">"a"</span>] = <span class="string">"start"</span></span><br><span class="line">parents[<span class="string">"b"</span>] = <span class="string">"start"</span></span><br><span class="line">parents[<span class="string">"fin"</span>] = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录处理过的节点</span></span><br><span class="line">processed = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找开销最低的节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lowest_const_node</span><span class="params">(costs)</span>:</span></span><br><span class="line">    lowest_const = float(<span class="string">"inf"</span>)</span><br><span class="line">    lowest_const_node = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs:</span><br><span class="line">        cost = costs[node]</span><br><span class="line">        <span class="keyword">if</span> cost &lt; lowest_const <span class="keyword">and</span> node <span class="keyword">not</span> <span class="keyword">in</span> processed:       <span class="comment"># 如果当前节点开销更低且为处理过</span></span><br><span class="line">            lowest_const = cost                                 <span class="comment"># 将其视为开销最低的节点</span></span><br><span class="line">            lowest_const_node = node</span><br><span class="line">    <span class="keyword">return</span> lowest_const_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node = find_lowest_const_node(costs) <span class="comment"># 在未处理的节点中找出花销最小的节点</span></span><br><span class="line"><span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:              <span class="comment"># 这个while循环在所有节点都被处理过后结束</span></span><br><span class="line">    cost = costs[node]</span><br><span class="line">    neighbors = graph[node]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbors.keys():          <span class="comment"># 遍历当前节点的所有邻居</span></span><br><span class="line">        new_cost = cost + neighbors[n]</span><br><span class="line">        <span class="keyword">if</span> costs[n] &gt; new_cost:               <span class="comment"># 如果当前节点前往该邻居更近</span></span><br><span class="line">            costs[n] = new_cost                 <span class="comment"># 则更新该邻居的开销</span></span><br><span class="line">            parents[n] = node                   <span class="comment"># 同时将该邻居的父节点设置为当前节点</span></span><br><span class="line">    processed.append(node)                  <span class="comment"># 将当前节点标记为处理过</span></span><br><span class="line">    node = find_lowest_const_node(costs)    <span class="comment"># 找出接下来要处理的排名，并循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于显示输出效果    </span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> costs.items():</span><br><span class="line">    print(key + <span class="string">":"</span> + str(value))</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"\n-----------------\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> parents.items():</span><br><span class="line">    print(key + <span class="string">":"</span> + value)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/48381641.jpg" alt=""></p><p>「终点」的父节点是「a」、「a」的父节点是「b」、「b」的父节点是「start」，这样就把这个加权图的最短路径给找出来了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>广度优先搜索用于在非加权图中查找最短路径。</li><li>狄克斯特拉算法用于在加权图中查找最短路径。</li><li>仅当权重为正时狄克斯特拉算法才管用。</li><li>如果图中包含负权边，请使用贝尔曼-福德算法。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《算法图解》第7章节</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迪克斯特拉算法（英语：Dijkstra’s algorithm）是采用了「广度优先搜索」解决在“加权图”中最短路径的问题&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yslemmo.github.io/categories/Python/"/>
    
      <category term="Algorithm" scheme="http://yslemmo.github.io/categories/Python/Algorithm/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="Algorithm" scheme="http://yslemmo.github.io/tags/Algorithm/"/>
    
      <category term="Map" scheme="http://yslemmo.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>[生存之战]_背包合成模块制作总结</title>
    <link href="http://yslemmo.github.io/post/the-inventory-module-of-war-game.html"/>
    <id>http://yslemmo.github.io/post/the-inventory-module-of-war-game.html</id>
    <published>2018-04-13T11:56:58.000Z</published>
    <updated>2019-03-18T10:49:03.915Z</updated>
    
    <content type="html"><![CDATA[<p>断断续续花了半个月的时间，把《生存之战》背包系统大概做出来了。这也相当于一个大项目的一个较为完整的模块，现在整理一下，也方便以后回顾。</p><a id="more"></a><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/65782005.jpg" alt=""></p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/71970226.jpg" alt=""></p><ul><li>整体上这属于一个<strong>背包系统</strong>，包括<code>1</code>的「背包模块」和<code>2</code>「合成模块」</li></ul><h2 id="背包模块"><a href="#背包模块" class="headerlink" title="背包模块"></a>背包模块</h2><p>背包模块比较简单，由一个整体的背景，背包背景子层生成固定数量的背包框，背包物体动态生成，数据是从Json的数据进行解析。</p><h2 id="合成模块"><a href="#合成模块" class="headerlink" title="合成模块"></a>合成模块</h2><p>合成模块相对比较复杂一点，整个上分为3个相对独立的部分（2.1和2.3在搭建UI层次的时候可以先分为一个，然后在拆分成2.1 和 2.3）</p><ul><li><strong>2.1</strong>是合成的类型，比如<strong>武器类</strong>可以有弓箭、长矛；而建筑类可以有窗户、门。</li><li><strong>2.2</strong>是具体的合成物品的种类，比如上面提到的弓箭、长矛等。</li><li><strong>2.3</strong>是某个物品的合成图谱，也就是说合成这个物品需要哪些原材料，在合成之前需要把原材料从背包模块拖拽到对应的图谱位置。</li><li><strong>2.4</strong>是进行合成的具体区域，当某个物品的合成图谱全部被填充好之后，才可以进行合成。</li></ul><h1 id="搭建UI布局"><a href="#搭建UI布局" class="headerlink" title="搭建UI布局"></a>搭建UI布局</h1><p>这里的UI布局是“死”的UI，先把整个的UI布局确定好，后面再根据这个UI布局进行灵活的“动态生成”，“逻辑控制”。搭建UI布局要注意的点：</p><ul><li>“大元素套小元素”，相对大的元素与覆盖在它表面的相对小的元素形成父子关系。这也是在Web开发中常常会使用到的「Div + CSS」布局的思路。</li><li>重复的子元素（比如合成图谱分类的Tab、各种的物品框）才表格布局的方法，先手动复制多个元素调试到适合的布局，再将这个元素制作成一个「预制体」，最后在代码中动态生成。</li></ul><h1 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h1><h2 id="M-V-C架构介绍"><a href="#M-V-C架构介绍" class="headerlink" title="M.V.C架构介绍"></a>M.V.C架构介绍</h2><p>在以前的案例制作中，常常会把「数据控制」「UI控制」「逻辑控制」放到一个Manager的控制脚本中，这样做的问题时，单个脚本的代码量非常庞大，管理起来不方便。因此，我们可以把UI相关的脚本分为三块：</p><ul><li><strong>数据控制[Model]</strong> (对XML、Json 读取，存储，更新…)</li></ul><ul><li><strong>界面控制[View]</strong> (组件查找，UI 数据更新…)</li><li><strong>整体逻辑[Controller]</strong> (循环生成子元素，UI 的事件处理，商品购买…)</li></ul><h3 id="迷你版MVC"><a href="#迷你版MVC" class="headerlink" title="迷你版MVC"></a>迷你版MVC</h3><p>迷你版MVC 主要应用在UI 功能模块的Panel 上，也就是模块的整体控制。</p><ul><li><strong>XxxxPanelView.cs</strong></li><li><strong>XxxxPanelController.cs</strong></li><li><strong>XxxxPanelModel.cs</strong></li></ul><p>而Panel 的子级物体还是单个脚本控制，叫做<code>XxxxItemController.cs</code>，因为子级物体逻辑相对简单，可以先不分层。</p><h3 id="使用迷你版MVC的注意事项"><a href="#使用迷你版MVC的注意事项" class="headerlink" title="使用迷你版MVC的注意事项"></a>使用迷你版MVC的注意事项</h3><ul><li>创建好MVC的三个脚本挂载到XxxPanel之后，「Controller脚本」要分别持有「View脚本」「Model脚本的引用」。因为「Controller脚本」处于主导地位。「View脚本」与「Model脚本」不直接通信。</li><li>Model脚本把加载好的数据以字段封装成属性的方式公开，Controller脚本可以调用，View的设置UI的方法也公开，通用供Controller脚本使用。</li><li>View 和Model 脚本当中的初始化操作需要放到Awake 方法内，Controller的初始化放到Start 方法内。目的是为了Controller 控制界面和数据的时候，这两个脚本必须已经初始化完毕。</li></ul><h2 id="脚本分析"><a href="#脚本分析" class="headerlink" title="脚本分析"></a>脚本分析</h2><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/54304579.jpg" alt=""></p><p>从上面的脚本关系图可以看出，整体上有两个「MVC框架」，因为我们之前已经把背包系统分为了两个模块，背包模块和合成模块，所以使用两个「MVC」分别对背包模块和合成模块进行控制：</p><ul><li>背包模块<ul><li>InventoryPanelController.cs</li><li>InventoryPanelView.cs</li><li>InventoryPanelModel.cs</li></ul></li><li>合成模块<ul><li>CraftingPanelController.cs</li><li>CraftingPanelView.cs</li><li>CraftingPanelModel.cs</li></ul></li></ul><h3 id="背包模块-1"><a href="#背包模块-1" class="headerlink" title="背包模块"></a>背包模块</h3><p>背包模块比较简单：</p><p>View层查找相关组件，并加载（Resources）生成UI所需的预制体供Controller层使用；</p><p>Model层从Json文件中解析出生成背包物体所需要的数据，并公开相应的方法让Controller使用这些数据；注意这里还创建想背包物体的「数据实体类」<code>InventoryItem.cs</code></p><p>Controller层负责调用View层和Model层的数据，循环生成UI物体</p><h3 id="合成模块-1"><a href="#合成模块-1" class="headerlink" title="合成模块"></a>合成模块</h3><p>合成模块相对于背包模块来说复杂一些，主要体现在Controller脚本中有几个子类物体的控制脚本。主要是因为北城模块的UI层次就很复杂，但是合成模块的MVC职责分工和背包模块的MVC的职责分工是一样的。</p><p>需要注意的是，「CraftingPanelController.cs」负责总的逻辑控制，而它的子物体的控制脚本只需要负责公开方法供它使用就可以的。</p><p>如果生成子类物体的时候想要初始化它的控制脚本的数据，可以在子类的控制脚本定义一个初始化的方法<code>Init（）</code>，在生成子类的之后就调用它的子类控制脚本的初始化方法，并传递必要的数据。</p><h3 id="模块间进行通信"><a href="#模块间进行通信" class="headerlink" title="模块间进行通信"></a>模块间进行通信</h3><p>两个模块进行通信，可以先把两个MVC的「Controller脚本」封装成单例，然后通过<code>XxxxPanelController.Instance.方法名()</code>的方式进行通信。</p><p>需要注意的是，模块与模块之间，最好只是两个Controller层通信，比如：》</p><blockquote><p><code>InventoryItemController.cs</code>想要调用<code>CarftingPanelController.cs</code>的方法则可以先在<code>InventoryPanelController.cs</code>声明一个公开的方法去调用<code>CarftingPanelContoller</code>的方法</p><p>然后<code>InventoryItemController.cs</code>再去调用那个公开的方法。</p></blockquote><p>这样做的目的是单一“脚本的职责”，减少脚本的耦合</p><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>在上面的脚本关系图中，最右边有两个工具类，分别是<code>ResourcesTools.cs</code>和<code>JsonTools.cs</code>，这两个脚本是在脚本编写过程中抽离出来的（在实际开发过程中，这些工具类是事先已经提供好的，可以直接进行使用，一般是“主程”编写好的），它与游戏逻辑没有直接业务关系。但是游戏逻辑需要使用到这些工具类。工具类的特点：</p><ul><li>工具类的实现有两种语法格式：密封类，结构体；最常用的还是密封类（sealed）格式；</li><li>工具类内的成员全部用static 静态关键字修饰；</li><li>工具类不需要实例对象，使用格式是：工具类名.字段名/属性名/方法名/；</li><li>工具类就是一个普通的C#类，不需要继承Mono 行为类。</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>项目文件：链接: <a href="https://pan.baidu.com/s/1yeGrQNXHshJfAWG9N9gzhA" target="_blank" rel="noopener">https://pan.baidu.com/s/1yeGrQNXHshJfAWG9N9gzhA</a> 密码: wfnk</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;断断续续花了半个月的时间，把《生存之战》背包系统大概做出来了。这也相当于一个大项目的一个较为完整的模块，现在整理一下，也方便以后回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity" scheme="http://yslemmo.github.io/categories/Unity/"/>
    
    
      <category term="Unity" scheme="http://yslemmo.github.io/tags/Unity/"/>
    
      <category term="UI" scheme="http://yslemmo.github.io/tags/UI/"/>
    
      <category term="Project" scheme="http://yslemmo.github.io/tags/Project/"/>
    
  </entry>
  
  <entry>
    <title>Python-简单的递归</title>
    <link href="http://yslemmo.github.io/post/recursion-algorithm-with-python.html"/>
    <id>http://yslemmo.github.io/post/recursion-algorithm-with-python.html</id>
    <published>2018-04-02T04:11:05.000Z</published>
    <updated>2019-02-11T13:26:10.837Z</updated>
    
    <content type="html"><![CDATA[<p>什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身称为递归调用。</p><a id="more"></a><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身成为递归调用。</p><p>“庙里的老和尚”的故事可以用来理解这种模式</p><blockquote><p>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？“从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？‘从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’” ——<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92" target="_blank" rel="noopener">维基百科</a></p></blockquote><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>使用递归函数的关键：</p><ol><li><strong>找出基线条件，退出递归函数</strong></li><li><strong>缩小问题的规模</strong></li></ol><h2 id="用递归来求和"><a href="#用递归来求和" class="headerlink" title="用递归来求和"></a>用递归来求和</h2><ul><li>用循环来求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(arr)</span>:</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> arr:</span><br><span class="line">        total += x</span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure><ul><li>用递归的求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(arr)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> arr == []:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">return</span> list[<span class="number">0</span>]+sum(list[<span class="number">1</span>:]) </span><br><span class="line"></span><br><span class="line">print(sum([<span class="number">12</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">9</span>])) </span><br><span class="line"><span class="comment"># 输入结果：42</span></span><br></pre></td></tr></table></figure><h2 id="用递归来计算列表的长度"><a href="#用递归来计算列表的长度" class="headerlink" title="用递归来计算列表的长度"></a>用递归来计算列表的长度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countElem</span><span class="params">(arr)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> arr==[]:  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+countElem(arr[<span class="number">1</span>:])  </span><br><span class="line"></span><br><span class="line">print(countElem([<span class="number">12</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">9</span>]))</span><br><span class="line"><span class="comment"># 输出结果：4</span></span><br></pre></td></tr></table></figure><h2 id="用递归来找出最大元素"><a href="#用递归来找出最大元素" class="headerlink" title="用递归来找出最大元素"></a>用递归来找出最大元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxElem</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>] <span class="keyword">if</span> arr[<span class="number">0</span>] &gt; maxElem(arr[<span class="number">1</span>:]) <span class="keyword">else</span> maxElem(arr[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">print(maxElem([<span class="number">12</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">9</span>]))</span><br><span class="line"><span class="comment"># 输出结果：17</span></span><br></pre></td></tr></table></figure><ul><li>理解<code>return-if-else</code>：这是Python支持的一种语法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"a"</span> <span class="keyword">if</span> <span class="number">1</span>&lt;<span class="number">2</span> <span class="keyword">else</span> <span class="string">"b"</span></span><br></pre></td></tr></table></figure><ul><li>在这里<code>1&lt;2</code>是判断条件，如果条件成立则返回“a”，如果条件不成立则返回“b”</li></ul><h2 id="快速排序（quick）"><a href="#快速排序（quick）" class="headerlink" title="快速排序（quick）"></a>快速排序（quick）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>] <span class="comment"># 递归条件</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line">    </span><br><span class="line"> print(quicksort([<span class="number">12</span>,<span class="number">4</span>,<span class="number">17</span>,<span class="number">9</span>]))</span><br><span class="line"> <span class="comment"># 输出结果：[4, 9, 12, 17]</span></span><br></pre></td></tr></table></figure><ul><li>基线条件：<code>2行</code>：当数组为空或者只包含一个元素，这样最后只需要原样恢复数组，不用再进行排序</li><li><code>pivot</code>是基准值，用于对其他的数进行分类</li><li><code>less</code>存储的是比<code>pivot</code>小的数组成的数组</li><li><code>greater</code>存储的是比<code>pivot</code>大的数组成的数组</li><li>快速排序的算法复杂度<code>O(n * Log n)</code></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://chenqx.github.io/2014/09/29/Algorithm-Recursive-Programming/" target="_blank" rel="noopener">递归算法详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是递归，就是自身调用自身，比如一个函数在它自己的函数体类条用它自身称为递归调用。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yslemmo.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="algorithm" scheme="http://yslemmo.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>迪米特原则</title>
    <link href="http://yslemmo.github.io/post/law-of-demeter.html"/>
    <id>http://yslemmo.github.io/post/law-of-demeter.html</id>
    <published>2018-03-26T13:13:59.000Z</published>
    <updated>2019-02-11T13:51:27.026Z</updated>
    
    <content type="html"><![CDATA[<p>迪米特原则也叫最小知道原则</p><a id="more"></a><h1 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h1><blockquote><p>一个对象应该对其他对象保持最少的了解。</p></blockquote><ul><li>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另外一个类的某一个方法的话，可以通过第三者转发这个调用。</li><li>一个对象应当对其他对象有尽可能少的了解。</li></ul><h1 id="迪米特原则的切入点"><a href="#迪米特原则的切入点" class="headerlink" title="迪米特原则的切入点"></a>迪米特原则的切入点</h1><ol><li><strong>在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</strong></li></ol><p>Unity 项目开发，不要使用public 公开字段，然后面板拖拽资源赋值这种方式。应该把字段全部private 修饰，然后public 属性公开调用。</p><ol start="2"><li><strong>迪米特原则主要是强调了类与类之间的松耦合</strong></li></ol><p>类与类之间的耦合度越低，越有利于代码的复用，一个处于低耦合的类被修改了，<br>不会对有关系的类造成影响</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/zhengzhb/article/details/7296930" target="_blank" rel="noopener">迪米特原则</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迪米特原则也叫最小知道原则&lt;/p&gt;
    
    </summary>
    
      <category term="OOP" scheme="http://yslemmo.github.io/categories/OOP/"/>
    
    
      <category term="OOP六大原则" scheme="http://yslemmo.github.io/tags/OOP%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="Design Pattern" scheme="http://yslemmo.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>依赖倒置原则</title>
    <link href="http://yslemmo.github.io/post/dependence-inversion-principle.html"/>
    <id>http://yslemmo.github.io/post/dependence-inversion-principle.html</id>
    <published>2018-03-26T12:44:56.000Z</published>
    <updated>2019-03-18T10:49:03.915Z</updated>
    
    <content type="html"><![CDATA[<p>针对抽象编程，不要针对实现编程；</p><a id="more"></a><h1 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h1><blockquote><p><em>A. High-level modules should not depend on low-level modules. Both should depend on abstractions.</em></p><p>B. Abstractions should not depend on details. Details should depend on abstractions.</p></blockquote><ul><li><p>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">抽象接口</a>)。</p><p><em>模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</em></p></li><li><p>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</p></li></ul><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>参考擅码网的讲解</p><h2 id="PHP中的依赖倒置原则"><a href="#PHP中的依赖倒置原则" class="headerlink" title="PHP中的依赖倒置原则"></a>PHP中的依赖倒置原则</h2><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/79150972.jpg" alt=""></p><p>代码逻辑并不是直接操控数据库，而是通过一个抽象的<code>PDO类</code>来进行增删改查，这样的好处是如果要更改使用的数据库类型，比如原本是使用「MySQL」，现在要改成「SQLite」，只需要对<code>PDO类</code>更改操作数据库的逻辑，而关键的「代码逻辑」不需要发生任何变化。</p><h2 id="Unity引擎的依赖倒置"><a href="#Unity引擎的依赖倒置" class="headerlink" title="Unity引擎的依赖倒置"></a>Unity引擎的依赖倒置</h2><p>Unity引擎的跨平台性很强</p><ol><li>早期开发游戏</li></ol><blockquote><ul><li>Android 平台的游戏，需要使用Eclipse 开发，只能运行于Android 平台；</li><li>IOS 平台的游戏，需要使用XCode 开发，只能运行于IOS 平台；</li><li>因为编写这些游戏时，使用的代码，都是各个平台提供的针对性的API。</li><li><strong>高层依赖于底层：开发游戏需要依赖于该平台的底层API。</strong></li></ul></blockquote><ol start="2"><li>Unity开发游戏</li></ol><blockquote><ul><li>使用C#开发一个版本，稍作调整就能发布到N 个平台。在我们发布成不同平台的游戏的时候，Unity 本身就做了一个“对接”的任务，把我们的代码里面的API，对接到该平台上相应的API。</li><li><strong>高层和底层都依赖于抽象：我们的游戏是依赖Unity 的，各个平台的API 也是Unity 完成对接任务的。</strong></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对抽象编程，不要针对实现编程；&lt;/p&gt;
    
    </summary>
    
      <category term="OOP" scheme="http://yslemmo.github.io/categories/OOP/"/>
    
    
      <category term="OOP六大原则" scheme="http://yslemmo.github.io/tags/OOP%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="Design Pattern" scheme="http://yslemmo.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>开闭原则</title>
    <link href="http://yslemmo.github.io/post/open-closed-princicle.html"/>
    <id>http://yslemmo.github.io/post/open-closed-princicle.html</id>
    <published>2018-03-26T12:17:42.000Z</published>
    <updated>2019-02-11T13:18:51.706Z</updated>
    
    <content type="html"><![CDATA[<p><strong>开闭原则</strong> 规定“<em>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的</em>”</p><a id="more"></a><blockquote><p>定义：软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。</p></blockquote><ul><li>面对需求，对程序的改动应该是以增加新代码的方式解决，而不是更改旧的代码。</li><li>在实际开发过程中，开发的某个功能，可能因为需求有变化，要重新构建新的代码。但是原来的代码也不能删掉，如果之后需求再发生变化，又要换到之前的代码，则只需要简单更换一个业务逻辑即可。</li><li>开放封闭原则，其中的封闭不是绝对的封闭。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;开闭原则&lt;/strong&gt; 规定“&lt;em&gt;软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的&lt;/em&gt;”&lt;/p&gt;
    
    </summary>
    
      <category term="OOP" scheme="http://yslemmo.github.io/categories/OOP/"/>
    
    
      <category term="OOP六大原则" scheme="http://yslemmo.github.io/tags/OOP%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="Design Pattern" scheme="http://yslemmo.github.io/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>使用Jieba库制作统计水浒传角色的词频</title>
    <link href="http://yslemmo.github.io/post/role-name-count-in-shuihu-use-Jieba.html"/>
    <id>http://yslemmo.github.io/post/role-name-count-in-shuihu-use-Jieba.html</id>
    <published>2018-03-25T05:38:17.000Z</published>
    <updated>2019-02-11T13:33:01.761Z</updated>
    
    <content type="html"><![CDATA[<p>这是学习Python一个星期依赖独立制作的一个比较小的案例脚本，计算一段文本的「词频」</p><a id="more"></a><h1 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h1><p>统计出某一文本中词条的词频。这个案例我是用水浒传文本来统计出每一名角色(108将)出现的次数</p><h1 id="案例知识点"><a href="#案例知识点" class="headerlink" title="案例知识点"></a>案例知识点</h1><ul><li>使用<code>Jieba模块</code>分词</li><li>使用<code>json模块</code>将字典导出成<code>json文本</code></li><li>Python的<code>IO操作</code></li></ul><h1 id="案例准备"><a href="#案例准备" class="headerlink" title="案例准备"></a>案例准备</h1><ul><li>Windows 10</li><li>Python 3.6</li><li>安装好JieBa库</li><li>《水浒传》.txt文本</li><li>水浒108将.txt文本</li></ul><h2 id="项目文件结构"><a href="#项目文件结构" class="headerlink" title="项目文件结构"></a>项目文件结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── namerate.json</span><br><span class="line">├── RoleCount.py</span><br><span class="line">├── role.txt</span><br><span class="line">└── shuihu.txt</span><br></pre></td></tr></table></figure><h2 id="安装JieBa库"><a href="#安装JieBa库" class="headerlink" title="安装JieBa库"></a>安装JieBa库</h2><blockquote><p>jieba 是一个python实现的分词库，对中文有着很强大的分词能力。</p><p>Git链接：<a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">https://github.com/fxsjy/jieba</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py -3 -m pip install Jieba</span><br></pre></td></tr></table></figure><h2 id="处理素材文本"><a href="#处理素材文本" class="headerlink" title="处理素材文本"></a>处理素材文本</h2><p>“水浒传.txt”不需要额外处理，但是“108将”需要使用「正则表达式」进行处理，处理结果最后应该是，每一行文本只有一个将领的名字。</p><h1 id="实验脚本"><a href="#实验脚本" class="headerlink" title="实验脚本"></a>实验脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 108将字典</span></span><br><span class="line">roles = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储水浒所有的文本</span></span><br><span class="line">shuihu_str = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入文件的名字</span></span><br><span class="line">filename = <span class="string">'namerate.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把108将添加到jieba词库中去</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddWords</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> roles:</span><br><span class="line">        jieba.add_word(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开role文本，创建字典</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"role.txt"</span>, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> file_Object:</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> file_Object:</span><br><span class="line">        roles[name.strip()] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">AddWords()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开shuihu文本，存储到shuihu_str变量中去</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"shuihu.txt"</span>, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> file_Object:</span><br><span class="line">    lines = file_Object.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        shuihu_str += line.strip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分词匹配</span></span><br><span class="line">seg_list = jieba.cut(shuihu_str, cut_all=<span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> seg_list:</span><br><span class="line">    <span class="keyword">for</span> role <span class="keyword">in</span> roles:</span><br><span class="line">        <span class="keyword">if</span>(role == word):</span><br><span class="line">            roles[role] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"匹配完毕"</span>)</span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    f_obj.write(json.dumps(roles, ensure_ascii=<span class="keyword">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Cmd窗口输出字典</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> roles.items():</span><br><span class="line">    print(key)</span><br></pre></td></tr></table></figure><h1 id="案例制作总结"><a href="#案例制作总结" class="headerlink" title="案例制作总结"></a>案例制作总结</h1><p>这个项目遇到的最大的问题是“中文字符”的编码问题，比如在<code>30行</code>open的文本无法与str相加，可能是字符编码不相同，存储字典到<code>.json</code>的中文字符也是乱码的。    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是学习Python一个星期依赖独立制作的一个比较小的案例脚本，计算一段文本的「词频」&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yslemmo.github.io/categories/Python/"/>
    
      <category term="Module" scheme="http://yslemmo.github.io/categories/Python/Module/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="Module" scheme="http://yslemmo.github.io/tags/Module/"/>
    
      <category term="案例" scheme="http://yslemmo.github.io/tags/%E6%A1%88%E4%BE%8B/"/>
    
      <category term="自然语言处理" scheme="http://yslemmo.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>使用bat脚本一键部署Hexo文章</title>
    <link href="http://yslemmo.github.io/post/create-new-article-with-bat.html"/>
    <id>http://yslemmo.github.io/post/create-new-article-with-bat.html</id>
    <published>2018-03-25T04:01:38.000Z</published>
    <updated>2019-03-18T10:49:03.915Z</updated>
    
    <content type="html"><![CDATA[<p>使用「Alt Run」和「Bat」脚本实现写Hexo文档的一键部署</p><a id="more"></a><p>每次用Hexo写文章，都需要先打开<code>Cmd</code>窗口转到D盘的Hexo的路径下，然后运行<code>hexo new **</code>，再定位到<code>_post</code>路径用「Typor」打开，最后还要使用<code>hexo g</code> <code>hexo s</code>等命令去部署，写一篇文档之前要浪费这样时间，尤其是复杂的操作降低了写作的积极性。为了减少操作，想到可以用脚本来代替自己的手动操作。最后使用alt run来打开脚本，更加快捷。</p><h1 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h1><ul><li>Win10 操作系统</li><li>Hexo 博客</li><li>ALT Run：快速启动软件</li><li>编写的Bat脚本</li></ul><h1 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h1><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/27235033.jpg" alt=""></p><h2 id="一键创建文章"><a href="#一键创建文章" class="headerlink" title="一键创建文章"></a>一键创建文章</h2><ol><li>创建Hexo文章.bat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> /p name=input pages name:</span><br><span class="line"><span class="built_in">echo</span> name:%name%</span><br><span class="line"><span class="built_in">echo</span> please <span class="built_in">wait</span></span><br><span class="line">hexo new %name% &amp;&amp; call 1.bat %name%</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><ul><li>2行：从cmd窗口获取文章的名字</li><li>5行：创建从窗口获取的名字，同时调用<code>1.bat</code>这个脚本</li></ul><ol start="2"><li>1.bat脚本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start /min /w mshta vbscript:setTimeout(<span class="string">"window.close()"</span>,1000)</span><br><span class="line"><span class="built_in">echo</span> The InputValue is %1</span><br><span class="line"><span class="built_in">set</span> name=%1</span><br><span class="line"><span class="built_in">echo</span> %name%</span><br><span class="line">start /d <span class="string">"D:\Program Files\Typora\Typora.exe"</span> Typora.exe  <span class="string">"D:\Hexo\blog\source\_posts\%name%.md"</span></span><br></pre></td></tr></table></figure><ul><li>1行：延迟1秒执行</li><li>3行：「继承 创建hexo文章.bat」的变量</li><li>5行：使用D盘的「Typora.exe」MarkDown编辑器打开刚才创建好的文章</li></ul><h2 id="发布到本地服务器"><a href="#发布到本地服务器" class="headerlink" title="发布到本地服务器"></a>发布到本地服务器</h2><ol><li>发布到本地服务器.bat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start hexo_g.bat</span><br><span class="line">start /min /w mshta vbscript:setTimeout(<span class="string">"window.close()"</span>,3000)</span><br><span class="line">start hexo_s.bat</span><br></pre></td></tr></table></figure><ol start="2"><li>hexo_g.bat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><ol start="3"><li>hexo_s.bat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="发布GitHub-Page"><a href="#发布GitHub-Page" class="headerlink" title="发布GitHub Page"></a>发布GitHub Page</h2><ol><li>发布到github.bat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start clean.bat</span><br><span class="line">start /min /w mshta vbscript:setTimeout(<span class="string">"window.close()"</span>,1200)</span><br><span class="line">start hexo_d.bat</span><br></pre></td></tr></table></figure><ol start="2"><li>clean.bat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> clean</span><br><span class="line"><span class="built_in">echo</span> Please <span class="built_in">wait</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ol start="3"><li>hexo_d.bat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> postting.....</span><br><span class="line">hexo g -d</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="搭配AltRun快速启动"><a href="#搭配AltRun快速启动" class="headerlink" title="搭配AltRun快速启动"></a>搭配AltRun快速启动</h2><p>什么，AltRun都不知道是什么，那还不快去了解一下，当然也可以使用其他的快速启动软件，或者把这些脚本的快捷键放到系统环境中，使用<code>Win + Q</code>启动。</p><p><img src="https://raw.githubusercontent.com/yslemmo/Images/master/61506301.jpg" alt=""></p><p>在AltRun用到的热键：</p><ul><li>new：创建文章，并使用Typora打开</li><li>start：生成静态网页，并打开本地hexo服务器</li><li>post：用<code>hexo clean</code>清除public文件夹，并且发布到「github page」中去</li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://xiaomuins.github.io/2017/04/17/%E4%BD%BF%E7%94%A8bat%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/" target="_blank" rel="noopener">使用bat批处理脚本优化hexo的使用体验</a></li><li><a href="https://xbeta.info/altrun.htm" target="_blank" rel="noopener">AltRun快速启动工具</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用「Alt Run」和「Bat」脚本实现写Hexo文档的一键部署&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yslemmo.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yslemmo.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Pillow对图片转为字符画</title>
    <link href="http://yslemmo.github.io/post/python-learning-use-pillow.html"/>
    <id>http://yslemmo.github.io/post/python-learning-use-pillow.html</id>
    <published>2018-03-23T15:02:31.000Z</published>
    <updated>2019-02-11T13:20:26.971Z</updated>
    
    <content type="html"><![CDATA[<p>这个案例来自实验楼的学习案例<br><a id="more"></a></p><h1 id="实验知识点"><a href="#实验知识点" class="headerlink" title="实验知识点"></a>实验知识点</h1><ol><li>pillow 库的使用</li><li>argparse 库的使用</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个解析对象</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向对象中添加要关注的命令行参数和选项</span></span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'file'</span>)     <span class="comment">#输入文件</span></span><br><span class="line">parser.add_argument(<span class="string">'-o'</span>, <span class="string">'--output'</span>)   <span class="comment">#输出文件</span></span><br><span class="line">parser.add_argument(<span class="string">'--width'</span>, type = int, default = <span class="number">80</span>) <span class="comment">#输出字符画宽</span></span><br><span class="line">parser.add_argument(<span class="string">'--height'</span>, type = int, default = <span class="number">73</span>) <span class="comment">#输出字符画高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量存储parser对象获取到的参数</span></span><br><span class="line">IMG = args.file</span><br><span class="line">WIDTH = args.width</span><br><span class="line">HEIGHT = args.height</span><br><span class="line">OUTPUT = args.output</span><br><span class="line"></span><br><span class="line">ascii_char = list(<span class="string">"$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将256灰度映射到70个字符上</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_char</span><span class="params">(r,g,b,alpha = <span class="number">256</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> alpha == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line">    length = len(ascii_char)</span><br><span class="line">    gray = int(<span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b)</span><br><span class="line"></span><br><span class="line">    unit = (<span class="number">256.0</span> + <span class="number">1</span>)/length</span><br><span class="line">    <span class="keyword">return</span> ascii_char[int(gray/unit)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面一行代码表示模拟程序的入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    im = Image.open(IMG)</span><br><span class="line">    im = im.resize((WIDTH,HEIGHT), Image.NEAREST)</span><br><span class="line"></span><br><span class="line">    txt = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(HEIGHT):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(WIDTH):</span><br><span class="line">            txt += get_char(*im.getpixel((j,i))) <span class="comment"># 实参前面使用*号表示传递元组</span></span><br><span class="line">        txt += <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> txt</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#字符画输出到文件</span></span><br><span class="line">    <span class="keyword">if</span> OUTPUT:</span><br><span class="line">        <span class="keyword">with</span> open(OUTPUT,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(txt)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"output.txt"</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(txt)</span><br></pre></td></tr></table></figure><hr><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://www.shiyanlou.com/courses/370" target="_blank" rel="noopener">Python 图片转字符画</a></li><li><a href="http://brieflyx.me/2015/python-module/PIL-intro/" target="_blank" rel="noopener">用Python处理图像——PIL</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个案例来自实验楼的学习案例&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yslemmo.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yslemmo.github.io/tags/Python/"/>
    
      <category term="案例" scheme="http://yslemmo.github.io/tags/%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
</feed>
